<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Git configuration file</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Fabrice Niessen" />
<meta name="description" content="Pretty format for `git log' and different helpful command aliases"
 />
<meta name="keywords" content="git, log, pretty format, alias" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">Git configuration file</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org50a7544">Comments on branching (from Matthias)</a></li>
<li><a href="#org502b6d2"><span class="todo TODO">TODO</span> See more Git configs (and aliases)</a></li>
<li><a href="#org09bd9cc">Overview</a></li>
<li><a href="#orgc7d65d6">User&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org22cf1ad">Core&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org6c135eb">Diff&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orga518e4d">Apply&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org4efa63c">Pull&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org5ba6327">Push&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orga6da4f5">Merge&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org1672ce5">Rebase&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org1271fc7">Grep&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#orgfe018fa">Color&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org75fd75a">Proxy</a></li>
<li><a href="#org5d16ec0">Format</a></li>
<li><a href="#org41cd390">Aliases</a>
<ul>
<li><a href="#org026bd79">CREATE - Getting a Git repository</a></li>
<li><a href="#org9e9bf84">SHOW - Check the status of your files</a></li>
<li><a href="#org49a04db">SHOW - View your changes</a></li>
<li><a href="#orgd6e76c0">SHOW - View the commit history</a></li>
<li><a href="#org0f78524">SHOW - Show blame information about original authors of lines changed or removed</a></li>
<li><a href="#org9f96a7d">SHOW - Search for commits</a></li>
<li><a href="#orgef3887e">SHOW - find all &ldquo;unpushed&rdquo; commits for all projects in a directory</a></li>
<li><a href="#org34f3242">Grep (Print lines matching a pattern)</a></li>
<li><a href="#org648520b">Ignoring files</a></li>
<li><a href="#org1b8dd91">REVERT - Undo things</a></li>
<li><a href="#orgb3eb48d">UPDATE - Pull</a></li>
<li><a href="#org14b8c26">UPDATE - Merge</a></li>
<li><a href="#org9966428">BRANCH - Branch</a></li>
<li><a href="#org56e9c37">Stash</a></li>
<li><a href="#orga8f494e">PUBLISH - Push</a></li>
<li><a href="#orgf651dc4">PUBLISH - Find out if a change is part of a release</a></li>
<li><a href="#orgadff49c">PUBLISH - ChangeLog</a></li>
<li><a href="#org5c4a382">PUBLISH - Prepare a release</a></li>
<li><a href="#orgad9ad05">PUBLISH - Tag</a></li>
<li><a href="#org3ad986d">Debugging</a></li>
<li><a href="#org5657498">Abbreviations</a></li>
<li><a href="#org187317b">Get the Git root directory</a></li>
<li><a href="#org7d3f628">Remove deleted files</a></li>
<li><a href="#orgbf53ccb">Sync</a></li>
<li><a href="#org3fffef4">Cherrypick style recording</a></li>
<li><a href="#org4db5491">Dangling</a></li>
<li><a href="#org196573a">Tips and tricks</a></li>
<li><a href="#org16946cb"><span class="todo TODO">TODO</span> To sort out</a></li>
</ul>
</li>
<li><a href="#orgb1a5c76">What if</a></li>
<li><a href="#org84277cc">If you made a mistake</a></li>
<li><a href="#org9cad30b">Recover from problems</a>
<ul>
<li><a href="#org5872519">Review which file have conflicts</a></li>
<li><a href="#org1bf9a72">Alternative</a></li>
<li><a href="#org80f39e8">A GitHub test repository to experiment with conflicts</a></li>
</ul>
</li>
<li><a href="#org64c249d">GitHub tasks</a>
<ul>
<li><a href="#org01ec74e">Force push</a></li>
<li><a href="#org75ceb3c">Push tags</a></li>
<li><a href="#org71822f2">Get user pubkeys</a></li>
<li><a href="#org8de9442">Routine</a></li>
</ul>
</li>
<li><a href="#org2413cbd">Git workflows</a></li>
<li><a href="#orgc4c6a01">References</a></li>
<li><a href="#orga454e39">Free private repositories</a></li>
</ul>
</div>
</div>
<p>
XXX Git-extras (extra commands!)
<a href="https://github.com/tj/git-extras/blob/master/Commands.md">https://github.com/tj/git-extras/blob/master/Commands.md</a>
</p>

<p>
Squash commits:
<a href="https://bitbucket.org/blog/git-squash-commits-merging-bitbucket">https://bitbucket.org/blog/git-squash-commits-merging-bitbucket</a>
</p>

<p>
<b>Commit early, commit often</b>: it is a bad idea to do a lot of work without
committing&#x2026; But don&rsquo;t push every single commit: push when changes are tested!
</p>

<p>
Branch out often.
<a href="http://kentnguyen.com/development/visualized-git-practices-for-team/">http://kentnguyen.com/development/visualized-git-practices-for-team/</a>
(definition of git rebase)
</p>

<p>
These are common Git commands used in various situations:
</p>

<ul class="org-ul">
<li>start a working area (see also: git help tutorial)
<dl class="org-dl">
<dt>clone</dt><dd>Clone a repository into a new directory</dd>
<dt>init</dt><dd>Create an empty Git repository or reinitialize an existing one</dd>
</dl></li>

<li>work on the current change (see also: git help everyday)
<dl class="org-dl">
<dt>add</dt><dd>Add file contents to the index</dd>
<dt>mv</dt><dd>Move or rename a file, a directory, or a symlink</dd>
<dt>reset</dt><dd>Reset current HEAD to the specified state</dd>
<dt>rm</dt><dd>Remove files from the working tree and from the index</dd>
</dl></li>

<li>examine the history and state (see also: git help revisions)
<dl class="org-dl">
<dt>bisect</dt><dd>Use binary search to find the commit that introduced a bug</dd>
<dt>grep</dt><dd>Print lines matching a pattern</dd>
<dt>log</dt><dd>Show commit logs</dd>
<dt>show</dt><dd>Show various types of objects</dd>
<dt>status</dt><dd>Show the working tree status</dd>
</dl></li>

<li>grow, mark and tweak your common history
<dl class="org-dl">
<dt>branch</dt><dd>List, create, or delete branches</dd>
<dt>checkout</dt><dd>Switch branches or restore working tree files</dd>
<dt>commit</dt><dd>Record changes to the repository</dd>
<dt>diff</dt><dd>Show changes between commits, commit and working tree, etc</dd>
<dt>merge</dt><dd>Join two or more development histories together</dd>
<dt>rebase</dt><dd>Reapply commits on top of another base tip</dd>
<dt>tag</dt><dd>Create, list, delete or verify a tag object signed with GPG</dd>
</dl></li>

<li>collaborate (see also: git help workflows)
<dl class="org-dl">
<dt>fetch</dt><dd>Download objects and refs from another repository</dd>
<dt>pull</dt><dd>Fetch from and integrate with another repository or a local branch</dd>
<dt>push</dt><dd>Update remote refs along with associated objects</dd>
</dl></li>
</ul>

<div id="outline-container-org50a7544" class="outline-2">
<h2 id="org50a7544">Comments on branching (from Matthias)</h2>
<div class="outline-text-2" id="text-org50a7544">
<p>
If you have finished your work, feel free to merge the branch into master (maybe
you want to rebase your WIP branch before based on master):
</p>

<p>
The following sequence is here very helpful:
</p>

<ol class="org-ol">
<li>git checkout master</li>
<li>git pull (this makes sure that your local master branch matches the remote one)</li>
<li>git checkout WIP</li>
<li>git rebase master</li>
<li>git checkout master</li>
<li>git merge WIP</li>
</ol>

<p>
after this you can delete your local WIP branch and or if you pushed it the
remote one too.
</p>
</div>
</div>

<div id="outline-container-org502b6d2" class="outline-2">
<h2 id="org502b6d2"><span class="todo TODO">TODO</span> See more Git configs (and aliases)</h2>
<div class="outline-text-2" id="text-org502b6d2">
<ul class="org-ul">
<li><a href="https://github.com/alikins/gitconfig/blob/master/gitconfig">https://github.com/alikins/gitconfig/blob/master/gitconfig</a></li>
<li><a href="https://github.com/GitAlias/gitalias">https://github.com/GitAlias/gitalias</a></li>
</ul>
</div>
</div>

<div id="outline-container-org09bd9cc" class="outline-2">
<h2 id="org09bd9cc">Overview</h2>
<div class="outline-text-2" id="text-org09bd9cc">
<p>
The following configures interesting global settings for Git. These are stored
in the <code>.gitconfig</code> file located in the user home directory.
</p>

<div class="warning">
<p>
Note that tangling this file will override whichever <code>~/.gitconfig</code> file you
might have. So <b>BE EXTREMELY CAREFUL</b>!
</p>

</div>
</div>
</div>

<div id="outline-container-orgc7d65d6" class="outline-2">
<h2 id="orgc7d65d6">User&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org22cf1ad" class="outline-2">
<h2 id="org22cf1ad">Core&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org6c135eb" class="outline-2">
<h2 id="org6c135eb">Diff&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-orga518e4d" class="outline-2">
<h2 id="orga518e4d">Apply&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org4efa63c" class="outline-2">
<h2 id="org4efa63c">Pull&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org5ba6327" class="outline-2">
<h2 id="org5ba6327">Push&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-orga6da4f5" class="outline-2">
<h2 id="orga6da4f5">Merge&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org1672ce5" class="outline-2">
<h2 id="org1672ce5">Rebase&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org1271fc7" class="outline-2">
<h2 id="org1271fc7">Grep&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-orgfe018fa" class="outline-2">
<h2 id="orgfe018fa">Color&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>

<div id="outline-container-org75fd75a" class="outline-2">
<h2 id="org75fd75a">Proxy</h2>
<div class="outline-text-2" id="text-org75fd75a">
<div class="org-src-container">
<pre class="src src-conf">[<span class="org-type">http</span>]
    <span class="org-variable-name">proxy</span> = http://proxy-guest.forem.be:8080
</pre>
</div>
</div>
</div>

<div id="outline-container-org5d16ec0" class="outline-2">
<h2 id="org5d16ec0">Format</h2>
<div class="outline-text-2" id="text-org5d16ec0">
<div class="org-src-container">
<pre class="src src-conf">[<span class="org-type">format</span>]
    <span class="org-variable-name">pretty</span> = format:%C(yellow)%h%C(reset) %C(green)%ad%C(auto)%d%C(reset) %s %C(blue)&lt;%an&gt;%C(reset)
</pre>
</div>

<p>
See
</p>
<ul class="org-ul">
<li><a href="https://devhints.io/git-log-format">https://devhints.io/git-log-format</a> and</li>
<li><a href="https://git-scm.com/docs/pretty-formats">https://git-scm.com/docs/pretty-formats</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org41cd390" class="outline-2">
<h2 id="org41cd390">Aliases</h2>
<div class="outline-text-2" id="text-org41cd390">
<div class="org-src-container">
<pre class="src src-conf">[<span class="org-type">alias</span>]
</pre>
</div>

<p>
If you forget your aliases and don&rsquo;t want to open <code>.gitconfig</code> just to check, type
<code>git alias</code> to <b>print the current list of Git aliases</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">alias</span> = <span class="org-string">"!git config -l | grep alias | cut -c 7- | sort"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">type</span> = cat-file -t
    <span class="org-variable-name">dump</span> = cat-file -p
</pre>
</div>

<p>
(see <a href="http://gitimmersion.com/lab_11.html">http://gitimmersion.com/lab_11.html</a>)
</p>

<p>
Define:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">exec</span> = <span class="org-string">'!exec '</span>
</pre>
</div>

<p>
so that you can do things like <code>git exec make</code>.  This works because Shell aliases
are always executed in the top-level directory.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Show the diff between the latest commit and the current state</span>
    <span class="org-variable-name">d</span> = !<span class="org-string">"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">`git di $number' shows the diff between the state `$number' revisions ago and the current state</span>
    <span class="org-variable-name">di</span> = !<span class="org-string">"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Pull in remote changes for the current repository and all its submodules</span>
    <span class="org-variable-name">p</span> = !<span class="org-string">"git pull; git submodule foreach git pull origin master"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Commit all changes (all local modifications/additions/deletions).</span>
    <span class="org-variable-name">ca</span> = !git add -A &amp;&amp; git commit -av
</pre>
</div>

<p>
Clean up your commits before publishing.  Before you push your commits to the
repository, it&rsquo;s good to revise them.  You can run the git interactive rebase to
squash your commits or modify commit messages.  The goal is to publish only
clean and relevant commits, no experiments or fixing typos.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Interactive rebase with the given number of latest commits</span>
    <span class="org-variable-name">ireb</span> = <span class="org-string">"!r() { git rebase -i HEAD~$1; }; r"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Remove branches that have already been merged with master</span>
    <span class="org-variable-name">dm</span> = <span class="org-string">"!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"</span>
</pre>
</div>

<p>
So, I can do things like <code>git exec make</code>. This works because shell aliases are
always executed in the top-level directory.
</p>
</div>

<div id="outline-container-org026bd79" class="outline-3">
<h3 id="org026bd79">CREATE - Getting a Git repository</h3>
<div class="outline-text-3" id="text-org026bd79">
</div>
<div id="outline-container-org8fc39f0" class="outline-4">
<h4 id="org8fc39f0">Create a repository</h4>
<div class="outline-text-4" id="text-org8fc39f0">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">this</span> = !git init &amp;&amp; ( [[ -n $(ls) ]] || touch .gitignore ) &amp;&amp; git add . &amp;&amp; git commit -m \"Initial commit\"
</pre>
</div>
</div>
</div>

<div id="outline-container-org047db23" class="outline-4">
<h4 id="org047db23">Clone an existing repository</h4>
<div class="outline-text-4" id="text-org047db23">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Clone a repository including all submodules.</span>
    <span class="org-variable-name">cl</span> = clone --recursive
</pre>
</div>

<div class="tip">
<p>
For <b>passwordless Git pull</b> (permanently authenticating with Git repositories),
<b>use SSH</b> when cloning, and <b>add</b> your <b>public key</b> to the remote server.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org9e9bf84" class="outline-3">
<h3 id="org9e9bf84">SHOW - Check the status of your files</h3>
<div class="outline-text-3" id="text-org9e9bf84">
<p>
Give the status in the <b>short-format</b> (preceded by a line showing the <i>branch name</i>
and <i>tracking info</i>).
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">st</span> = status -s -b
</pre>
</div>

<p>
In the following example:
</p>

<pre class="example">
M  README
 M lisp/mail/rmail.el
MM ChangeLog
</pre>

<ul class="org-ul">
<li><code>README</code> is changed and <b>staged for commit</b> (it&rsquo;s <b>in the index</b>),</li>
<li><code>lisp/mail/rmail.el</code> is changed but <b>not staged for commit</b>, and</li>
<li><code>Changelog</code> is changed and staged for commit, then <b>changed again</b> and the new
change is <b>not staged for commit</b>.</li>
</ul>

<div class="note">
<p>
Staging for commit is typically done by <code>git add</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-org49a04db" class="outline-3">
<h3 id="org49a04db">SHOW - View your changes</h3>
<div class="outline-text-3" id="text-org49a04db">
</div>
<div id="outline-container-org3050de2" class="outline-4">
<h4 id="org3050de2">Changes between the working tree and the index (staged for the next commit)</h4>
<div class="outline-text-4" id="text-org3050de2">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">df</span> = diff
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">wdiff</span> = diff --word-diff
    <span class="org-variable-name">dw</span> = diff --word-diff
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb64cb0e" class="outline-4">
<h4 id="orgb64cb0e">Changes between the working tree and the latest commit (HEAD)</h4>
<div class="outline-text-4" id="text-orgb64cb0e">
<div class="org-src-container">
<pre class="src src-shell">    diff-all = diff HEAD
</pre>
</div>
</div>
</div>

<div id="outline-container-org8cba60f" class="outline-4">
<h4 id="org8cba60f">Changes between the index (staged for the next commit) and the latest commit (HEAD)</h4>
<div class="outline-text-4" id="text-org8cba60f">
<p>
Just before committing the <b>staged</b> changes, check what your commit changes:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">dc</span> = diff --cached
</pre>
</div>
</div>
</div>

<div id="outline-container-org71c5538" class="outline-4">
<h4 id="org71c5538">Precommit</h4>
<div class="outline-text-4" id="text-org71c5538">
<p>
This is a key part of my workflow. I run this before every commit to make sure
I don&rsquo;t need to use the undo commands.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">precommit</span> = diff --cached --diff-algorithm=minimal -w
</pre>
</div>
</div>
</div>

<div id="outline-container-org98cb213" class="outline-4">
<h4 id="org98cb213">Today</h4>
<div class="outline-text-4" id="text-org98cb213">
<p>
Quickly see what you&rsquo;ve done today (commits that aren&rsquo;t merges on all branches):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">today</span> = !git log --since=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty=<span class="org-string">'%C(green)%ad%C(auto) - %s'</span> --date=format:<span class="org-string">'%Y-%m-%d %a %H:%M'</span>
    <span class="org-variable-name">yesterday</span> = !git log --since=<span class="org-string">'1 day ago midnight'</span> --until=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty=<span class="org-string">'%C(green)%ad%C(auto) - %s'</span> --date=format:<span class="org-string">'%Y-%m-%d %a %H:%M'</span>
    <span class="org-variable-name">this-week</span> = !git log --since=1.weeks --author=\"$(git config user.name)\" --no-merges --all --pretty=<span class="org-string">'%C(green)%ad%C(auto) - %s'</span> --date=format:<span class="org-string">'%Y-%m-%d %a %H:%M'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">today-all</span> = !git log --since=midnight --no-merges --all
</pre>
</div>
</div>
</div>

<div id="outline-container-org619c012" class="outline-4">
<h4 id="org619c012">When</h4>
<div class="outline-text-4" id="text-org619c012">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">When was this file last updated, on each local branch.</span>
    <span class="org-variable-name">wwflu</span> = <span class="org-string">"!f() { for b in $(git rev-parse --symbolic --branches); do echo -e `git log --format=%at:%ar -1 $b -- \"$1\"`\\\\t$b; done | sort -r | cut -f2 -d: ; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org33ee95d" class="outline-4">
<h4 id="org33ee95d">Diff of branch</h4>
<div class="outline-text-4" id="text-org33ee95d">
<p>
Getting the diff of a branch since it forked from another branch, or since the
last merge.
</p>

<p>
To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">forkdiff</span> = !bash -c <span class="org-string">'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" '</span> -
</pre>
</div>

<p>
It uses <code>git merge-base</code> to determine the fork-point (the commit that is common
to both the branches) and does a <code>git diff</code> between that commit and the second
branch.
</p>

<p>
Usage:
</p>

<pre class="example">
git forkdiff &lt;forked from branch&gt; &lt;forked branch&gt; [git-diff-options]
</pre>


<p>
Example:
</p>

<pre class="example">
git forkdiff origin/master my_forked_branch --stat
</pre>
</div>
</div>

<div id="outline-container-org29c9ffb" class="outline-4">
<h4 id="org29c9ffb">Finding new commits</h4>
<div class="outline-text-4" id="text-org29c9ffb">
<p>
Diverging from <code>origin/master</code>, whatever the branch?
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">log-local</span> = log --oneline origin..HEAD
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd6e76c0" class="outline-3">
<h3 id="orgd6e76c0">SHOW - View the commit history</h3>
<div class="outline-text-3" id="text-orgd6e76c0">
<div class="note">
<p>
The <code>git log</code> command shows, by default, the &ldquo;author date&rdquo; &#x2013; not the &ldquo;committer
date&rdquo;.
</p>

</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ls</span> = log --decorate --date=short
    <span class="org-variable-name">ld</span> = log --decorate --date=relative
</pre>
</div>

<p>
List commits <b>showing changed files</b> (prettier and concise <code>whatchanged</code>):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ll</span> = log --decorate --date=short --stat
</pre>
</div>

<p>
View the Git history tree:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">tree</span> = log --decorate --all --date=short --graph
</pre>
</div>

<p>
To see real <b>timeline</b> of who is working on what and when:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">graph</span> = log --graph -10 --branches --remotes --tags --format=format:<span class="org-string">'%C(yellow)%h %C(reset) %&lt;(75,trunc)%s &lt;%cn&gt; (%cr) %C(red)%d'</span> --date-order
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ls-modified</span>  = <span class="org-string">"!git status --porcelain -uno | awk 'match($1, /M/) {print $2}'"</span>
    <span class="org-variable-name">ls-added</span>     = <span class="org-string">"!git status --porcelain -uno | awk 'match($1, /A/) {print $2}'"</span>
    <span class="org-variable-name">ls-deleted</span>   = <span class="org-string">"!git status --porcelain -uno | awk 'match($1, /D/) {print $2}'"</span>
    <span class="org-variable-name">ls-renamed</span>   = <span class="org-string">"!git status --porcelain -uno | awk 'match($1, /R/) {print $2}'"</span>
    <span class="org-variable-name">ls-copied</span>    = <span class="org-string">"!git status --porcelain -uno | awk 'match($1, /C/) {print $2}'"</span>
    <span class="org-variable-name">ls-updated</span>   = <span class="org-string">"!git status --porcelain -uno | awk 'match($1, /U/) {print $2}'"</span>
    <span class="org-variable-name">ls-staged</span>    = <span class="org-string">"!git status --porcelain -uno | grep -P '^[MA]' | awk '{ print $2 }'"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ls-del</span>  = ls-files -d
    <span class="org-variable-name">ls-mod</span>  = ls-files -m   <span class="org-comment-delimiter"># </span><span class="org-comment">This will include deleted files also.</span>
    <span class="org-variable-name">ls-new</span>  = ls-files --exclude-standard -o
    <span class="org-comment-delimiter"># </span><span class="org-comment">this one is a MUST have</span>
    <span class="org-variable-name">ls-ign</span>  = ls-files --exclude-standard -o -i
    <span class="org-variable-name">lsfiles</span> = ls-files --exclude-per-directory=.gitignore \
                     <span class="org-variable-name">--exclude-from</span>=.git/info/exclude \
                     -v -d -o -m -s -u
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">last</span> = log --decorate --date=short -1 --stat

    <span class="org-comment-delimiter"># </span><span class="org-comment">Show last x commits</span>
    <span class="org-variable-name">last</span> = !git log -$1 ${*:2} &amp;&amp; :
</pre>
</div>
</div>

<div id="outline-container-org05f6f76" class="outline-4">
<h4 id="org05f6f76">List all the changed files in a commit</h4>
<div class="outline-text-4" id="text-org05f6f76">
<p>
<b>List all the <code>changed</code> files in a commit</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">changed</span> = show --pretty=<span class="org-string">"format:"</span> --name-only
</pre>
</div>

<p>
List all the changed files <b>between 2 commits</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">diffn</span> = diff --name-only
</pre>
</div>

<p>
(See <code>git what</code> as well!)
(Use Tig?  Use git blame?)
</p>

<p>
XXX They don&rsquo;t show the same files (test with <code>git changed HEAD~1</code> and <code>git diffn HEAD~1</code>) XXX
</p>

<div class="org-src-container">
<pre class="src src-shell">git changed                             <span class="org-comment-delimiter"># </span><span class="org-comment">List files modified in last commit.</span>
git changed bAda55                      <span class="org-comment-delimiter"># </span><span class="org-comment">List files modified in this commit.</span>
git changed bAda55..ff0021              <span class="org-comment-delimiter"># </span><span class="org-comment">List files modified between those commits.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5463135" class="outline-4">
<h4 id="org5463135">Show the history of a file</h4>
<div class="outline-text-4" id="text-org5463135">
<p>
<b>List all commits</b> that changed a <b>specific file</b> (it accounts for renames!):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">filelog</span> = log --date=short --follow -C
    <span class="org-variable-name">fl</span> = log --date=short --follow -C
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">related</span> = !sh -c <span class="org-string">'git log --follow --format=format:%H $1 | xargs -L1 git diff-tree --no-commit-id --name-only -r | sort | uniq -c | sort -b -n -r'</span>
</pre>
</div>

<div class="warning">
<p>
Put a end of options character (&#x2013;) after lf and before the path!!
</p>

</div>
</div>
</div>

<div id="outline-container-org0a6f996" class="outline-4">
<h4 id="org0a6f996">Show a &ldquo;top contributors&rdquo; list</h4>
<div class="outline-text-4" id="text-org0a6f996">
<p>
Show a &ldquo;top contributors&rdquo; list (rank):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">who</span> = shortlog -n -s -e --no-merges --
</pre>
</div>

<div class="note">
<p>
The <code>--</code> signals the end of options, that the rest of the parameters are limiters.
</p>

</div>
</div>
</div>

<div id="outline-container-org1458501" class="outline-4">
<h4 id="org1458501">Inspect the commits for each edit</h4>
<div class="outline-text-4" id="text-org1458501">
<pre class="example">
git log ... | xargs -n 1 git show
</pre>
</div>
</div>
</div>

<div id="outline-container-org0f78524" class="outline-3">
<h3 id="org0f78524">SHOW - Show blame information about original authors of lines changed or removed</h3>
<div class="outline-text-3" id="text-org0f78524">
<p>
$ git blame -w  # ignores white space
$ git blame -M  # ignores moving text
$ git blame -C  # ignores moving text into other files
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">praise</span> = blame -w
    <span class="org-variable-name">archeology</span> = blame -w -C -n
    <span class="org-variable-name">whodoikill</span> = blame -w -C -n
</pre>
</div>

<p>
Extra script (called <a href="https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten">git-overwritten</a>) which shows blame information about
original authors of lines changed or removed in a given branch:
</p>

<div class="org-src-container">
<pre class="src src-shell">git overwritten feature origin/master
</pre>
</div>

<p>
This is useful when opening pull requests per GitHub Flow; you&rsquo;ll want your pull
request reviewed by colleagues but you might not be sure who to ping. With
git-overwritten you&rsquo;ll get the names of people who wrote the lines you just
changed, so you&rsquo;ll know who to @-mention when opening a pull request.
</p>

<p>
&gt; So, given a patch (or a branch) together with a &ldquo;base revision&rdquo;, you&rsquo;d get
&gt; a list of code chunks modified by that patch, then run &ldquo;annotate&rdquo; on the
&gt; base revision, and look for those code chunks, collecting the names of
&gt; corresponding authors.
</p>

<p>
Sounds like git-guilt (which I&rsquo;ve just read about today), might be
relevant: <a href="https://bitbucket.org/tpettersen/git-guilt">https://bitbucket.org/tpettersen/git-guilt</a>
</p>
</div>
</div>

<div id="outline-container-org9f96a7d" class="outline-3">
<h3 id="org9f96a7d">SHOW - Search for commits</h3>
<div class="outline-text-3" id="text-org9f96a7d">
</div>
<div id="outline-container-orge0782e3" class="outline-4">
<h4 id="orge0782e3">Whose commit message mention your regexp</h4>
<div class="outline-text-4" id="text-orge0782e3">
<p>
If you want to find all commits (<b>across all branches</b>, showing names and status
of changed files) where <b>log message</b> matches a specified pattern (regular
expression), use <code>find</code>.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">find</span> = <span class="org-string">"log --decorate -i --all --date=short --grep"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find commits by commit message.</span>
    <span class="org-variable-name">findm</span> = <span class="org-string">"!f() { git log --decorate --grep=$1 -i --all --date=short; }; f"</span>
</pre>
</div>

<p>
Add <code>--name-status</code> to show only names and status of <b>changed files</b>.
</p>

<p>
For example, to find all commits referencing bug #382:
</p>

<div class="org-src-container">
<pre class="src src-shell">git findm <span class="org-string">"Bug #382"</span>
</pre>
</div>

<p>
To find commits that match <b>either</b> of patterns (implicit <b>OR</b> semantic), you can
use:
</p>

<div class="org-src-container">
<pre class="src src-shell">git log --grep=&lt;foo&gt; --grep=&lt;bar&gt;
</pre>
</div>

<p>
To find <i>commit</i> that has <b>both</b> line matching first and line matching second
somewhere, use the <b>AND</b> semantic:
</p>

<div class="org-src-container">
<pre class="src src-shell">git log --all-match --grep=&lt;foo&gt; --grep=&lt;bar&gt;
</pre>
</div>

<p>
Show the <b>last commit</b> which <b>message matches a regex</b>:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-comment-delimiter"># </span><span class="org-comment">Show the last commit which has the word "fix" in its message.</span>
git show :/fix

<span class="org-comment-delimiter"># </span><span class="org-comment">Show the last merge commit.</span>
git show :/^Merge
</pre>
</div>
</div>
</div>

<div id="outline-container-org4576ff7" class="outline-4">
<h4 id="org4576ff7">String added/removed in Commit contents (Diff)</h4>
<div class="outline-text-4" id="text-org4576ff7">
<p>
If you want to find all commits where a <b>string</b> was <b>added or removed</b> in the <i>file
contents</i> (to be more exact: where its <b>number of occurrences changed</b> in the
source file), i.e. search the <i>commit contents</i>, use <code>-S</code>.
</p>

<p>
You can dig up commits that have, for example,
</p>
<ul class="org-ul">
<li>removed calls to a specific function, or</li>
<li>added a certain CSS classname.</li>
</ul>

<div class="warning">
<p>
If the number of times &ldquo;foo&rdquo; appears in the file is the same before and after
a commit, it will not match using <code>-S "foo"</code>.
</p>

</div>

<p>
In other words, to find the following commit:
</p>

<div class="org-src-container">
<pre class="src src-diff"><span class="org-diff-hunk-header">@@ -4211,9 +4211,10 @@</span><span class="org-diff-function"> public class MovesHandler extends EventHandlerBase {</span>
<span class="org-diff-context">      */</span>

<span class="org-diff-context">     private boolean actionsNotCompleted(final EventHandlerContext context, final String mo_id) {</span>
<span class="org-diff-context">         final Object found_mo_id =</span>
<span class="org-diff-context">                 selectDbValue(context, "activity_log", "activity_log_id", "mo_id=" + mo_id</span>
<span class="org-diff-indicator-removed">-</span><span class="org-diff-removed">                    + " AND status NOT IN ('COMPLETED-V','REJECTED','CANCELLED')");</span>
<span class="org-diff-indicator-added">+</span><span class="org-diff-added">                    + " AND status NOT IN ('COMPLETED-V','CLOSED','REJECTED','CANCELLED')");</span>
<span class="org-diff-context">         return (found_mo_id != null);</span>
     }
</pre>
</div>

<p>
you <b>need to search on &rsquo;CLOSED&rsquo;</b>.  Searching on &rsquo;COMPLETED-V&rsquo; would not bring back
that commit!
</p>

<div class="org-src-container">
<pre class="src src-shell">git log --all -S <span class="org-string">"foo"</span> --since=<span class="org-string">"1 week ago"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">whatwhen</span> = log --decorate --date=short -p -S
</pre>
</div>

<p>
Prettier <code>whatchanged</code> with full diffs based on text search:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Find commits by source code.</span>
    <span class="org-variable-name">findc</span> = <span class="org-string">"!f() { git log --decorate --date=short -S $1; }; f"</span>

    <span class="org-variable-name">grep4d</span> = !sh -c <span class="org-string">'git log -p -S'</span>$1<span class="org-string">' $2'</span> -
<span class="org-comment-delimiter"># </span><span class="org-comment">Not the best example, but: git grep4d CLOSED '*.java'</span>
</pre>
</div>

<p>
By default, <code>-S</code> accepts a string, but can be modified to accept a <b>regexp</b> with
<code>--pickaxe-regex</code>.
</p>
</div>
</div>

<div id="outline-container-org4c02caf" class="outline-4">
<h4 id="org4c02caf">Whose changes include your regexp</h4>
<div class="outline-text-4" id="text-org4c02caf">
<p>
String contained in added/removed lines from Commit contents (Diff)
</p>

<p>
With the <code>-G</code> option, the commit is shown in the log if your <b>regexp</b> search matches
any <b>line</b> that was added, removed, or changed.
</p>

<div class="org-src-container">
<pre class="src src-shell">git log --all -G <span class="org-string">"foo"</span> --since=<span class="org-string">"1 week ago"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgef3887e" class="outline-3">
<h3 id="orgef3887e">SHOW - find all &ldquo;unpushed&rdquo; commits for all projects in a directory</h3>
<div class="outline-text-3" id="text-orgef3887e">
<p>
See <a href="https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory">https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory</a>
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">status-all</span> = <span class="org-string">"!for d in `find . -name \".git\"`; do echo \"\n*** Repository: $d ***\" &amp;&amp; git --git-dir=$d --work-tree=$d/.. status | grep -q \"is ahead of\"; done"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org34f3242" class="outline-3">
<h3 id="org34f3242">Grep (Print lines matching a pattern)</h3>
<div class="outline-text-3" id="text-org34f3242">
</div>
<div id="outline-container-orgc4e272d" class="outline-4">
<h4 id="orgc4e272d">Pattern in working directory (and its subdirectories)</h4>
<div class="outline-text-4" id="text-orgc4e272d">
<p>
The advantages of <code>git grep</code> are not only its <b>speed</b>, and the fact it only searches
your project files (i.e. no files in <code>.git</code>), but also that is allows you to
interface with your repository&rsquo;s Git database; for example, for searching:
</p>

<ul class="org-ul">
<li>files registered in the index, rather than the working tree,</li>
<li>for your regexp in some files from another branch (XXX does not work? XXX).</li>
</ul>

<div class="note">
<p>
It doesn&rsquo;t search files that are not revisioned (untracked, excluded/ignored,
etc.).
</p>

</div>

<p>
Example:
</p>

<div class="org-src-container">
<pre class="src src-shell">git grep <span class="org-string">"foo"</span> -- <span class="org-string">'*.java'</span>
</pre>
</div>

<p>
More readable output, <b>with grouping</b> (like Ripgrep, <code>rg</code>):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Case-sensitive.</span>
    <span class="org-variable-name">rg</span> = <span class="org-string">"grep --break --heading --line-number"</span>
<span class="org-variable-name">grep-all</span> = <span class="org-string">"!f() { git rev-list --all | xargs git grep $1; }; f"</span>
</pre>
</div>

<p>
Broader search (<b>case-sensitive</b>), output <b>without grouping</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">`-I' = Don't match the pattern in binary files.</span>
    <span class="org-variable-name">g</span> = <span class="org-string">"grep -I"</span>
    <span class="org-variable-name">gno</span> = <span class="org-string">"grep -I --name-only"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd0524e" class="outline-4">
<h4 id="orgbd0524e">Find files that contain some terms, not necessarily on the same line</h4>
<div class="outline-text-4" id="text-orgbd0524e">
<p>
Match any of these patterns, but print matches only from files that have <i>all</i> of
them (files must have lines that match each of them):
</p>

<div class="org-src-container">
<pre class="src src-shell">git grep --all-match -e &lt;regexp&gt; -e &lt;regexp&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org648520b" class="outline-3">
<h3 id="org648520b">Ignoring files</h3>
<div class="outline-text-3" id="text-org648520b">
</div>
<div id="outline-container-org50bb81b" class="outline-4">
<h4 id="org50bb81b">List untracked files</h4>
<div class="outline-text-4" id="text-org50bb81b">
<p>
Tell if a file is being tracked:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">List all tracked files.</span>
    <span class="org-variable-name">ls-tracked</span> = ls-files -t

    <span class="org-variable-name">tracked1</span> = <span class="org-string">"!f() { tracked=$(git ls-files ${1}); if [[ -z ${tracked} ]]; then echo 'File NOT tracked (or No such file)'; else echo 'File tracked'; fi; }; f"</span>

    <span class="org-variable-name">tracked2</span> = <span class="org-string">"!f() { echo -n ${1}': '; if [[ -f ${1} ]]; then tracked=$(git ls-files ${1}); if [[ -z ${tracked} ]]; then echo 'File NOT tracked'; else echo 'File tracked'; fi; else echo 'No such file!'; fi; }; f"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">does not work!?</span>
</pre>
</div>

<div class="note">
<p>
<code>[[</code> has fewer surprises and is generally safer to use. But it is not portable &#x2013;
POSIX doesn&rsquo;t specify what it does and only some shells support it (beside bash,
I heard ksh supports it too). For example, you can do
</p>

<pre class="example">
[[ -e $b ]]
</pre>


<p>
to test whether a file exists. But with <code>[</code>, you have to quote <code>$b</code>, because it
splits the argument and expands things like <code>"a*"</code> (where <code>[[</code> takes it
literally). That has also to do with how <code>[</code> can be an external program and
receives its argument just normally like every other program (although it can
also be a builtin, but then it still has not this special handling).
</p>

</div>

<p>
List untracked <b>files ignored</b> by a <code>.gitignore</code> statement somewhere.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">List all untracked files.</span>
    <span class="org-variable-name">ls-untracked</span> = ls-files --others
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ls-ignored</span> = ls-files --others --ignored --exclude-standard
</pre>
</div>

<p>
Remove ignored files that are still on the repository:
</p>

<div class="org-src-container">
<pre class="src src-shell">git ls-ignored | xargs rm
</pre>
</div>
</div>
</div>

<div id="outline-container-org9e6a496" class="outline-4">
<h4 id="org9e6a496"><code>git ignore</code> command</h4>
<div class="outline-text-4" id="text-org9e6a496">
<p>
Quickly add a file or directory to <code>.gitignore</code>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ignore</span> = <span class="org-string">"!f() { echo $1 &gt;&gt; \"${GIT_PREFIX}.gitignore\"; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c65bda" class="outline-4">
<h4 id="org2c65bda"><code>assume-unchanged</code> command</h4>
<div class="outline-text-4" id="text-org2c65bda">
<p>
Ignore/unignore changes to <b>tracked file(s)</b> without <code>.gitignore</code>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">assume</span> = update-index --assume-unchanged
    <span class="org-variable-name">unassume</span> = update-index --no-assume-unchanged
</pre>
</div>

<p>
It has to be configured for each project member individually.
</p>

<div class="warning">
<p>
As stated in <a href="http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged">git ignore vs. exclude vs. assume-unchanged</a>,
<code>git-update-index --assume-unchanged</code> was never meant to ignore changes to tracked
files (<b>only to spare some stats</b>).  So do not suggest it as a means to achieve
that.
</p>

</div>

<p>
List ignored files (<b>marked unchanged</b>):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">assumed</span> = <span class="org-string">"!git ls-files -v | grep '^h' | cut -c 3-"</span>
</pre>
</div>

<p>
Unassume all the assumed files:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">unassumeall</span> = <span class="org-string">"!git assumed | xargs git update-index --no-assume-unchanged"</span>
</pre>
</div>

<p>
Assume all:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">assumeall</span> = <span class="org-string">"!git status -s | awk {'print $2'} | xargs git assume"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1b8dd91" class="outline-3">
<h3 id="org1b8dd91">REVERT - Undo things</h3>
<div class="outline-text-3" id="text-org1b8dd91">
<p>
&gt; The reason I don&rsquo;t commit a change immediately after I write it is
&gt; that I want to test it in real (and varied) use.  Sometimes I find
&gt; bugs and have to change it.  After some period in which it works well,
&gt; I decide it is ready to install.
</p>

<p>
That is a good reason. However, for your information there is the variant <code>git
commit --amend</code>, which as the option suggests amends the <b>current</b> commit. Just
<code>git add</code> the files you changed and run <code>git commit --amend</code>. It also lets you edit
the commit message. After discovering this option, I find I am less fearful of
making premature commits, since they are easily fixed. (But not after pushing,
of course. That way lies madness.)
</p>
</div>

<div id="outline-container-org8b3e373" class="outline-4">
<h4 id="org8b3e373">Change your last commit</h4>
<div class="outline-text-4" id="text-org8b3e373">
<p>
This will help when we need to change the most recent commit.
</p>

<div class="warning">
<p>
<code>git commit --amend</code> is a dangerous operation.  Someone might forget that the
current commit has already been pushed, and amend it anyway.  What will they do
then?
</p>

<p>
Try to push the result, see a message about non-fast-forward pushes being not
allowed, then go along the &ldquo;If pushing fails&rdquo; section (pull, resolve, commit,
push), and we&rsquo;ll have two similar commits in the history.
</p>

</div>

<p class="verse">
The key to understanding that is that Git does not rewrite history, it creates<br />
new history and calls that reality.  The commits in this history have different<br />
IDs (because the ID is the content plus the ID of its parent, changing just one<br />
commit means everything after it must change).  If you push this new history<br />
(with &#x2013;force) everyone else will have the old divergent history.  All their<br />
work will be on top of this divergent history.  They have to do the surgery to<br />
put their work on your new history.<br />
<br />
When users do a &ldquo;git pull&rdquo;, git doesn&rsquo;t store that you did a rebase (it would be<br />
nice if it did) so it assumes something has gone wrong and refuses to pull.  Git<br />
gets a human to look at the divergence and decide what to do with it.<br />
Unfortunately, most people don&rsquo;t know what to do with a divergent repository.<br />
<br />
And yes, this applies to amended commits.<br />
<br />
This is a common question answered on Stack Overflow.<br />
<a href="https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase">https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase</a><br />
<br />
This answer isn&rsquo;t specifically about rebase, but it illustrates how Git creates<br />
new history.<br />
<a href="https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938">https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938</a><br />
</p>

<p>
Modify the <b>last</b> commit, amending with the same message (without your editor
prompting you for the message you&rsquo;ve already entered):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Append additional (staged) changes to the PREVIOUS commit.</span>
    <span class="org-variable-name">fixup</span> = commit -v --amend --reuse-message HEAD
    <span class="org-comment-delimiter"># </span><span class="org-comment">fixlastcommit?</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Commit changes to current HEAD (modified and deleted files) as amended commit.</span>
    <span class="org-variable-name">plus</span> = commit -a -v --amend --reuse-message HEAD

    <span class="org-comment-delimiter"># </span><span class="org-comment">Change previous commit's message to what you type in.</span>
    <span class="org-variable-name">medit</span> = commit --amend -m

    <span class="org-comment-delimiter"># </span><span class="org-comment">Credit an author on the LATEST commit.</span>
    <span class="org-variable-name">credit</span> = <span class="org-string">"!f() { git commit --amend --author \"$1 &lt;$2&gt;\" --reuse-message HEAD; }; f"</span>
</pre>
</div>

<p>
Note that the <code>-a</code> switch which tells Git to automatically <b>stage all your changes</b>,
as if you ran <code>git add .</code> (stage all local modifications/additions) right before
the commit.
</p>

<div class="warning">
<p>
<b>Never amend a commit</b> that you&rsquo;ve <b>already pushed</b> to a remote repository.
<a href="https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message">https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message</a>
</p>

</div>

<p>
Solution for <b>amending older commits</b>:
<a href="https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit">https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit</a>
(see 1st and 2nd answers!)
</p>
</div>
</div>

<div id="outline-container-orgfd2fa59" class="outline-4">
<h4 id="orgfd2fa59">Unmodify a modified file / Undelete a deleted file</h4>
<div class="outline-text-4" id="text-orgfd2fa59">
<p>
<b>Undo</b> the local changes <b>in the working directory</b>: roll a file back to its last
committed version.
</p>

<div class="tip">
<p>
It can also recover <b>deleted files</b> &#x2013; if the deletion has not been committed.
</p>

</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">unmodify</span> = checkout --
    <span class="org-variable-name">undelete</span> = checkout --
</pre>
</div>

<div class="note">
<p>
The two dashes there (canonically called the &ldquo;bare double dashes&rdquo;) ensure that
the checkout command know that we are trying to roll back a file and not <i>change
branches</i> (the typical usage of the checkout command).
</p>

</div>

<p>
When you grab a file from a previous time, it sits <b>in your index</b>, modified.
</p>
</div>
</div>

<div id="outline-container-org9b8d416" class="outline-4">
<h4 id="org9b8d416">Unstage a staged file</h4>
<div class="outline-text-4" id="text-org9b8d416">
<p>
<b>Remove</b> the specified <b>files from the index</b> (proposed next commit, staging area):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">unstage</span> = reset HEAD --
<span class="org-comment-delimiter"># </span><span class="org-comment">OK</span>
</pre>
</div>

<p>
<code>unstage</code> is the opposite of <code>git add</code>. It lets you remove items from the staging
area.  This makes it a very useful tool when you&rsquo;re deciding which files to
stage for a commit.  If you&rsquo;ve accidentally added something to the staging area,
just use <code>unstage</code> to remove it.
</p>
</div>
</div>

<div id="outline-container-orgdcd2226" class="outline-4">
<h4 id="orgdcd2226">Throw away a commit</h4>
<div class="outline-text-4" id="text-orgdcd2226">
<p>
<a href="http://www.vogella.com/tutorials/Git/article.html#resetcommits">http://www.vogella.com/tutorials/Git/article.html#resetcommits</a>
<a href="http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified">http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified</a>
<a href="http://git-scm.com/2011/07/11/reset.html">http://git-scm.com/2011/07/11/reset.html</a>
</p>

<p>
<code>git reset</code> is a simple way to undo changes that haven&rsquo;t been shared with anyone
else.
</p>

<p>
See « Undo &rsquo;git add&rsquo; before commit ».
</p>
</div>

<div id="outline-container-orgf893f81" class="outline-5">
<h5 id="orgf893f81">Do not touch the index file or the working tree at all</h5>
<div class="outline-text-5" id="text-orgf893f81">
<p>
Go back before last commit, with files in uncommitted state:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">uncommit</span> = reset --soft HEAD~1
<span class="org-comment-delimiter"># </span><span class="org-comment">OK (or undolast)</span>
</pre>
</div>

<p>
<code>uncommit</code> <b>removes the last commit</b> from your repository, and <b>puts the changes into
your index</b>, keeping changes in the working directory &#x2013; it doesn&rsquo;t touch it.
It&rsquo;s like going back in time to the moment right before you committed.
</p>

<div class="note">
<p>
<code>uncommit</code> here means to do just the reverse of commit, i.e. just like commit it
shouldn&rsquo;t touch the files&rsquo;s contents, only the metadata.
</p>

</div>

<p>
This is a useful technique in resuming work on an unfinished changeset.
</p>
</div>
</div>

<div id="outline-container-orgb9dacba" class="outline-5">
<h5 id="orgb9dacba">Reset the index (but not the working tree)</h5>
<div class="outline-text-5" id="text-orgb9dacba">
<p>
Reset the previous commit, but <b>puts</b> all <b>the changes</b> from that commit <b>in the
working directory</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">undo</span> = reset --mixed HEAD~1
<span class="org-comment-delimiter"># </span><span class="org-comment">popcommit?</span>
</pre>
</div>

<div class="note">
<p>
<code>--mixed</code> with paths is deprecated; use <code>git reset -- &lt;paths&gt;</code> instead.
</p>

</div>

<p>
This is a useful technique if your pull fails to merge the new stuff from
upstream: <code>git reset HEAD~1</code>, pull again, fix the conflicts, then commit your
changes again.
</p>
</div>
</div>

<div id="outline-container-orgc63d3ee" class="outline-5">
<h5 id="orgc63d3ee">Reset both the index and working tree</h5>
<div class="outline-text-5" id="text-orgc63d3ee">
<p>
Remove the last commit, <b>delete changes in your staging area and in your working
directory</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Reset every file in your working directory to its committed state.</span>
    <span class="org-variable-name">wipe</span> = reset --hard HEAD~1
<span class="org-comment-delimiter"># </span><span class="org-comment">rollback?</span>
</pre>
</div>

<p>
If you reset work that you <i>never committed</i>, it is gone for good.  Too bad!  This
is quite a dangerous command (<code>git reset --hard</code> is one of the few Git commands
which deletes information with no backout), and must be used with <b>EXTREME
CAUTION</b>.
</p>

<div class="warning">
<p>
This command will also <b>overwrite changed files</b> in the working tree!
</p>

</div>

<div class="tip">
<p>
If you have changes in your working directory or staging area, you&rsquo;ll probably
want to stash them before doing the above.
</p>

</div>

<p>
Use <code>git reset --hard @{u}</code> to make sure the integration branch is up-to-date
before merging.
</p>

<div class="note">
<p>
<code>git reset --hard</code> will not <b>remove untracked files</b>, where as <code>git clean</code> will remove
any files from the tracked root directory that are not under Git tracking.
</p>

<p>
<b>WARNING &#x2013; BE CAREFUL WITH THIS!</b>  It is helpful to run a dry-run with <code>git clean</code>
first, to see what it will delete.
</p>

<p>
Use:
</p>
<ul class="org-ul">
<li><code>git clean -n</code> (dry run) to see what <code>git clean -f</code> will do, so you can be sure
it&rsquo;s what you want.</li>
<li><code>git clean -f</code> (to <b>remove</b> the <b>untracked files</b>) and</li>
<li><code>git clean -d -f</code> (to also <b>remove untracked directories</b> in addition to untracked
files).</li>
</ul>

</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Files and directories in .gitignore will be preserved.</span>
    <span class="org-variable-name">clear-soft</span> = !git clean -d -f &amp;&amp; git reset --hard
</pre>
</div>

<p>
which:
</p>
<ul class="org-ul">
<li>unstages changes in the index,</li>
<li>discards changes in the working directory, and</li>
<li>removes any new files.</li>
</ul>

<p>
XXX What is the difference with <code>git checkout .</code>?  See
<a href="https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout">https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout</a>.
</p>

<p>
Nuclear version:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">including those in .gitignore.</span>
    <span class="org-variable-name">clear</span> = git clean -d -f -x &amp;&amp; git reset --hard
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org55a883c" class="outline-4">
<h4 id="org55a883c">Revert a commit</h4>
<div class="outline-text-4" id="text-org55a883c">
<p>
Once you&rsquo;ve pushed changes to a remote repository, it is considered dangerous to
modify the history because someone else may have already pulled it.
</p>

<p>
However, Git offers you an easy way to undo a patch by committing a change that
effectively reverses the patch in question. The simplest usage is to revert an
entire commit:
</p>

<div class="org-src-container">
<pre class="src src-shell">git revert [hash]
</pre>
</div>

<p>
This creates a patch that is the opposite of commit <code>[hash]</code> and commits it to
your repository.
</p>

<p>
If you want to revert that commit without committing it (putting the reversion
into your index), use:
</p>

<div class="org-src-container">
<pre class="src src-shell">git revert -n [hash]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb3eb48d" class="outline-3">
<h3 id="orgb3eb48d">UPDATE - Pull</h3>
<div class="outline-text-3" id="text-orgb3eb48d">
<p>
Starting with Git 1.7.0, <code>@{u}</code> is shorthand for the <b>current</b> branch&rsquo;s <b>upstream</b>
branch; e.g., <code>origin/foo</code> (or <code>github/foo</code>, etc., since the remote doesn&rsquo;t have to
be called <code>origin</code>) if the checked out branch is <code>foo</code>.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">r</span> = remote -v
    <span class="org-variable-name">remotes</span> = remote -v
</pre>
</div>

<div class="note">
<p>
<code>git pull</code> is simply <code>git fetch &amp;&amp; git merge remote</code>.  Its <code>--rebase</code> option uses
<code>rebase</code> instead of <code>merge</code>.
</p>

<p>
That&rsquo;s exactly why some decide to avoid <code>rebase</code> (but to <code>pull</code> instead), because it
has bad effects if one merges from another branch and then wants to push.
</p>

</div>

<p>
About rebase (with visual aid):
<a href="https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395">https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395</a>
</p>

<p>
The <code>in</code> command returns a list of <b>incoming</b> commits for the <b>current branch</b> &#x2013;
after a <code>git fetch</code>, to fetch down <b>all the data</b> it has for the <b>current remote</b> that
you do not &#x2013;, the next time you do a merge.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">in</span> = !(echo <span class="org-string">"Please fetch origin before."</span> &amp;&amp; git log --decorate ..@{u})
    <span class="org-variable-name">inf</span> = !(git remote update -p              &amp;&amp; git log --decorate ..@{u})
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">in-stat</span> = log --stat ..@{u}
</pre>
</div>

<p>
Show the changes between the last local commit and the <b>remote</b> branch:
</p>

<p>
Show a <b>single diffstat</b> (number of added and deleted lines for <b>all changed
files</b>):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">in-what</span> = diff --stat ...@{u}
</pre>
</div>

<div class="warning">
<p>
The upstream diff <code>in-what</code> will show the negative of unpushed (rebased) commits,
if any, with the <code>..</code> notation &#x2014; not with the <code>...</code> notation!
</p>

</div>
</div>

<div id="outline-container-org698a4c0" class="outline-4">
<h4 id="org698a4c0">Update with local modifications</h4>
<div class="outline-text-4" id="text-org698a4c0">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">pull</span> = pull -v
</pre>
</div>

<div class="note">
<p>
<code>git pull</code> with uncommitted changes can succeed if the newly pulled changes don&rsquo;t
touch the locally changed files, but will fail otherwise.  Which makes a lot of
sense.
</p>

</div>

<p>
Git&rsquo;s fix is to ask you to commit (or stash) before you pull (which is fetch
followed by merge).
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">up = "!git stash &amp;&amp; git pull &amp;&amp; git stash pop"</span>
</pre>
</div>

<div class="warning">
<p>
The above approach is <b>unsafe</b>: if there&rsquo;s nothing to stash, the first command
will do nothing, and then <code>stash pop</code> will unstash some random stuff from before.
</p>

</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">pull-autostash</span> = ![[ -z $(git status --porcelain -uno) ]] &amp;&amp; git pull || git stash save <span class="org-string">"autostash"</span> &amp;&amp; git pull &amp;&amp; git stash pop
</pre>
</div>

<p>
XXX What about <code>git stash --include-untracked</code> and <code>git stash pop</code>?
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">up</span> = pull --rebase --autostash
    <span class="org-variable-name">up</span> = !git fetch &amp;&amp; git rebase --autostash FETCH_HEAD
</pre>
</div>

<p>
See <a href="https://www.praqma.com/stories/git-autostash/">https://www.praqma.com/stories/git-autostash/</a>.
</p>

<p>
See <a href="http://aanandprasad.com/git-up/">git-up</a> (no longer maintained), which is (roughly) equivalent of executing the following:
</p>

<div class="org-src-container">
<pre class="src src-shell">git stash
git fetch --all
[foreach branch]
    git rebase --preserve-merges &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;
    git merge --ff-only &lt;branch&gt;
[end foreach]
git checkout &lt;prev_branch&gt;
git stash pop
</pre>
</div>

<div class="warning">
<p>
Use with care: the final stash application after a successful rebase might
result in non-trivial conflicts.
</p>

</div>

<p>
With <b>all versions</b> of Git, I recommend using <code>git up</code> instead of <code>git pull</code>.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">up-tmpname</span> = <span class="org-string">"!f() { git remote update -p; git merge --ff-only @{u} ; }; f"</span>
</pre>
</div>

<p>
It is pretty safe: it will abort the merge if it can&rsquo;t be done using
fast-forward.  (In other words, if the local branch has diverged from the
remote.)
</p>

<p>
See <a href="https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful">https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful</a>
</p>

<p>
<code>remote update -p</code> <b>fetches</b> all refs from all remotes, instead of just the needed
one; <code>merge</code> then merges the appropriate <b>single branch</b>.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Rebasing non-linear changes (when the fast-forward merge is not possible).</span>
    <span class="org-variable-name">upr</span> = <span class="org-string">"!f() { git remote update -p; git rebase -p @{u} ; }; f"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf"><span class="org-comment-delimiter"># </span><span class="org-comment">cleanpull</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">update (like svn? if we add a git reset in front?)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">sync</span>
</pre>
</div>

<p>
&#x2026; but read &ldquo;you&rsquo;re not using git as it was intended&rdquo; on
<a href="https://news.ycombinator.com/item?id=2301765">https://news.ycombinator.com/item?id=2301765</a>.
</p>

<p>
Before doing work (in a new branch), <b>ensure that the working directory is</b>
<b>up-to-date</b> with the <code>origin</code> (pull and get latest for all submodules):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">update</span> = !git pull --rebase --prune $@ &amp;&amp; git submodule update --init --recursive
    <span class="org-variable-name">update</span> = !git pull                     &amp;&amp; git submodule update --init --recursive
</pre>
</div>

<p>
<a href="https://gist.github.com/gitaarik/8735255">Git Submodules basic explanation</a>
</p>
</div>
</div>

<div id="outline-container-org036a8e3" class="outline-4">
<h4 id="org036a8e3">Update all local branches</h4>
<div class="outline-text-4" id="text-org036a8e3">
<p>
Pull all:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">pull-all</span> = !<span class="org-string">"old=$(git rev-parse --abbrev-ref HEAD) ; for b in $(git for-each-ref refs/heads --format='%(refname)') ; do git checkout ${b#refs/heads/} ; git pull --ff-only ; done; git checkout ${old}"</span>
</pre>
</div>

<p>
See <a href="http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches">http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches</a>
(+ interesting comments about <b>rebase vs merge during a pull</b>!)
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-variable-name">REMOTES</span>=<span class="org-string">"$@"</span>;
<span class="org-keyword">if</span> [ -z <span class="org-string">"$REMOTES"</span> ]; <span class="org-keyword">then</span>
    <span class="org-variable-name">REMOTES</span>=$(<span class="org-sh-quoted-exec">git</span> remote);
<span class="org-keyword">fi</span>
<span class="org-variable-name">REMOTES</span>=$(<span class="org-sh-quoted-exec">echo</span> <span class="org-string">"$REMOTES"</span> | xargs -n 1 echo)

<span class="org-variable-name">CLB</span>=$(<span class="org-sh-quoted-exec">git</span> branch -l | awk <span class="org-string">'/^\*/{print $2}'</span>);

<span class="org-builtin">echo</span> <span class="org-string">"$REMOTES"</span> | <span class="org-keyword">while </span><span class="org-builtin">read</span> REMOTE; <span class="org-keyword">do</span>
    git remote update --prune $<span class="org-variable-name">REMOTE</span>
    <span class="org-builtin">echo</span>
    git remote show $<span class="org-variable-name">REMOTE</span> -n <span class="org-sh-escaped-newline">\</span>
        | awk <span class="org-string">'/merges with remote/ {print $5" "$1}'</span> <span class="org-sh-escaped-newline">\</span>
        | <span class="org-keyword">while </span><span class="org-builtin">read</span> line; <span class="org-keyword">do</span>
              <span class="org-variable-name">RB</span>=$(<span class="org-sh-quoted-exec">echo</span> <span class="org-string">"$line"</span> | cut -f1 -d<span class="org-string">" "</span>);
              <span class="org-variable-name">ARB</span>=<span class="org-string">"refs/remotes/$REMOTE/$RB"</span>;
              <span class="org-variable-name">LB</span>=$(<span class="org-sh-quoted-exec">echo</span> <span class="org-string">"$line"</span> | cut -f2 -d<span class="org-string">" "</span>);
              <span class="org-variable-name">ALB</span>=<span class="org-string">"refs/heads/$LB"</span>;
              <span class="org-variable-name">NBEHIND</span>=$(( $(<span class="org-sh-quoted-exec">git</span> rev-list --count $<span class="org-variable-name">ALB</span>..$<span class="org-variable-name">ARB</span> 2&gt; /dev/null) + 0));
              <span class="org-variable-name">NAHEAD</span>=$(( $(<span class="org-sh-quoted-exec">git</span> rev-list --count $<span class="org-variable-name">ARB</span>..$<span class="org-variable-name">ALB</span> 2&gt; /dev/null) + 0));
              <span class="org-keyword">if</span> [ <span class="org-string">"$NBEHIND"</span> -gt 0 ]; <span class="org-keyword">then</span>
                  <span class="org-keyword">if</span> [ <span class="org-string">"$NAHEAD"</span> -gt 0 ]; <span class="org-keyword">then</span>
                      <span class="org-builtin">echo</span> -e <span class="org-string">"[$LB \tis $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB.]  Not possible to fast-forward, aborting."</span>;
                  <span class="org-keyword">elif</span> [ <span class="org-string">"$LB"</span> = <span class="org-string">"$CLB"</span> ]; <span class="org-keyword">then</span>
                      <span class="org-builtin">echo</span> -e <span class="org-string">"[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Fast-forwarding merge...]"</span>;
                      <span class="org-comment-delimiter"># </span><span class="org-comment">git merge --quiet $ARB;</span>
                      git merge --ff-only --verbose $<span class="org-variable-name">ARB</span>;
                  <span class="org-keyword">else</span>
                      <span class="org-builtin">echo</span> -e <span class="org-string">"[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Resetting local branch to remote...]"</span>;
                      <span class="org-comment-delimiter"># </span><span class="org-comment">git branch -l -f $LB -t $ARB &gt; /dev/null;</span>
                      git branch -l -f $<span class="org-variable-name">LB</span> -t $<span class="org-variable-name">ARB</span>;
                  <span class="org-keyword">fi</span>
              <span class="org-keyword">else</span>
                  <span class="org-builtin">echo</span> -e <span class="org-string">"$LB \tAlready up to date."</span>;
              <span class="org-keyword">fi</span>
              <span class="org-builtin">echo</span>
          <span class="org-keyword">done</span>
<span class="org-keyword">done</span>
</pre>
</div>

<p>
XXX Is this <code>sync</code>?
</p>
</div>
</div>

<div id="outline-container-org3329ebb" class="outline-4">
<h4 id="org3329ebb">Delete all old local branches</h4>
<div class="outline-text-4" id="text-org3329ebb">
<p>
Remove local branches no longer on remote (by deleting the local ones that show
they are &ldquo;gone&rdquo; in <code>git branch -vv</code>):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Git config alias escaping...  This DOES NOT work.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">prunelocal = !sh -c 'git fetch -p &amp;&amp; git branch -vv | grep \": gone]\" | awk \"{print $1}\" | xargs git branch -d'</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Here is a correct solution (using bash as a command-line).</span>
    <span class="org-variable-name">prunelocal</span> = <span class="org-string">"!f() { git fetch -p &amp;&amp; git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -d ; }; f"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Here is a correct solution (which does not need access to the remote Git repo).</span>
    <span class="org-variable-name">prunelocal</span> = <span class="org-string">"!f() { git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -d ; }; f"</span>
</pre>
</div>

<p>
What about
</p>

<pre class="example">
git remote update --prune
</pre>


<p>
instead?
</p>
</div>
</div>

<div id="outline-container-org10ca375" class="outline-4">
<h4 id="org10ca375">Get timestamp of last pull</h4>
<div class="outline-text-4" id="text-org10ca375">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">when</span> = !stat -c %y .git/FETCH_HEAD | cut -d<span class="org-string">'.'</span> -f1
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org14b8c26" class="outline-3">
<h3 id="org14b8c26">UPDATE - Merge</h3>
<div class="outline-text-3" id="text-org14b8c26">
<p>
Merging means to <b>bring the contents of another branch</b> (possibly from an external
repository) <b>into the current branch</b>. [&#x2026;]  Merging is performed by an automatic
process that identifies changes made since the branches diverged, and then
applies all those changes together.
</p>

<pre class="example">
Merge branch 'branch_name' into master
</pre>


<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Will only try to "merge" if your current HEAD commit is in the branch</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">you're merging in.  This will allow you to merge some commits whilst being</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">sure you won't get conflicts.</span>
    <span class="org-variable-name">ff</span> = merge --ff-only
    <span class="org-variable-name">ff</span> = merge --ff-only @{u}

    <span class="org-comment-delimiter"># </span><span class="org-comment">Avoid a fast-forward commit.</span>
    <span class="org-variable-name">mm</span> = merge --no-ff
</pre>
</div>
</div>

<div id="outline-container-orga471ac1" class="outline-4">
<h4 id="orga471ac1">Undo the merge</h4>
<div class="outline-text-4" id="text-orga471ac1">
<p>
If you tried a merge which resulted in complex conflicts and want to start over,
you can recover with <code>git merge --abort</code>.  It will allow you to <b>undo the merge</b>,
even if it is a fast-forward merge.
</p>
</div>
</div>

<div id="outline-container-orgb569287" class="outline-4">
<h4 id="orgb569287">Dry run (do not make changes)</h4>
<div class="outline-text-4" id="text-orgb569287">
<p>
Naive (but slow) way:
</p>

<div class="org-src-container">
<pre class="src src-shell">rm -Rf /tmp/repository
cp -r repository /tmp/
<span class="org-builtin">cd</span> /tmp/repository
git merge ...
<span class="org-comment-delimiter"># </span><span class="org-comment">... If successful, do the real merge.</span>
</pre>
</div>

<div class="warning">
<p>
It won&rsquo;t work just cloning to <code>/tmp</code>; you need a <b>copy</b> in order <b>to be sure that
uncommitted changes will not conflict</b>.
</p>

</div>

<p>
Performing a Git merge with <b>no commit</b> and <b>no fast-forward</b> will merge the two
code bases together &#x2013; it will <b>modify your working copy</b>.  This will allow you to
examine, test, and undo the merge if required.
</p>

<div class="org-src-container">
<pre class="src src-shell">git merge --no-commit --no-ff $<span class="org-variable-name">BRANCH</span>
</pre>
</div>

<p>
You can do <code>git merge --abort</code> after seeing that there are conflicts.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">merge-check</span> = <span class="org-string">"!f() { git merge --no-commit --no-ff $1; git merge --abort; echo 'Merge aborted'; }; f"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">works for git fetch &amp; git merge</span>
</pre>
</div>

<div class="warning">
<p>
If your repository is a live Web server, then you could be serving files with
conflicts in.  That&rsquo;s why you should <b>never</b> be <b>handling merges on a live Web
server</b>!  Fix up the <code>prod</code> branch (on your development box) and then push it to
the real webserver with <code>git pull --ff-only</code>.
</p>

</div>

<p>
See if the merge is applicable to the current working tree and/or the index file
and <b>detects conflicts</b>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Check how the merge of `dev' into master will go: git merge-dry-run dev.</span>
    <span class="org-variable-name">merge-dry-run</span> = <span class="org-string">"!f() { grep -q 'changed in both' &lt;&lt;&lt; $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) &amp;&amp; echo 'Merge conflicts!' || echo 'No merge conflicts'; }; f"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">DOESN'T work for git fetch &amp; git merge</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Extract the "changed in both" lines as well as the conflicting parts.</span>
    <span class="org-variable-name">merge-dry-run-conflicts</span> = <span class="org-string">"!f() { git merge-tree $(git merge-base $1 $2) $1 $2 | sed -n '/+&lt;&lt;&lt;&lt;&lt;&lt;&lt; .our/,/+&gt;&gt;&gt;&gt;&gt;&gt;&gt; .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' | cdiff; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org376c840" class="outline-4">
<h4 id="org376c840">Branch/Integration manager</h4>
<div class="outline-text-4" id="text-org376c840">
<p>
If you&rsquo;re the Branch/Integration manager, you can use these aliases to <b>merge</b>
stuff (to select the entirety of either our or their file in a 3-way merge).
</p>

<p>
Often, during a merge, you know you want to take a file from one side wholesale.
The following aliases expose the:
</p>

<ul class="org-ul">
<li><code>ours</code> (stage #2) and</li>
<li><code>theirs</code> (stage #3)</li>
</ul>

<p>
commands which will let you pick a file(s) from
</p>

<ul class="org-ul">
<li>the current branch (local) or</li>
<li>the merged branch (remote)</li>
</ul>

<p>
respectively:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ours</span>   = <span class="org-string">"!f() { git checkout --ours   $@ &amp;&amp; git add $@; }; f"</span>
    <span class="org-variable-name">theirs</span> = <span class="org-string">"!f() { git checkout --theirs $@ &amp;&amp; git add $@; }; f"</span>
</pre>
</div>

<div class="note">
<p>
Using <code>git checkout</code> with <code>--ours</code> or <code>--theirs</code> expects at least one argument: the
<b>path(s)</b> of the <b>files / directories</b> to checkout.  If you use <code>git checkout</code> without
any files, then it takes the meaning of <i>switching branches</i>.
</p>

</div>

<p>
<b>Best (and safest) way to merge</b> a Git local branch into <code>master</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">git checkout master
git pull origin master                  <span class="org-comment-delimiter"># </span><span class="org-comment">Get the latest changes from the remote.</span>
git merge test
git push origin master

git branch -d local_branch_name         <span class="org-comment-delimiter"># </span><span class="org-comment">Delete local branch.</span>
</pre>
</div>

<div class="warning">
<p>
<b>Update first the branch (to merge in) of the RIGHT LOCAL CLONE.</b> &#x2013; if you do
have many clones on your file system.
</p>

</div>

<p>
Best answer I have seen on <code>git merge</code> <b>strategies</b>:
<a href="https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies">https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies</a>
</p>
</div>
</div>

<div id="outline-container-orga36c14d" class="outline-4">
<h4 id="orga36c14d">List conflicted files</h4>
<div class="outline-text-4" id="text-orga36c14d">
<p>
Unmerged files after a merge failure:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">conflicts</span> = <span class="org-string">"!git ls-files -u | cut -f 2 | sort -u"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9966428" class="outline-3">
<h3 id="org9966428">BRANCH - Branch</h3>
<div class="outline-text-3" id="text-org9966428">
<div class="tip">
<p>
Consistent <b>naming conventions</b> (from the <a href="https://fr.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow</a> Git workflow):
</p>
<ul class="org-ul">
<li><code>master</code> (used for deploying <b>production releases</b>)</li>
<li><code>develop</code> (used as integration branch for <b>&ldquo;next release&rdquo; development</b>)</li>
<li>prefix <code>feature/MSW-709-add-support-for-webm</code> (for new <b>features</b>, such as Jira <b>stories</b>)</li>
<li>prefix <code>release/2018-12-24</code> (used for preparing and testing <b>release</b> tasks)</li>
<li>prefix <code>hotfix/fix-123-for-production</code> (used to <b>urgently fix</b> a Production branch)</li>
<li>prefix <code>support/</code></li>
<li>prefix <code>bugfix/</code> (typically used to fix Release branches, such as Jira <b>bugs</b>)</li>
</ul>

</div>

<p>
See <a href="http://nuclearsquid.com/writings/git-tricks-tips-workflows/">http://nuclearsquid.com/writings/git-tricks-tips-workflows/</a> for more
interesting stuff, such as:
</p>

<ul class="org-ul">
<li>When branching off a remote branch, automatically let the local branch track
the remote branch.</li>

<li>When pushing without giving a refspec, push the current branch to its upstream
branch. See the git config man page for more possible options.</li>
</ul>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">co</span> = checkout
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Switch to a branch, creating it if necessary.</span>
    <span class="org-variable-name">create-branch</span> = checkout -b
</pre>
</div>

<div class="note">
<p>
I think the recommended approach is to create a branch pointing at a
specific commit. So:
</p>

<pre class="example">
git checkout -b test_branch 7e09ef09
</pre>


<p>
Otherwise you&rsquo;re in a &ldquo;detached head&rdquo; state, which can have odd results.
The branch method is at least a little more stable.
</p>

</div>

<div class="note">
<p>
I usually branch off from the commit before the offending
commit and stay there until things are resolved (unless I&rsquo;m able to
resolve it myself).
</p>

<p>
Or I branch off master and revert the offending commit until things are
resolved, ie. like so
 git checkout master
 git checkout -b sb-master
 git revert sha1-of-offending-commit
</p>

</div>

<p>
Checkout <a href="http://nvie.com/posts/a-successful-git-branching-model/">common branches</a> (useful if you have feature branches):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">master</span> = checkout master
    <span class="org-variable-name">develop</span> = checkout develop
</pre>
</div>

<p>
In case of error &ldquo;The following untracked working tree files would be
overwritten by checkout&rdquo;, <b>move the untracked files</b>, instead of <b>deleting them</b>.
For example:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-builtin">cd</span> <span class="org-string">"$(</span><span class="org-sh-quoted-exec">git</span><span class="org-string"> rev-parse --show-toplevel)"</span>
git checkout BRANCH 2&gt;&amp;1 | <span class="org-keyword">while </span><span class="org-builtin">read</span> f; <span class="org-keyword">do</span> [ <span class="org-negation-char">!</span> -e <span class="org-string">"$f"</span> ] || mv <span class="org-string">"$f"</span> <span class="org-string">"$f.bak"</span>; <span class="org-keyword">done</span>
</pre>
</div>

<p>
<b>List all branches</b> (both local remote-tracking and local branches), showing SHA1
and commit subject line for each head, along with the name of the upstream
branch (if any).
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">br</span> = branch -a -vv
</pre>
</div>

<p>
Delete a <b>local</b> branch:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">delete-local-branch</span> = branch -d
</pre>
</div>

<div class="note">
<p>
The -d (&#x2013;delete) option only deletes the branch if it has already been fully
merged in its upstream branch. You could also use -D, which is an alias
for &#x2013;delete &#x2013;force, which deletes the branch &ldquo;irrespective of its merged
status.&rdquo;
</p>

</div>

<p>
Delete a <b>remote</b> branch:
</p>

<div class="org-src-container">
<pre class="src src-shell">git push origin --delete &lt;remote_branch_name&gt;
</pre>
</div>

<p>
<code>git bclean</code> is meant to be run from your master (or default) branch and does the
cleanup of merged branches.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">bclean</span> = <span class="org-string">"!f() { git branch --merged ${1-master} | grep -v "</span> ${1-master}$<span class="org-string">" | xargs -r git branch -d; }; f"</span>
</pre>
</div>

<p>
When I&rsquo;m done with this topic branch and I want to clean everything up on my
local machine, I use <code>git bdone</code>:
</p>

<ol class="org-ol">
<li>Switch to master (though you can specify a different default branch)</li>
<li>Run git up to bring master up to speed with the origin</li>
<li>Delete all branches already merged into master using another alias,
<code>git bclean</code></li>
</ol>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">bdone</span> = <span class="org-string">"!f() { git checkout ${1-master} &amp;&amp; git up &amp;&amp; git bclean ${1-master}; }; f"</span>
</pre>
</div>

<p>
See <a href="http://haacked.com/archive/2014/07/28/github-flow-aliases/">http://haacked.com/archive/2014/07/28/github-flow-aliases/</a>.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Current branch.</span>
    <span class="org-variable-name">cb</span> = <span class="org-string">"name-rev --name-only HEAD"</span>
</pre>
</div>
</div>

<div id="outline-container-org2514f6a" class="outline-4">
<h4 id="org2514f6a">How to git diff all changes since branching from master?</h4>
<div class="outline-text-4" id="text-org2514f6a">
<p>
Show all commits in a git branch since original branching point from master:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">diffsincemaster</span> = diff master...
    <span class="org-variable-name">logsincemaster</span> = log master...
</pre>
</div>

<p>
<a href="https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git">https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git</a>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">oldest-ancestor</span> = !zsh -c <span class="org-string">'diff --old-line-format='' --new-line-format='' &lt;(git rev-list --first-parent "${1:-master}") &lt;(git rev-list --first-parent "${2:-HEAD}") | head -1'</span> -
    <span class="org-variable-name">branchdiff</span> = !sh -c <span class="org-string">'git diff $(git oldest-ancestor)..'</span>
    <span class="org-variable-name">branchlog</span>  = !sh -c <span class="org-string">'git log $(git oldest-ancestor)..'</span>

    <span class="org-variable-name">diverges</span> = !sh -c <span class="org-string">'git rev-list --boundary "${1:-HEAD}"..."${2:-master}" | grep "^-" | cut -c2-'</span>
</pre>
</div>

<p>
When you use three dots, <code>git diff</code> finds the merge-base between the left and
right side commit SHA1s (as obtained from the names, or defaulting to <code>HEAD</code>) and
substitutes that in for the left-side SHA1. The right-side SHA1 (as resolved
from the name) remains intact.
</p>
</div>
</div>

<div id="outline-container-org2286329" class="outline-4">
<h4 id="org2286329">Rename branch</h4>
<div class="outline-text-4" id="text-org2286329">
<p>
Sometimes we name a branch poorly or maybe we thought the name was &ldquo;good&rdquo; but
not meaningful to the work we are doing.
</p>

<p>
To rename the branch locally:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">rename</span> = branch -m
</pre>
</div>

<p>
One thing to keep in mind is that this command works in two different ways:
</p>

<ul class="org-ul">
<li>If we are on the branch we want to rename, we can just <code>git rename &lt;new-name&gt;</code>.</li>
<li>If we are not on the branch, we have to use <code>git rename &lt;target-branch&gt;
  &lt;new-name&gt;</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org9488dad" class="outline-4">
<h4 id="org9488dad">List branches that contain a given commit ID (SHA1)</h4>
<div class="outline-text-4" id="text-org9488dad">
<p>
Filter the list of <b>branches</b> to only those which have the given <b>commit ID</b> among
their ancestors.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">where</span> = <span class="org-string">"branch -a --contains"</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find branches containing commit.</span>
    <span class="org-variable-name">findb</span> = <span class="org-string">"!f() { git branch -a --contains $1; }; f"</span>
</pre>
</div>

<p>
This also includes <b>remote tracking branches</b> in the list, that is &ldquo;local
branches that have a direct relationship to a remote branch&rdquo;.
</p>

<p>
List all <b>tags</b> that contain a commit ID:
</p>

<div class="org-src-container">
<pre class="src src-shell">git tag --contains a2c71a6
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Find tags containing commit.</span>
    <span class="org-variable-name">findt</span> = <span class="org-string">"!f() { git describe --always --contains $1; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org51704a0" class="outline-4">
<h4 id="org51704a0">See which changes from a branch are already present upstream</h4>
<div class="outline-text-4" id="text-org51704a0">
<p>
While on &ldquo;feature&rdquo; branch:
</p>

<div class="org-src-container">
<pre class="src src-shell">git cherry -v master
</pre>
</div>

<pre class="example">
+ 497034f2 Listener.new now accepts a hash of options
- 2d0333ff cache the absolute images path for growl messages
+ e4406858 rename Listener#run to #start
</pre>

<p>
The <code>cherry</code> command is useful to see which commits have been cherry-picked from
a development branch to the stable branch, for instance. This command compares
changes on the current (<code>feature</code>) branch to upstream (<code>master</code>) and indicates which
are present on both with the <code>-</code> sign. Changes still missing from upstream are
marked with <code>+</code>.
</p>
</div>
</div>

<div id="outline-container-orgba7ad13" class="outline-4">
<h4 id="orgba7ad13">Recover a branch after its deletion in Git</h4>
<div class="outline-text-4" id="text-orgba7ad13">
<p>
Most of the time unreachable commits are in the reflog. So, the <b>first thing to
try is to look at the reflog</b> using the command <code>git reflog</code> (which display the
reflog for <code>HEAD</code>).
</p>

<ol class="org-ol">
<li>Perhaps something easier if the commit was part of a specific branch still
existing is to use the command <code>git reflog name-of-my-branch</code> to <b>find the SHA1</b>
for the commit at the tip of your deleted branch &#x2013; It works also with
a remote, for example if you forced push.  Otherwise, use <code>git reflog</code>.</li>
<li>Then, you can just <code>git checkout -b &lt;branch&gt; &lt;sha1&gt;</code> to recreate the branch
from there.</li>
</ol>

<p>
See <a href="https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git">https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org56e9c37" class="outline-3">
<h3 id="org56e9c37">Stash</h3>
<div class="outline-text-3" id="text-org56e9c37">
<p>
A <b>stash</b> is nothing but a <b>(temporary) branch</b>.
</p>

<p>
<code>git stash</code> makes a temporary copy of the changes in your <b>index</b> (staging area) and
<b>working tree</b>, and clears the decks so you can easily work on something else; it
reverts your local modifications, allowing you to get rid of some incomplete
changes.
</p>

<div class="tip">
<p>
Use <code>git stash</code> if Git refused to merge because it foresees conflicts.
</p>

</div>

<p>
Information that is used by default if you don&rsquo;t provide a message:
</p>

<pre class="example">
stash@{0}: WIP on &lt;branch&gt;: &lt;sha1 of head&gt; &lt;title line of head&gt;
</pre>

<p>
You can operate on the &ldquo;stash&rdquo; ref as if it were any other ref.
</p>
</div>

<div id="outline-container-org4657758" class="outline-4">
<h4 id="org4657758">Stash save</h4>
<div class="outline-text-4" id="text-org4657758">
<p>
<code>git stash save</code> also optionally takes a message describing the contents of the
stash (much, much more useful):
</p>

<div class="org-src-container">
<pre class="src src-conf">git stash save <span class="org-string">"DESCRIBE WHAT YOU DID HERE"</span>
</pre>
</div>

<pre class="example">
stash@{0}: On &lt;branch&gt;: DESCRIBE WHAT YOU DID HERE
</pre>

<p>
This command is useful in saving all changes not ready to be committed and the
user wants to have an updated repository.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Save with name.</span>
    <span class="org-variable-name">ss</span> = stash save
    <span class="org-variable-name">ssave</span> = stash save
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sshow</span> = <span class="org-string">"!f() { git stash show stash^{/$@} -p; }; f"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Like sapply but shows it only</span>

    <span class="org-variable-name">sapply</span> = <span class="org-string">"!f() { git stash apply stash^{/$@}; }; f"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Find stash with name like text</span>

    <span class="org-variable-name">spop</span> = <span class="org-string">"!f() { git stash pop stash@{$(git stashid $@)}; }; f"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Like sapply but pops it off</span>

    <span class="org-variable-name">stashid</span> = <span class="org-string">"!f() { git stash list | grep $@ | head -n 1 | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; }; f"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">only accepts single word, no quotations</span>

    <span class="org-variable-name">hide</span> = stash save --include-untracked <span class="org-comment-delimiter"># </span><span class="org-comment">hides all files, including untracked files (faster than using --all)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sspatch</span> = stash save --patch
    <span class="org-variable-name">ssscratch</span> = stash save --keep-index
</pre>
</div>
</div>
</div>

<div id="outline-container-org9323d9f" class="outline-4">
<h4 id="org9323d9f">Apply the stash only, don&rsquo;t delete it</h4>
<div class="outline-text-4" id="text-org9323d9f">
<p>
When you&rsquo;re done, with <code>git stash apply</code> (top stash by default), you&rsquo;re back where
you were.  But if that doesn&rsquo;t work, for whatever reason, you can use any of
Git&rsquo;s other branch merging tools to put things back they way you want them.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sa</span> = stash apply
</pre>
</div>

<p>
<a href="https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git">https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git</a>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sapply</span> = <span class="org-string">"!f() { git stash apply stash^{/$*}; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d80966" class="outline-4">
<h4 id="org7d80966">Show a list of all stashes</h4>
<div class="outline-text-4" id="text-org7d80966">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sl</span> = stash list
    <span class="org-variable-name">stashes</span> = stash list
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc08e082" class="outline-4">
<h4 id="orgc08e082">Stash pop</h4>
<div class="outline-text-4" id="text-orgc08e082">
<p>
<code>git stash pop</code> removes the most recent stash or any stash specified and applies
changes as a merge.  If merge fails, the stash is not removed from the list and
must be removed manually.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sp</span> = stash pop
</pre>
</div>

<div class="warning">
<p>
Be aware that, unlike <code>git stash apply</code> (though it has its use), <code>git stash pop</code>
<b>deletes the applied stash</b> &#x2013; <i>only</i> if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!
</p>

</div>
</div>
</div>

<div id="outline-container-org48529a7" class="outline-4">
<h4 id="org48529a7">Show the stash</h4>
<div class="outline-text-4" id="text-org48529a7">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ssh</span> = stash show -p
    <span class="org-variable-name">stashdiff</span> = stash show -p
</pre>
</div>

<p>
<a href="https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git">https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git</a>:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sshow</span> = <span class="org-string">"!f() { git stash show stash^{/$*} -p; }; f"</span>
</pre>
</div>

<p>
One very useful feature one may consider is to list contents of all local
stashes:
</p>

<div class="org-src-container">
<pre class="src src-shell">git stash list | awk -F: <span class="org-string">'{ print "\n\n\n\n"; print $0; print "\n\n"; system("git stash show -p " $1); }'</span>
</pre>
</div>

<p>
Press [Q] to exit each stash.
</p>

<p>
It helped me a lot in the past (cleaning stashes stack).
</p>
</div>
</div>

<div id="outline-container-orgf50bfd6" class="outline-4">
<h4 id="orgf50bfd6">Stash show name-only</h4>
<div class="outline-text-4" id="text-orgf50bfd6">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sshno</span> = stash show --name-only
</pre>
</div>
</div>
</div>

<div id="outline-container-org03f31d1" class="outline-4">
<h4 id="org03f31d1">Drop the stash</h4>
<div class="outline-text-4" id="text-org03f31d1">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">std</span> = stash drop
</pre>
</div>
</div>
</div>

<div id="outline-container-org9faf0ea" class="outline-4">
<h4 id="org9faf0ea">Take named stash</h4>
<div class="outline-text-4" id="text-org9faf0ea">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">snapshot</span> = !git stash save <span class="org-string">"Snapshot [$(date +\"%F %a %R\")]"</span> &amp;&amp; git stash apply <span class="org-string">"stash@{0}"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">checkpoint and checkpoint recover</span>
    <span class="org-variable-name">cp</span>      = !git stash save $(date +%F--%T) &amp;&amp; git stash pop --index
    <span class="org-variable-name">cpr</span>     = <span class="org-string">"!f() { git fsck | grep commit | cut -d' ' -f3 | while read hash; do git rev-parse --verify --no-revs --quiet $hash^2 2&gt;/dev/null &amp;&amp; echo $hash | xargs git rev-list --since=${1:-1day} -1; done | xargs -L 1 git log --format=%at:%h -1 | sort|cut -f2 -d: | xargs -L 1 git log --graph --oneline --format='%Cblue%h %Cgreen(%ar) %Creset%s' -3 ; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org063fb40" class="outline-4">
<h4 id="org063fb40">Other commands</h4>
<div class="outline-text-4" id="text-org063fb40">
<div class="org-src-container">
<pre class="src src-shell">git stash clear
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">stash-unapply</span> = !git stash show -p --no-textconv --binary | git apply -R
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">"show-branch -g=N" can't be aliased for N easily, so we stop here:</span>
    <span class="org-variable-name">sb</span>  = show-branch
    <span class="org-comment-delimiter"># </span><span class="org-comment">pg sbt master pu -- if the last line is 'master' and not 'master^'</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">or 'master~N' then pu is a descendent of master</span>
    <span class="org-variable-name">sbt</span> = show-branch --topics
    <span class="org-variable-name">sbs</span> = show-branch --sha1-name
</pre>
</div>
</div>
</div>

<div id="outline-container-org0a395db" class="outline-4">
<h4 id="org0a395db">Workflows</h4>
<div class="outline-text-4" id="text-org0a395db">
<p>
Alternative to <code>stash</code> (writing a commit with a default message):
</p>

<p>
XXX See doc of git help stash for workflows&#x2026;
</p>

<ol class="org-ol">
<li><p>
Do a regular <code>commit</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">   git add -A &amp;&amp; git commit -m <span class="org-string">'WIP'</span>       <span class="org-comment-delimiter"># </span><span class="org-comment">Add all changes (including untracked files).</span>
</pre>
</div></li>

<li>Do some other work&#x2026;</li>

<li><p>
Return to previous work:
</p>

<div class="org-src-container">
<pre class="src src-shell">   git reset --mixed                       <span class="org-comment-delimiter"># </span><span class="org-comment">Reset the previous commit (but</span>
                                           <span class="org-comment-delimiter"># </span><span class="org-comment">keeps all the changes from that</span>
                                           <span class="org-comment-delimiter"># </span><span class="org-comment">commit in the working directory).</span>

   git reset --soft                        <span class="org-comment-delimiter"># </span><span class="org-comment">Or this one???</span>
</pre>
</div>

<p>
Or, if I merely need to modify the <b>previous</b> commit:
</p>

<div class="org-src-container">
<pre class="src src-shell">   git commit -a --amend
</pre>
</div>

<p>
The <code>-a</code> adds any modifications and deletions of existing files to the commit
but ignores brand new files.
</p>

<p>
The <code>--amend</code> launches your default commit editor and lets you change the
commit message of the <b>most recent</b> commit.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org344a6bb" class="outline-4">
<h4 id="org344a6bb">From git help stash</h4>
<div class="outline-text-4" id="text-org344a6bb">
<p>
Pulling into a dirty tree
    When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple git pull will let
    you move forward.
</p>

<p>
However, there are cases in which your local changes do conflict with the upstream changes, and git pull refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:
</p>

<p>
$ git pull
 &#x2026;
file foobar not up to date, cannot merge.
$ git stash
$ git pull
$ git stash pop
</p>

<p>
Interrupted workflow
    When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to
    make the emergency fix, like this:
</p>

<p>
$ git checkout -b my_wip
$ git commit -a -m &ldquo;WIP&rdquo;
$ git checkout master
$ edit emergency fix
$ git commit -a -m &ldquo;Fix in a hurry&rdquo;
$ git checkout my_wip
$ git reset &#x2013;soft HEAD^
</p>

<p>
You can use git stash to simplify the above, like this:
</p>

<p>
$ git stash
$ edit emergency fix
$ git commit -a -m &ldquo;Fix in a hurry&rdquo;
$ git stash pop
</p>

<p>
Testing partial commits
    You can use git stash save &#x2013;keep-index when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:
</p>

<p>
$ git add &#x2013;patch foo            # add just first part to the index
$ git stash save &#x2013;keep-index    # save all other changes to the stash
$ edit/build/test first part
$ git commit -m &rsquo;First part&rsquo;     # commit fully tested change
$ git stash pop                  # prepare to work on all other changes
</p>

<p>
$ edit/build/test remaining parts
$ git commit foo -m &rsquo;Remaining parts&rsquo;
</p>

<p>
Recovering stashes that were cleared/dropped erroneously
    If you mistakenly drop or clear stashes, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stashes that are still in your repository, but not reachable any
    more:
</p>

<p>
git fsck &#x2013;unreachable |
grep commit | cut -d\  -f3 |
xargs git log &#x2013;merges &#x2013;no-walk &#x2013;grep=WIP
</p>
</div>
</div>
</div>

<div id="outline-container-orga8f494e" class="outline-3">
<h3 id="orga8f494e">PUBLISH - Push</h3>
<div class="outline-text-3" id="text-orga8f494e">
<p>
It is useful to know if you have any <b>local commits</b> that are not in the remote
branch.
</p>

<div class="note">
<p>
It is a good idea to examine what you are about to push, before actually doing
so, because fixing mistakes before pushing is much easier. To do that, use the
command &ldquo;git diff origin/master&rdquo;. If you want to show your unpushed commits with
their commit log messages, use &ldquo;git show origin/master..&rdquo; instead. If you only
have one local commit you want to push, just &ldquo;git show&rdquo; is enough.
</p>

<p>
&gt; It is not clear to me how these two differ.  Does &ldquo;git show origin/master..&rdquo;
&gt; output everything that &ldquo;git diff origin/master&rdquo; outputs, plus log messages?
</p>

<p>
Yes, that&rsquo;s the only real difference between them, when you have no uncommitted
changes.  (When you do have uncommitted changes, &ldquo;git diff&rdquo; will include them,
while &ldquo;git show&rdquo; will not.)
</p>

</div>

<p>
The <code>out</code> command returns a list of <b>unpushed</b> (outgoing) commits for the <b>current
branch</b>, the next time you do a push.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">out</span> = log --date=short @{u}..
    <span class="org-variable-name">out-stat</span> = log --stat --date=short @{u}..
</pre>
</div>

<p>
This causes <code>git log</code> to show all commits reachable from <code>HEAD</code> excluding those
reachable from the upstream branch.  The <code>@{u}..</code> argument is equivalent to
<code>@{u}..HEAD</code>, where <code>HEAD</code> stands for the last commit in your local branch, but <code>HEAD</code>
can be omitted for shorthand purposes.
</p>

<p>
If you want to see all <b>unpushed</b> commits from <b>all branches</b>, do this:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">outgoing</span> = log --branches --not --remotes --decorate
</pre>
</div>
</div>

<div id="outline-container-org0720565" class="outline-4">
<h4 id="org0720565">Upload your changes</h4>
<div class="outline-text-4" id="text-org0720565">
<p>
Use <code>git push -u origin new/branch</code> to push the <code>new/branch</code> branch to the <code>origin</code>
remote and to set up tracking.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Get the current branch name (not so useful in itself, but used in other</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">aliases).</span>
    <span class="org-variable-name">branch-name</span> = !git rev-parse --abbrev-ref HEAD

<span class="org-variable-name">upstream-name</span> = !git for-each-ref --format=<span class="org-string">'%(upstream:short)'</span> $(git symbolic-ref -q HEAD)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Push the current branch to the remote "origin", and set it to track the</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">upstream branch.</span>
    <span class="org-variable-name">publish</span> = !git push -u origin $(git branch-name)

    <span class="org-variable-name">unpublish</span> = !git push origin :$(git branch-name)
</pre>
</div>

<p>
<code>git publish</code> is a shortcut for manually typing the branch name:
</p>

<pre class="example">
git push origin -u &lt;current-branch&gt;
</pre>


<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">export-branch</span> = !git format-patch --stdout $1 &gt; ~/$(git branch-name).diff
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf651dc4" class="outline-3">
<h3 id="orgf651dc4">PUBLISH - Find out if a change is part of a release</h3>
<div class="outline-text-3" id="text-orgf651dc4">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sha1-tag</span> = <span class="org-string">'!f() { git name-rev --name-only "$@"; }; f'</span>
</pre>
</div>

<p>
The <code>name-rev</code> command indicates the <b>position of a commit relative to tags</b> in the
project. For example, <code>v2.3~5</code> means that this commit is located 5 commits <b>before</b>
the v2.3 tag &#x2013; we can be certain that this change is part of v2.3, then.
</p>
</div>
</div>

<div id="outline-container-orgadff49c" class="outline-3">
<h3 id="orgadff49c">PUBLISH - ChangeLog</h3>
<div class="outline-text-3" id="text-orgadff49c">
<p>
Generate an Org mode version of your ChangeLog:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">chlogm</span> =  !sh -c <span class="org-string">'git log $1...$2  --pretty=format:\"%s [[http://github.com/$3/$4/commit/%H][view commit]]\"'</span> -
</pre>
</div>

<p>
Use it like this:
</p>

<div class="org-src-container">
<pre class="src src-shell">git chlogm first_tag last_tag github_user github_repo
</pre>
</div>

<p>
See also <a href="https://github.com/github-changelog-generator/github-changelog-generator">https://github.com/github-changelog-generator/github-changelog-generator</a>.
</p>
</div>
</div>

<div id="outline-container-org5c4a382" class="outline-3">
<h3 id="org5c4a382">PUBLISH - Prepare a release</h3>
<div class="outline-text-3" id="text-org5c4a382">
<p>
Save a repo as a tarball:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">export</span> = archive -o latest.tar.gz -9 --prefix=latest/
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">  <span class="org-comment-delimiter"># </span><span class="org-comment"># Deploy</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">staging = !git push heroku-staging $(git name):master -f &amp;&amp; git track 'Deployed to staging ' # push current branch to staging, can add more comments after</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">dev = !git push heroku-dev $(git name):master -f &amp;&amp; git track 'Deployed to dev ' # push current branch to dev</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">deploy = !git push heroku $(git name):master -f &amp;&amp; git track 'Deployed to produciton ' # push current branch to production</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgad9ad05" class="outline-3">
<h3 id="orgad9ad05">PUBLISH - Tag</h3>
<div class="outline-text-3" id="text-orgad9ad05">
<p>
When tagging releases in a version control system, the tag for a version should
be <code>X.Y.Z</code> (<b>without</b> prefix <code>v</code>).  The advantages of <code>X.Y.Z</code> are that gitweb or GitHub
can automatically offer a tarball or zip download of the form
<code>packagename-$tag.tar.gz</code> (and it&rsquo;s quite established that a tarball should be
named <code>package-X.Y.Z.tar.gz</code>).
</p>

<p>
Basically, <b>lightweight tags</b> are just pointers to specific commits. <b>No further
information is saved</b>; on the other hand, <b>annotated tags</b> are <b>regular objects</b>,
which have an author and a date and can be referred because they have their own
SHA key.
</p>

<p>
If knowing <b>who</b> tagged <b>what</b> and <b>when</b> is relevant for you, then use annotated
tags. If you <b>just want to tag a specific point in your development</b>, no matter
who and when did that, then lightweight tags are good enough.
</p>

<div class="note">
<p>
Annotated tags are meant for release while lightweight tags are meant for
private or temporary object labels.
</p>

</div>

<div class="org-src-container">
<pre class="src src-shell">git tag &lt;tagname&gt;
</pre>
</div>

<p>
The tag will be a <b>lightweight tag</b> by default.
</p>

<p>
Show the last tag:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">version</span> = describe --tags
    <span class="org-variable-name">lasttag</span> = describe --tags --abbrev=0
</pre>
</div>

<p>
List tags using (better) version sorting (if your <code>sort</code> supports it):
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Show verbose output about tags.</span>
    <span class="org-variable-name">tags</span> = tag -l
    <span class="org-variable-name">tags</span> = !git tag | sort -V
</pre>
</div>

<p>
You can do a lot better with:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">releases</span> = log --decorate --oneline --simplify-by-decoration --all
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ad986d" class="outline-3">
<h3 id="org3ad986d">Debugging</h3>
<div class="outline-text-3" id="text-org3ad986d">
<p>
Sometimes it&rsquo;s nice to see what is going on under the hood. Try this alias:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">debug</span>  = <span class="org-string">"!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"</span>
</pre>
</div>

<p>
Just insert <code>debug</code> between <code>git</code> and whatever would usually follow; for example:
</p>

<div class="org-src-container">
<pre class="src src-shell">git debug unwip
</pre>
</div>
</div>
</div>

<div id="outline-container-org5657498" class="outline-3">
<h3 id="org5657498">Abbreviations</h3>
<div class="outline-text-3" id="text-org5657498">
<p>
Basic shortcuts.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">ci</span> = commit
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">cp</span> = cherry-pick -x
    <span class="org-variable-name">pick</span> = cherry-pick -s
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">h</span> = help
</pre>
</div>
</div>
</div>

<div id="outline-container-org187317b" class="outline-3">
<h3 id="org187317b">Get the Git root directory</h3>
<div class="outline-text-3" id="text-org187317b">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">root</span> = rev-parse --show-toplevel
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">Get the path cleaned up.</span>
    <span class="org-variable-name">root</span> = !pwd -P
</pre>
</div>

<div class="note">
<p>
This works because Shell aliases are always executed in the top-level directory.
</p>

</div>
</div>
</div>

<div id="outline-container-org7d3f628" class="outline-3">
<h3 id="org7d3f628">Remove deleted files</h3>
<div class="outline-text-3" id="text-org7d3f628">
<p>
Removing multiple files from a Git repo that have already been deleted from
disk:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">rma</span> = !git ls-files --deleted -z | xargs -0 git rm
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf53ccb" class="outline-3">
<h3 id="orgbf53ccb">Sync</h3>
<div class="outline-text-3" id="text-orgbf53ccb">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sync</span> = !git pull &amp;&amp; git push
</pre>
</div>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">sync</span> = !git update &amp;&amp; git co master &amp;&amp; git pull &amp;&amp; git commit @{-1}
</pre>
</div>

<p>
That&rsquo;s rather basic - it doesn&rsquo;t actually rebase my branch that I&rsquo;m on.
</p>

<p>
Let&rsquo;s do a slightly different command: <code>resync</code>
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">git resync -&gt; sync repository and rebase current branch.</span>
    <span class="org-variable-name">resync</span> = !sh -c <span class="org-string">'BRANCH_NAME=master &amp;&amp; git checkout master &amp;&amp; git fetch &amp;&amp; git reset --hard origin/master &amp;&amp; git rebase master'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3fffef4" class="outline-3">
<h3 id="org3fffef4">Cherrypick style recording</h3>
<div class="outline-text-3" id="text-org3fffef4">
<p>
Ask interactively which patch hunk to commit, and then do the commit:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">record</span> = !sh -c <span class="org-string">'(git add -p -- $@ &amp;&amp; git commit) || git reset'</span> --
</pre>
</div>

<p>
It will not only do <code>git add -p</code> (with an optional file list), but it will also
immediately do the <code>commit</code>. Upon abandonment of either the add or the commit, it
will <code>reset</code> the index.
</p>
</div>
</div>

<div id="outline-container-org4db5491" class="outline-3">
<h3 id="org4db5491">Dangling</h3>
<div class="outline-text-3" id="text-org4db5491">
<ul class="org-ul">
<li>Dangling blob = Change(s) that made it to the staging area/index but never got
committed. One thing that is amazing with Git is that once it gets added to
the staging area, you can always get it back because these blobs behave like
commits!!</li>

<li>Dangling commit = A commit that isn&rsquo;t linked to any branch or tag either
directly or by any of its ancestors. You can get these back too!</li>
</ul>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">lost</span> = <span class="org-string">"!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%C(reset)  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org196573a" class="outline-3">
<h3 id="org196573a">Tips and tricks</h3>
<div class="outline-text-3" id="text-org196573a">
<p>
Directed Acyclic Graph:
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">graphviz</span> = <span class="org-string">"!f() { echo 'digraph git {' ; git log --pretty='format:  %h -&gt; { %p }' \"$@\" | sed 's/[0-9a-f][0-9a-f]*/\"&amp;\"/g' ; echo '}'; }; f"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org16946cb" class="outline-3">
<h3 id="org16946cb"><span class="todo TODO">TODO</span> To sort out</h3>
<div class="outline-text-3" id="text-org16946cb">
<div class="org-src-container">
<pre class="src src-conf">    <span class="org-comment-delimiter"># </span><span class="org-comment">2009-05-26  (merged-bed-bug) 6fe85ff regenerate rules Brad Bowman</span>
    <span class="org-variable-name">logdate</span> = log --format=format:<span class="org-string">'%ad %d %h %s %an%n'</span> --date=short
    <span class="org-variable-name">br-date</span> = !<span class="org-string">"sh -c 'for b in $(git branch --no-merged) ; \</span>
<span class="org-string">               do git logdate -1 -r $b --; done'"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb1a5c76" class="outline-2">
<h2 id="orgb1a5c76">What if</h2>
<div class="outline-text-2" id="text-orgb1a5c76">
<p>
&#x2026; I&rsquo;m working on master adding a simple feature. After a few minutes I realize
it was not so simple and it should have been better to work into a new branch.
</p>

<p>
<a href="http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master">http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master</a>
</p>
</div>
</div>

<div id="outline-container-org84277cc" class="outline-2">
<h2 id="org84277cc">If you made a mistake</h2>
<div class="outline-text-2" id="text-org84277cc">
</div>
</div>

<div id="outline-container-org9cad30b" class="outline-2">
<h2 id="org9cad30b">Recover from problems</h2>
<div class="outline-text-2" id="text-org9cad30b">
<p>
It is POSSIBLE that a safe way to recover from your problems is as follows:
</p>

<div class="org-src-container">
<pre class="src src-shell">git stash
git reset --hard HEAD
git pull --ff-only
git stash apply
</pre>
</div>

<p>
Of course, if any of the commands but the last fails, stop and ask for advice
again. If the last one reports merge conflicts, fix them by hand and run <code>git add</code>
on each file after you fixed it. DO NOT use C-x v v after fixing a merge
conflict, since that runs both git add and git commit, and you are not ready for
the latter until all merge conflicts are dealt with.
</p>

<p>
In any case, do run git status before finally doing git commit. If all succeeds,
you can clean up with:
</p>

<div class="org-src-container">
<pre class="src src-shell">git stash drop
</pre>
</div>
</div>

<div id="outline-container-org5872519" class="outline-3">
<h3 id="org5872519">Review which file have conflicts</h3>
<div class="outline-text-3" id="text-org5872519">
<p>
This command tells you which files have conflicts after merging.
</p>

<div class="org-src-container">
<pre class="src src-conf">    <span class="org-variable-name">conflicts</span> = diff --name-only --diff-filter=U
    <span class="org-variable-name">unmerged</span> = diff --name-only --diff-filter=U
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bf9a72" class="outline-3">
<h3 id="org1bf9a72">Alternative</h3>
<div class="outline-text-3" id="text-org1bf9a72">
<p>
If your master branch is busted, rename it to something else so that it&rsquo;s out of
the way:
</p>

<div class="org-src-container">
<pre class="src src-shell">git branch -m master master-busted
</pre>
</div>

<p>
Create a new branch <code>master</code> that tracks the origin:
</p>

<div class="org-src-container">
<pre class="src src-shell">git branch --track master origin/master
</pre>
</div>

<p>
Check it out (be careful, this will discard all your local changes):
</p>

<div class="org-src-container">
<pre class="src src-shell">git checkout -f master
</pre>
</div>

<p>
Make sure the <code>master</code> is up-to-date:
</p>

<div class="org-src-container">
<pre class="src src-shell">git pull
</pre>
</div>
</div>
</div>

<div id="outline-container-org80f39e8" class="outline-3">
<h3 id="org80f39e8">A GitHub test repository to experiment with conflicts</h3>
<div class="outline-text-3" id="text-org80f39e8">
<p>
You can experiment with resolving a Git conflict with this repository:
<a href="https://github.com/brianleetest/testGit/blob/master/README.md">https://github.com/brianleetest/testGit/blob/master/README.md</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org64c249d" class="outline-2">
<h2 id="org64c249d">GitHub tasks</h2>
<div class="outline-text-2" id="text-org64c249d">
</div>

<div id="outline-container-org01ec74e" class="outline-3">
<h3 id="org01ec74e">Force push</h3>
<div class="outline-text-3" id="text-org01ec74e">
<div class="org-src-container">
<pre class="src src-shell">git push --force origin master
</pre>
</div>
</div>
</div>

<div id="outline-container-org75ceb3c" class="outline-3">
<h3 id="org75ceb3c">Push tags</h3>
<div class="outline-text-3" id="text-org75ceb3c">
<div class="org-src-container">
<pre class="src src-shell">git push --tags
</pre>
</div>
</div>
</div>

<div id="outline-container-org71822f2" class="outline-3">
<h3 id="org71822f2">Get user pubkeys</h3>
<div class="outline-text-3" id="text-org71822f2">
<div class="org-src-container">
<pre class="src src-shell">curl https://github.com/abo-abo.keys
</pre>
</div>
</div>
</div>

<div id="outline-container-org8de9442" class="outline-3">
<h3 id="org8de9442">Routine</h3>
<div class="outline-text-3" id="text-org8de9442">
<div class="org-src-container">
<pre class="src src-shell">git fetch --all
</pre>
</div>

<p>
This results in all pull requests available in the local repo in the local pull/
namespace.
</p>

<p>
To check out e.g. PR #42:
</p>

<div class="org-src-container">
<pre class="src src-shell">git checkout -b foo refs/pull/upstream/42
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2413cbd" class="outline-2">
<h2 id="org2413cbd">Git workflows</h2>
<div class="outline-text-2" id="text-org2413cbd">
<p>
It may be helpful to do a some background reading on workflows with Git.  Here
is the gitworkflows man page:
<a href="https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html">https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html</a>
</p>

<p>
Other doc on branch models:
</p>

<p>
<a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a>
<a href="http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html">http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html</a>
<a href="http://williamdurand.fr/2012/01/17/my-git-branching-model/">http://williamdurand.fr/2012/01/17/my-git-branching-model/</a>
</p>
</div>
</div>

<div id="outline-container-orgc4c6a01" class="outline-2">
<h2 id="orgc4c6a01">References</h2>
<div class="outline-text-2" id="text-orgc4c6a01">
<ul class="org-ul">
<li><a href="https://github.com/tj/git-extras">https://github.com/tj/git-extras</a></li>
<li><a href="https://hub.github.com/hub.1.html">https://hub.github.com/hub.1.html</a></li>
<li><a href="http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh">http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh</a></li>

<li><a href="https://git.wiki.kernel.org/index.php/Aliases">Git SCM Wiki - Aliases</a></li>
<li><a href="https://ochronus.com/git-tips-from-the-trenches/">Git tips from the trenches</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga454e39" class="outline-2">
<h2 id="orga454e39">Free private repositories</h2>
<div class="outline-text-2" id="text-orga454e39">
<p>
I use the <b>free private repos</b> from <a href="https://bitbucket.org/">https://bitbucket.org/</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Fabrice Niessen</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
