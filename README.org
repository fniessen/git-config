#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en

#+PROPERTY:  tangle ~/.gitconfig
#+PROPERTY:  eval no

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *be extremely careful*!
#+end_warning

* Tasks

** TODO Outsource and include private entries in .gitconfig

Git (1.7.10+) now supports this syntax in .gitconfig:

#+begin_src conf :tangle no
[include]
	path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a .gitconfig file for your nonsensitive information and a git ignored
.githubconfig file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

** TODO Mix professional and personal Git configurations

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

* User

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
	name = John Doe
	email = johndoe@example.com
#+end_src

You should "override" the above with your personal details:

#+begin_src conf
[include]
	path = .gitconfig.user
#+end_src

* Core

#+begin_src conf
[core]
	editor = emacsclient
	pager = less
	whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

#+begin_src conf :tangle no
	autocrlf = input
	safecrlf = true
#+end_src

* Diff

#+begin_src conf
[diff]
	renames = copies
	algorithm = patience
#+end_src

* Merge

#+begin_src conf
[merge]
	stat = true
#+end_src

* Grep

#+begin_src conf
[grep]
	fullname = true
	linenumber = true
#+end_src

* Pull

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
	rebase = true
#+end_src

* Rebase

Also set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they
pull.

#+begin_src conf
[rebase]
	stat = true
#+end_src

* Push

Push only the *current branch* to its tracking branch (sane pushing -- instead of
pushing all branches).

#+begin_src conf
[push]
	default = current
#+end_src

XXX or `matching'?

* Color

#+begin_src conf
[color]
	ui = auto
	branch = auto
	diff = auto
	status = auto
	interactive = auto
#+end_src

** Branch

#+begin_src conf
[color "branch"]
	current = yellow reverse
	local = yellow
	remote = green
#+end_src

** Diff

#+begin_src conf
[color "diff"]
	meta = yellow bold
	frag = magenta bold
	old = red bold
	new = green bold
	whitespace = red reverse
#+end_src

** Status

#+begin_src conf
[color "status"]
	updated = green
	added = yellow
	changed = yellow
	untracked = bold red
	branch = green
	nobranch = red reverse
#+end_src

** Grep

#+begin_src conf
[color "grep"]
	filename = bold yellow reverse
	linenumber = magenta bold
	match = green reverse bold
	separator = red bold
	selected = white bold
	context = black
	function = red
#+end_src

* Aliases

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~:

#+begin_src conf
[alias]
#+end_src

Print the current list of Git aliases:

#+begin_src conf
	alias = "!git config -l | grep alias | cut -c 7- | sort"
#+end_src

** Abbreviations

Basic shortcuts.

- List all branches (both remote-tracking and local), showing sha1 and commit
  subject line for each head, along with the name of the upstream branch (if
  any).

#+begin_src conf
	br = branch -a -vv
#+end_src

#+begin_src conf
	ci = commit
	cl = clone
	co = checkout
	cp = cherry-pick
	ls = ls-files
	st = status -s
#+end_src

Checkout master branch (useful if you keep feature branches):

#+begin_src conf
	master = checkout master
#+end_src

** Initialize a Git repository

#+begin_src conf
	this = !git init && git add . && git commit -m \"Initial commit\"
#+end_src

** Remove deleted files

Removing multiple files from a Git repo that have already been deleted from
disk:

#+begin_src conf
	r = !git ls-files --deleted -z | xargs -0 git rm
#+end_src

** Ignored files

Show files ignored by Git:

#+begin_src conf
	ignored = ls-files -o -i --exclude-standard
#+end_src

XXX Quickly add a file or directory to =.gitignore=:

#+begin_src conf
	ignore = !([ ! -e .gitignore ] && touch .gitignore) | echo $1 >> .gitignore
#+end_src

** Log

#+begin_src conf
	lg = log --decorate --oneline --graph
	lgr = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=relative --graph
	lga = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=short --graph
#+end_src

#+begin_note
The ~git log~ command shows, by default, the "author date" (not the "committer
date").
#+end_note

#+begin_src conf
	y = diff "@{yesterday}"
#+end_src

Show a "top contributors" list:

#+begin_src conf
	who = shortlog -n -s --
#+end_src

#+begin_note
The ~--~ signals the end of options, that the rest of the parameters are limiters.
#+end_note

#+begin_src conf
	head = !"git log -n1"
	heads = !"git log --format='%C(yellow)%h%Creset;%C(cyan)%H%Creset;%s %Cgreen<%an>%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"

	# prettier and concise whatchanged
	what = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=short --stat

	# prettier whatchanged with full diffs based on text search
	whatwhen = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=iso -p -S
#+end_src

** Unpulled

#+begin_src conf
	in = pull --dry-run
#+end_src

** Pull all

#+begin_src conf
	pull-all = !"old=$(git rev-parse --abbrev-ref HEAD) ; for b in $(git for-each-ref refs/heads --format='%(refname)') ; do git checkout ${b#refs/heads/} ; git pull --ff-only ; done; git checkout ${old}"
#+end_src

** Unpushed

What is left to push to ~origin~:

#+begin_src conf
	out = log --branches --not --remotes
	unpushed = log --branches --not --remotes --color --graph --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset' --abbrev-commit
#+end_src

** Amend

Amend with the same message (without your editor prompting you for the message
you've already entered).

#+begin_src conf
	amend = "!git log -n 1 --pretty=tformat:%s%n%n%b | git commit -F - --amend"
#+end_src

** Diff

Differences between the *unstaged* files and the *last commit*:

#+begin_src conf
	df = diff
#+end_src

Just before committing the staged changes, check what your commit changes
(differences between the *staged* files and the *last commit*):

#+begin_src conf
	dc = diff --cached
#+end_src

Getting the diff of a branch since it forked from another branch, or since the
last merge.

To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:

#+begin_src conf
	forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
#+end_src

It uses ~git merge-base~ to determine the fork-point (the commit that is common
to both the branches) and does a ~git diff~ between that commit and the second
branch.

Usage

: git forkdiff <forked from branch> <forked branch> [git-diff-options]

Example

: git forkdiff origin/master my_forked_branch --stat

** Search

#+begin_src shell :tangle no
# Git Search
alias ggFind='git log -g --pretty=format:%h -S'
alias gFind='git log --pretty=format:%h -S'
alias gGFing='git log --pretty=format:%h -G'
alias gCFind='git log --grep="string in a commit message" --all --pretty=format:%h'
#+END_SRC

*** Commit messages

If you want to find all commits where /commit message/ contains given word, use
~--grep~.

#+begin_src conf :tangle no
	git log --grep
#+end_src

*** Commit contents (Diff)

If you want to find all commits where a *string* was added or removed in the /file
contents/ (to be more exact: where its *number of occurrences changed*),
i.e. search the /commit contents/, use ~-S~.

By default, ~-S~ accepts a string, but can be modified to accept a regexp with
~--pickaxe-regex~.

~-G~ looks for *differences* whose added or removed *line* matches the given *regexp*.

I think you'd want this with ~--all~ as well (whether using ~-S~ or ~-G~).

*** Code base

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- for your regexp in some files from another branch,
- files registered in the index, rather than the working tree.

#+begin_src conf
	gr = "grep --break --heading"
#+end_src

XXX works only on files really in Git (bypassing ignored files)?

** Tags

List tags using (better) version sorting (if your ~sort~ supports it):

#+begin_src conf
	tags = !git tag | sort -V
#+end_src

Show the last tag:

#+begin_src conf
	lasttag = describe --tags --abbrev=0
#+end_src

** Merge aliases

If you're the Branch/Integration manager, you can use these aliases to merge
stuff:

#+begin_src conf
	ours = "!f() { git co --ours $@ && git add $@; }; f"
	theirs = "!f() { git co --theirs $@ && git add $@; }; f"
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
	record = !sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit it
will ~reset~ the index.

** Reset Commands

Remove changes from the index:

#+begin_src conf
	unstage = reset HEAD --
#+end_src

Go back before last commit, with files in uncommitted state:

#+begin_src conf
	uncommit = reset --soft HEAD~1
#+end_src

Undo the last commit:

#+begin_src conf
	undo = reset --hard HEAD~1
#+end_src

** Stash operations

#+begin_src conf
	sl = stash list
	sa = stash apply
	ss = stash save
#+end_src

XXX What about ~git stash --include-untracked~ and ~git stash pop~?

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
	lost = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

** Save a repo as a tarball

#+begin_src conf
	export = archive -o latest.tar.gz -9 --prefix=latest/
#+end_src

* References

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
