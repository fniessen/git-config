#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: Pretty format for `git log' and different helpful command aliases
#+KEYWORDS:  git, log, pretty format, alias
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2

#+SETUPFILE: ~/.dotfiles/org/theme-readtheorg.setup

#+EXPORT_EXCLUDE_TAGS: noexport
#+PROPERTY:  header-args :tangle ~/.dotfiles/home/.gitconfig :eval no

Squash commits:
https://bitbucket.org/blog/git-squash-commits-merging-bitbucket

*Commit early, commit often*: it is a bad idea to do a lot of work without
committing... But don't push every single commit: push when changes are tested!

Branch out often.
http://kentnguyen.com/development/visualized-git-practices-for-team/
(definition of git rebase)

These are common Git commands used in various situations:

- start a working area (see also: git help tutorial)
  + clone ::      Clone a repository into a new directory
  + init ::       Create an empty Git repository or reinitialize an existing one

- work on the current change (see also: git help everyday)
  + add ::        Add file contents to the index
  + mv ::         Move or rename a file, a directory, or a symlink
  + reset ::      Reset current HEAD to the specified state
  + rm ::         Remove files from the working tree and from the index

- examine the history and state (see also: git help revisions)
  + bisect ::     Use binary search to find the commit that introduced a bug
  + grep ::       Print lines matching a pattern
  + log ::        Show commit logs
  + show ::       Show various types of objects
  + status ::     Show the working tree status

- grow, mark and tweak your common history
  + branch ::     List, create, or delete branches
  + checkout ::   Switch branches or restore working tree files
  + commit ::     Record changes to the repository
  + diff ::       Show changes between commits, commit and working tree, etc
  + merge ::      Join two or more development histories together
  + rebase ::     Reapply commits on top of another base tip
  + tag ::        Create, list, delete or verify a tag object signed with GPG

- collaborate (see also: git help workflows)
  + fetch ::      Download objects and refs from another repository
  + pull ::       Fetch from and integrate with another repository or a local branch
  + push ::       Update remote refs along with associated objects

* Comments on branching (from Matthias)

If you have finished your work, feel free to merge the branch into master (maybe
you want to rebase your WIP branch before based on master):

The following sequence is here very helpful:

1. git checkout master
2. git pull (this makes sure that your local master branch matches the remote one)
3. git checkout WIP
4. git rebase master
5. git checkout master
6. git merge WIP

after this you can delete your local WIP branch and or if you pushed it the
remote one too.

* TODO See more Git configs (and aliases)

- https://github.com/alikins/gitconfig/blob/master/gitconfig
- https://github.com/GitAlias/gitalias

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *BE EXTREMELY CAREFUL*!
#+end_warning

* COMMENT Tasks

See https://blog.liip.ch/archive/2015/12/11/git-tips-tricks.html!!! XXX

** TODO Look at Git Power Routines [course]

https://www.youtube.com/playlist?list=PLDshL1Z581YYxLsjYwM25HkIYrymXb7H_

** TODO Read about Git

http://marlacorinne.4parkers.com/2012/07/20/git-pull-vs-git-fetch-then-merge/
https://adamcod.es/2014/12/10/git-pull-correct-workflow.html

** TODO Add doc about push failure

If a push fails, that does not necessarily indicate a "bad state"---it
simply represents that your history is different than what the remote
server has, and that the tip of the branch you are pushing to cannot
simply be "fast-forwarded" to your commit.

After a failed push, you are in no different state than you were before
the push (aside from a possibly puzzled mental state).

In your case, since you just want to commit and push in one operation,
you likely want to run ~git pull --rebase~, which would get those
changes and then automatically re-commit your work on top of them, as if
you had those changes all along.  You could then push.  So, something
like:

#+begin_src shell :tangle no
# Commit all changes and attempt to push, pulling in changes if necessary and
# re-pushing; on failure, restore to previous state with changes uncomitted.
git commit -am Foo \
  && {
    git push \
      |   | { |
        { git pull --rebase || handle-pull-conflicts; } \
          && git push;
      }
  } \
  |   | { |
    git reset --soft HEAD^
    echo 'Commit failed.'
  }
#+end_src

But what if rebasing fails?  Then you are left resolving a conflict
before you can attempt the push operation again.  I do not know how you
would want to handle this.  ~handle-pull-conflicts~ might simply perform
a ~git rebase --abort~ and exit with a non-zero status, or it may open a
UI/shell to help resolve changes.  If you are pushing after every
change, this amounts to correcting a single commit, so it might be worth
having VC maintain the state here, allow you to correct your commit, and
then the vc-next-action would be to run ~git rebase --continue~ after
adding the files that conflicted.

This will be how the majority of Git users will resolve rejected pushes.

Does that make sense?

  [Aside: ~git pull~ without ~--rebase~ performs a ~git fetch && git
  merge whatever-branch-you-are-tracking~, which has the unfortunate
  side-effect of creating a merge commit if histories are different;
  this muddies up history.  ~git pull --rebase~ performs ~git fetch &&
  git rebase whatever-branch-you-are-tracking~.  The difference in the
  two styles of conflicts here is that, with rebasing, since you are
  re-committing each and every changeset, you may get multiple
  conflicts on any number of commits, whereas a merge will give you a
  single conflict that must be resolved at once.  The benefit of
  rebasing is that it gives you a clean history and does not produce an
  unnecessary merge conflict which you would then push to origin, akin
  to leaving a bag of poop on origin's doorstep.]

For other users, it may represent a wholly different problem.  For
example, if I were to push to GNU ease.js' repo and get that message,
that would be a problem, since that means that someone has committed to
my repository without my permission.  An automatic pull and re-push
would be bad in this case, since that makes it look like I'm okay with
that.

A failed push could also mean that you are tracking the wrong
branch, or pushing to the wrong repository.  Git allows you to set a
"tracking branch", which can be anything---a local branch, a remote
branch, or a branch in an entirely different repository, local or
remote.  Further, you can override the tracking branch by specifying
which remote to push to as part of the ~push~ command.

In your case, you'd always want to respect the tracking branch and
assume that there are no problems pushing, since you use only one
remote, and the tracking branch is always a branch of the same name on
origin.

A failed push could also mean that someone rudely rewrote history on the
remote branch (using ~git push --force~) and someone needs a talkin' to.

** TODO Outsource and include private entries in .gitconfig

Git 1.7.10+ supports this syntax in =.gitconfig=:

#+begin_src conf :tangle no
[include]
    path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a =.gitconfig= file for your nonsensitive information and a git ignored
=.githubconfig= file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

Mix professional and personal Git configurations:

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

** TODO git-repos

http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html

** TODO Git Quick Start For Emacs Devs

http://www.emacswiki.org/emacs/GitQuickStartForEmacsDevs

** TODO Work in progress which I can't commit (from Stephen J. Turnbull)
[2015-03-31 Tue 16:35]

#+begin_verse
 > > With git pull, if there are changes in the working directory, the
 > > merge (i.e. merge from remote/master into master) part of the
 > > operation is aborted before it starts, giving a message describing its
 > > refusal.  It does this even when there are no conflicts to deal with.
 >
 > What are we supposed to do in that case, if we're not yet ready to
 > commit our files?

If you have work-in-progress and feel unable to commit, but at the
same time feel the need to pull into that workspace, I suggest you get
up and walk around, fight off the pull urge, then finish the commit
after your head cools off.

If that isn't satisfactory, then

 > or putting our work into a new branch, like:
 >
 > --8<---------------cut here---------------start------------->8---
 > git checkout -b new-branch-name
 > git commit -a -m "Edited"
 > git checkout master
 > git pull
 > ...
 > --8<---------------cut here---------------end--------------->8---

is one way to go.  Another possibility is creating a new workspace,
with cp -a or similar.

If you need the pulled code for your work, then a quick stash is the
better idea.
#+end_verse

From [[gnus:INBOX#87vbhhi69x.fsf@uwakimon.sk.tsukuba.ac.jp][Email from Stephen J. Turnbull: Re: VC mode and git]]

** Git the simple guide

http://rogerdudler.github.io/git-guide/

** Git rebase branch

#+begin_src shell :tangle no
git pull --rebase -r origin master
#+end_src

* User                                                                 :ARCHIVE:

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
    name = John Doe
    email = johndoe@example.com

[github]
    user = jdoe
#+end_src

You should "override" the above with your personal details:

#+begin_src conf
[include]
    path = ~/.gitconfig_local
#+end_src

Or create a Git command to set email addresses for you:

#+begin_src conf
[alias]
    workprofile = config user.email \"john@work.com\"
#+end_src

* Core                                                                 :ARCHIVE:

#+begin_src conf
[core]
    editor = emacsclient
#+end_src

*Text viewer* for use by Git commands.

#+begin_note
When the ~LESS~ environment variable is unset, Git sets it to ~FRSX~.  If the ~LESS~
environment variable is set, Git does not change it at all.

We use ~-R~ in the command itself to be sure to *interpret the color codes* when Git
is run from /Windows/ Emacs (~C-x v l~), with /no/ value for the ~LESS~ /environment
variable/.
#+end_note

#+begin_src conf
    pager = "less -R"
#+end_src

#+begin_src conf
#    whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

#+begin_src conf :tangle no
    autocrlf = input
    safecrlf = true

    autocrlf = false
    safecrlf = false
#+end_src

#+begin_src conf
[gc]
    auto = 1
#+end_src

* Diff                                                                 :ARCHIVE:

#+begin_src conf
[diff]
    renames = copies
    renameLimit = 30000
    #+end_src

Using the patience diff algorithm to compare large swathes of repetitive text
(hello, xml!) often produces a much more readable diff that will reveal context
and therefore hopefully bugs/typos etc.

Here's a quick snippet of a diff to show it helping. Bare LCS-based diff:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
+}
+
+def somethingelse {
+    something += 1
 }

 def thing2 {
     something += 2
 }
#+end_src

With ~patience~ becomes:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
 }

+def somethingelse {
+    something += 1
+}
+
 def thing2 {
     something += 2
 }
#+end_src

Same end result but much easier to read.

    #+begin_src conf
    algorithm = patience
#+end_src

Git diff will use (i)ndex, (w)ork tree, (c)ommit and (o)bject instead of a/b/c/d
as prefixes for patches:

#+begin_src conf
    mnemonicprefix = true
#+end_src

** Use Meld as Git ~difftool~

#+begin_src conf
    tool = meld

[difftool]
    prompt = false

[difftool "meld"]
    cmd = meld "$LOCAL" "$REMOTE"
#+end_src

Use a generic rev syntax (rev-parse) to transparently allow complex rev
expressions.

#+begin_src conf
[alias]
    showtool = "!f () { rev=$(git rev-parse \"${*:-HEAD}\"); git difftool $rev~1 $rev; }; f"
#+end_src

This allows doing nice things like:

#+begin_src shell :tangle no
git showtool :/some nasty bug
#+end_src

** Performing directory diffs (Comparing folders)

The following command makes it similar to the =git-meld.pl= script here:
https://github.com/wmanley/git-meld:

#+begin_src conf
[alias]
    diffall = "!git difftool -t meld --dir-diff"
#+end_src

* Apply                                                                :ARCHIVE:

#+begin_src conf
[apply]
    # Detect whitespace errors when applying a patch.
    whitespace = fix
#+end_src

* Pull                                                                 :ARCHIVE:

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
    rebase = preserve
#+end_src

(The merge commit doesn't get deleted!)

* Push                                                                 :ARCHIVE:

Push *only* the *current working branch* (sane pushing -- instead of pushing all
branches), with an added safety: only if it is /tracking/ a remote upstream branch
with the /same name/.

#+begin_src conf
[push]
    default = simple
#+end_src

(~simple~ is the default in Git 2.x)

* Merge                                                                :ARCHIVE:

#+begin_src conf
[merge]
    stat = true
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true
#+end_src

#+begin_src conf
    conflictstyle = diff3
#+end_src

- For small changes, ~git diff~ and ~vc-diff~ are perfect.
- For medium changes, ~magit~ is perfect.
- For large changes, [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD) is perfect.

How to resolve merge conflicts in Git?  Try: ~git mergetool~.

** Emacs as a Git mergetool

Ediff or Emerge?  Or Magit???

#+begin_src conf :tangle no
[merge]
    tool = ediff

[mergetool "ediff"]
    cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
    keepBackup = false
#+end_src

** Meld as Git mergetool

*How do I set up and use Meld as my git mergetool?*
See https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool.

See ~auto-merge~ in
https://stackoverflow.com/questions/11133290/git-merging-using-meld (first and
second solution).

#+begin_src conf
    tool = meld
#+end_src

Firstly here is what the parameters mean:

- ~$LOCAL~ is the file in the *current branch* (e.g. ~master~).

- ~$REMOTE~ is the file in the *branch being merged* (e.g. ~branch_name~).

- ~$MERGED~ is the *partially merged file* with the merge conflict information in
  it.

- ~$BASE~ is the *common ancestor* of ~$LOCAL~ and ~$REMOTE~, this is to say the file as
  it was (before both changes) when the branch containing ~$REMOTE~ was originally
  created.

I suggest you use either:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$MERGED" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

or:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

The choice is whether to use ~$MERGED~ or ~$BASE~ in between ~$LOCAL~ and ~$REMOTE~.

Either way, Meld will display 3 panes with:

- ~$LOCAL~ in the left pane,
- ~$REMOTE~ in the right pane and
- either ~$MERGED~ or ~$BASE~ in the middle pane.

In BOTH cases, *the middle pane is the file that you should edit to resolve the
merge conflicts*.  The difference is just in which starting edit position you'd
prefer:

- ~$MERGED~ for the file which contains the partially merged file with the merge
  conflict information or

- ~$BASE~ for the shared commit ancestor of ~$LOCAL~ and ~$REMOTE~.

#+begin_note
Since both cmd lines can be useful, I keep them both in my =.gitconfig= file. Most
of the time I use the ~$MERGED~ line and the ~$BASE~ line is commented out, but the
commenting out can be swapped over if I want to use the ~$BASE~ line instead.
#+end_note

#+begin_src conf
[mergetool "meld"]
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

* Rebase                                                               :ARCHIVE:

Also set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they
pull.

#+begin_src conf
[rebase]
    stat = true
#+end_src

* Grep                                                                 :ARCHIVE:

https://git-scm.com/docs/git-grep

#+begin_src conf
[grep]
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    fullName = true
#+end_src

* Color                                                                :ARCHIVE:

Instead of hardcoding colors, I suggest:

#+begin_src conf
[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto
#+end_src

See http://git-scm.com/docs/git-config for the ~slot~ list.

** Branch

#+begin_src conf
[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse
#+end_src

** Diff

#+begin_src conf
[color "diff"]
    context = "#888888"
    plain = normal
    meta = yellow bold
    func = "#cc99cc"
    frag = magenta bold
    old = red bold
    new = green bold
    commit = yellow
    whitespace = red reverse
#+end_src

** Status

#+begin_src conf
[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold
#+end_src

- added = modified
- changed = updated

** Grep

#+begin_src conf
[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = blue reverse bold
    separator = red bold
    selected = white bold
#+end_src

* Proxy

#+begin_src conf :tangle no
[http]
    proxy = http://proxy-guest.forem.be:8080
#+end_src

* Format

#+begin_src conf
[format]
    pretty = format:%C(yellow)%h%C(reset) %C(green)%ad%C(auto)%d%C(reset) %s %C(blue)<%an>%C(reset)
#+end_src

See
- https://devhints.io/git-log-format and
- https://git-scm.com/docs/pretty-formats.

* Aliases

#+begin_src conf
[alias]
#+end_src

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~ to *print the current list of Git aliases*:

#+begin_src conf
    alias = "!git config -l | grep alias | cut -c 7- | sort"
#+end_src

#+begin_src conf
    type = cat-file -t
    dump = cat-file -p
#+end_src

(see http://gitimmersion.com/lab_11.html)

Define:

#+begin_src conf
    exec = '!exec '
#+end_src

so that you can do things like ~git exec make~.  This works because Shell aliases
are always executed in the top-level directory.

#+begin_src conf
    # Show the diff between the latest commit and the current state
    d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

    # `git di $number' shows the diff between the state `$number' revisions ago and the current state
    di = !"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull origin master"

    # Commit all changes (all local modifications/additions/deletions).
    ca = !git add -A && git commit -av
#+end_src

Clean up your commits before publishing.  Before you push your commits to the
repository, it's good to revise them.  You can run the git interactive rebase to
squash your commits or modify commit messages.  The goal is to publish only
clean and relevant commits, no experiments or fixing typos.

#+begin_src conf
    # Interactive rebase with the given number of latest commits
    ireb = "!r() { git rebase -i HEAD~$1; }; r"
#+end_src

#+begin_src conf
    # Remove branches that have already been merged with master
    dm = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"
#+end_src

So, I can do things like ~git exec make~. This works because shell aliases are
always executed in the top-level directory.

** CREATE - Getting a Git repository

*** Create a repository

#+begin_src conf
    this = !git init && ( [[ -n $(ls) ]] || touch .gitignore ) && git add . && git commit -m \"Initial commit\"
#+end_src

*** Clone an existing repository

#+begin_src conf
    # Clone a repository including all submodules.
    cl = clone --recursive
#+end_src

#+begin_tip
For *passwordless Git pull* (permanently authenticating with Git repositories),
*use SSH* when cloning, and *add* your *public key* to the remote server.
#+end_tip

** SHOW - Check the status of your files

Give the status in the *short-format* (preceded by a line showing the /branch name/
and /tracking info/).

#+begin_src conf
    st = status -s -b
#+end_src

In the following example:

#+begin_example
M  README
 M lisp/mail/rmail.el
MM ChangeLog
#+end_example

- =README= is changed and *staged for commit* (it's *in the index*),
- =lisp/mail/rmail.el= is changed but *not staged for commit*, and
- =Changelog= is changed and staged for commit, then *changed again* and the new
  change is *not staged for commit*.

#+begin_note
Staging for commit is typically done by ~git add~.
#+end_note

** SHOW - View your changes

*** Changes between the working tree and the index (staged for the next commit)

#+begin_src conf
    df = diff
    #+end_src

    #+begin_src conf
    wdiff = diff --word-diff
    dw = diff --word-diff
#+end_src

*** Changes between the working tree and the latest commit (HEAD)

#+begin_src shell :tangle no
    diff-all = diff HEAD
#+end_src

*** Changes between the index (staged for the next commit) and the latest commit (HEAD)

Just before committing the *staged* changes, check what your commit changes:

#+begin_src conf
    dc = diff --cached
#+end_src

*** Precommit

This is a key part of my workflow. I run this before every commit to make sure
I don't need to use the undo commands.

#+begin_src conf
    precommit = diff --cached --diff-algorithm=minimal -w
#+end_src

*** Today

Quickly see what you've done today (commits that aren't merges on all branches):

#+begin_src conf
    today = !git log --since=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
    yesterday = !git log --since='1 day ago midnight' --until=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
    this-week = !git log --since=1.weeks --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
#+end_src

#+begin_src conf
    today-all = !git log --since=midnight --no-merges --all
#+end_src

*** When

#+begin_src conf
    # When was this file last updated, on each local branch.
    wwflu = "!f() { for b in $(git rev-parse --symbolic --branches); do echo -e `git log --format=%at:%ar -1 $b -- \"$1\"`\\\\t$b; done | sort -r | cut -f2 -d: ; }; f"
#+end_src

*** Diff of branch

Getting the diff of a branch since it forked from another branch, or since the
last merge.

To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:

#+begin_src conf
    forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
#+end_src

It uses ~git merge-base~ to determine the fork-point (the commit that is common
to both the branches) and does a ~git diff~ between that commit and the second
branch.

Usage:

: git forkdiff <forked from branch> <forked branch> [git-diff-options]

Example:

: git forkdiff origin/master my_forked_branch --stat

*** Finding new commits

Diverging from ~origin/master~, whatever the branch?

#+begin_src conf
    log-local = log --oneline origin..HEAD
#+end_src

** SHOW - View the commit history

#+begin_note
The ~git log~ command shows, by default, the "author date" -- not the "committer
date".
#+end_note

#+begin_src conf
    ls = log --decorate --date=short
    ld = log --decorate --date=relative
#+end_src

List commits *showing changed files* (prettier and concise ~whatchanged~):

#+begin_src conf
    ll = log --decorate --date=short --stat
#+end_src

View the Git history tree:

#+begin_src conf
    tree = log --decorate --all --date=short --graph
#+end_src

To see real *timeline* of who is working on what and when:

#+begin_src conf
    graph = log --graph -10 --branches --remotes --tags --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --date-order
#+end_src

#+begin_src conf
    ls-modified  = "!git status --porcelain -uno | awk 'match($1, /M/) {print $2}'"
    ls-added     = "!git status --porcelain -uno | awk 'match($1, /A/) {print $2}'"
    ls-deleted   = "!git status --porcelain -uno | awk 'match($1, /D/) {print $2}'"
    ls-renamed   = "!git status --porcelain -uno | awk 'match($1, /R/) {print $2}'"
    ls-copied    = "!git status --porcelain -uno | awk 'match($1, /C/) {print $2}'"
    ls-updated   = "!git status --porcelain -uno | awk 'match($1, /U/) {print $2}'"
    ls-staged    = "!git status --porcelain -uno | grep -P '^[MA]' | awk '{ print $2 }'"
#+end_src

#+begin_src conf
    ls-del  = ls-files -d
    ls-mod  = ls-files -m   # This will include deleted files also.
    ls-new  = ls-files --exclude-standard -o
    # this one is a MUST have
    ls-ign  = ls-files --exclude-standard -o -i
    lsfiles = ls-files --exclude-per-directory=.gitignore \
                     --exclude-from=.git/info/exclude \
                     -v -d -o -m -s -u
#+end_src

#+begin_src conf
    last = log --decorate --date=short -1 --stat

    # Show last x commits
    last = !git log -$1 ${*:2} && :
#+end_src

*** List all the changed files in a commit

*List all the ~changed~ files in a commit*:

#+begin_src conf
    changed = show --pretty="format:" --name-only
    #+end_src

List all the changed files *between 2 commits*:

    #+begin_src conf
    diffn = diff --name-only
#+end_src

(See ~git what~ as well!)
(Use Tig?  Use git blame?)

XXX They don't show the same files (test with ~git changed HEAD~1~ and ~git diffn HEAD~1~) XXX

#+begin_src shell :tangle no
git changed                             # List files modified in last commit.
git changed bAda55                      # List files modified in this commit.
git changed bAda55..ff0021              # List files modified between those commits.
#+end_src

*** Show the history of a file

*List all commits* that changed a *specific file* (it accounts for renames!):

#+begin_src conf
    filelog = log --date=short --follow -C
    fl = log --date=short --follow -C
#+end_src

#+begin_src conf
    related = !sh -c 'git log --follow --format=format:%H $1 | xargs -L1 git diff-tree --no-commit-id --name-only -r | sort | uniq -c | sort -b -n -r'
#+end_src

#+begin_warning
Put a end of options character (--) after lf and before the path!!
#+end_warning

*** Show a "top contributors" list

Show a "top contributors" list (rank):

#+begin_src conf
    who = shortlog -n -s -e --no-merges --
#+end_src

#+begin_note
The ~--~ signals the end of options, that the rest of the parameters are limiters.
#+end_note

*** Inspect the commits for each edit

: git log ... | xargs -n 1 git show

** SHOW - Show blame information about original authors of lines changed or removed

$ git blame -w  # ignores white space
$ git blame -M  # ignores moving text
$ git blame -C  # ignores moving text into other files

#+begin_src conf
    praise = blame -w
    archeology = blame -w -C -n
    whodoikill = blame -w -C -n
#+end_src

Extra script (called [[https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten][git-overwritten]]) which shows blame information about
original authors of lines changed or removed in a given branch:

#+begin_src shell :tangle no
git overwritten feature origin/master
#+end_src

This is useful when opening pull requests per GitHub Flow; you'll want your pull
request reviewed by colleagues but you might not be sure who to ping. With
git-overwritten you'll get the names of people who wrote the lines you just
changed, so you'll know who to @-mention when opening a pull request.

> So, given a patch (or a branch) together with a "base revision", you'd get
> a list of code chunks modified by that patch, then run "annotate" on the
> base revision, and look for those code chunks, collecting the names of
> corresponding authors.

Sounds like git-guilt (which I've just read about today), might be
relevant: https://bitbucket.org/tpettersen/git-guilt

** SHOW - Search for commits

*** Whose commit message mention your regexp

If you want to find all commits (*across all branches*, showing names and status
of changed files) where *log message* matches a specified pattern (regular
expression), use ~find~.

#+begin_src conf
    find = "log --decorate -i --all --date=short --grep"

    # Find commits by commit message.
    findm = "!f() { git log --decorate --grep=$1 -i --all --date=short; }; f"
#+end_src

Add ~--name-status~ to show only names and status of *changed files*.

For example, to find all commits referencing bug #382:

#+begin_src shell :tangle no
git findm "Bug #382"
#+end_src

To find commits that match *either* of patterns (implicit *OR* semantic), you can
use:

#+begin_src shell :tangle no
git log --grep=<foo> --grep=<bar>
#+end_src

To find /commit/ that has *both* line matching first and line matching second
somewhere, use the *AND* semantic:

#+begin_src shell :tangle no
git log --all-match --grep=<foo> --grep=<bar>
#+end_src

Show the *last commit* which *message matches a regex*:

#+begin_src shell :tangle no
# Show the last commit which has the word "fix" in its message.
git show :/fix

# Show the last merge commit.
git show :/^Merge
#+end_src

*** String added/removed in Commit contents (Diff)

If you want to find all commits where a *string* was *added or removed* in the /file
contents/ (to be more exact: where its *number of occurrences changed* in the
source file), i.e. search the /commit contents/, use ~-S~.

You can dig up commits that have, for example,
- removed calls to a specific function, or
- added a certain CSS classname.

#+begin_warning
If the number of times "foo" appears in the file is the same before and after
a commit, it will not match using ~-S "foo"~.
#+end_warning

In other words, to find the following commit:

#+begin_src diff :tangle no
@@ -4211,9 +4211,10 @@ public class MovesHandler extends EventHandlerBase {
      */

     private boolean actionsNotCompleted(final EventHandlerContext context, final String mo_id) {
         final Object found_mo_id =
                 selectDbValue(context, "activity_log", "activity_log_id", "mo_id=" + mo_id
-                    + " AND status NOT IN ('COMPLETED-V','REJECTED','CANCELLED')");
+                    + " AND status NOT IN ('COMPLETED-V','CLOSED','REJECTED','CANCELLED')");
         return (found_mo_id != null);
     }
#+end_src

you *need to search on 'CLOSED'*.  Searching on 'COMPLETED-V' would not bring back
that commit!

#+begin_src shell :tangle no
git log --all -S "foo" --since="1 week ago"
#+end_src

#+begin_src conf
    whatwhen = log --decorate --date=short -p -S
#+end_src

Prettier ~whatchanged~ with full diffs based on text search:

#+begin_src conf
    # Find commits by source code.
    findc = "!f() { git log --decorate --date=short -S $1; }; f"

    grep4d = !sh -c 'git log -p -S'$1' $2' -
# Not the best example, but: git grep4d CLOSED '*.java'
#+end_src

By default, ~-S~ accepts a string, but can be modified to accept a *regexp* with
~--pickaxe-regex~.

*** Whose changes include your regexp

String contained in added/removed lines from Commit contents (Diff)

With the ~-G~ option, the commit is shown in the log if your *regexp* search matches
any *line* that was added, removed, or changed.

#+begin_src shell :tangle no
git log --all -G "foo" --since="1 week ago"
#+end_src

** SHOW - find all "unpushed" commits for all projects in a directory

See https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory

#+begin_src conf
    status-all = "!for d in `find . -name \".git\"`; do echo \"\n*** Repository: $d ***\" && git --git-dir=$d --work-tree=$d/.. status | grep -q \"is ahead of\"; done"
#+end_src

** Grep (Print lines matching a pattern)

*** Pattern in working directory (and its subdirectories)

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- files registered in the index, rather than the working tree,
- for your regexp in some files from another branch (XXX does not work? XXX).

#+begin_note
It doesn't search files that are not revisioned (untracked, excluded/ignored,
etc.).
#+end_note

Example:

#+begin_src shell :tangle no
git grep "foo" -- '*.java'
#+end_src

More readable output, *with grouping* (like Ripgrep, ~rg~):

#+begin_src conf
    # Case-sensitive.
    rg = "grep --break --heading --line-number"
grep-all = "!f() { git rev-list --all | xargs git grep $1; }; f"
#+end_src

Broader search (*case-sensitive*), output *without grouping*:

#+begin_src conf
    # `-I' = Don't match the pattern in binary files.
    g = "grep -I"
    gno = "grep -I --name-only"
#+end_src

*** Find files that contain some terms, not necessarily on the same line

Match any of these patterns, but print matches only from files that have /all/ of
them (files must have lines that match each of them):

#+begin_src shell :tangle no
git grep --all-match -e <regexp> -e <regexp>
#+end_src

** Ignoring files

*** List untracked files

Tell if a file is being tracked:

#+begin_src conf
    # List all tracked files.
    ls-tracked = ls-files -t

    tracked1 = "!f() { tracked=$(git ls-files ${1}); if [[ -z ${tracked} ]]; then echo 'File NOT tracked (or No such file)'; else echo 'File tracked'; fi; }; f"

    tracked2 = "!f() { echo -n ${1}': '; if [[ -f ${1} ]]; then tracked=$(git ls-files ${1}); if [[ -z ${tracked} ]]; then echo 'File NOT tracked'; else echo 'File tracked'; fi; else echo 'No such file!'; fi; }; f"
# does not work!?
#+end_src

#+begin_note
~[[~ has fewer surprises and is generally safer to use. But it is not portable --
POSIX doesn't specify what it does and only some shells support it (beside bash,
I heard ksh supports it too). For example, you can do

: [[ -e $b ]]

to test whether a file exists. But with ~[~, you have to quote ~$b~, because it
splits the argument and expands things like ~"a*"~ (where ~[[~ takes it
literally). That has also to do with how ~[~ can be an external program and
receives its argument just normally like every other program (although it can
also be a builtin, but then it still has not this special handling).
#+end_note

List untracked *files ignored* by a =.gitignore= statement somewhere.

#+begin_src conf
    # List all untracked files.
    ls-untracked = ls-files --others
#+end_src

#+begin_src conf
    ls-ignored = ls-files --others --ignored --exclude-standard
#+end_src

Remove ignored files that are still on the repository:

#+begin_src shell :tangle ~/.dotfiles/bin/git-delete-ignored :shebang #!/usr/bin/env bash
git ls-ignored | xargs rm
#+end_src

*** ~git ignore~ command

Quickly add a file or directory to =.gitignore=:

#+begin_src conf
    ignore = "!f() { echo $1 >> \"${GIT_PREFIX}.gitignore\"; }; f"
#+end_src

*** ~assume-unchanged~ command

Ignore/unignore changes to *tracked file(s)* without =.gitignore=:

#+begin_src conf
    assume = update-index --assume-unchanged
    unassume = update-index --no-assume-unchanged
#+end_src

It has to be configured for each project member individually.

#+begin_warning
As stated in [[http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged][git ignore vs. exclude vs. assume-unchanged]],
~git-update-index --assume-unchanged~ was never meant to ignore changes to tracked
files (*only to spare some stats*).  So do not suggest it as a means to achieve
that.
#+end_warning

List ignored files (*marked unchanged*):

#+begin_src conf
    assumed = "!git ls-files -v | grep '^h' | cut -c 3-"
#+end_src

Unassume all the assumed files:

#+begin_src conf
    unassumeall = "!git assumed | xargs git update-index --no-assume-unchanged"
#+end_src

Assume all:

#+begin_src conf
    assumeall = "!git status -s | awk {'print $2'} | xargs git assume"
#+end_src

** REVERT - Undo things

> The reason I don't commit a change immediately after I write it is
> that I want to test it in real (and varied) use.  Sometimes I find
> bugs and have to change it.  After some period in which it works well,
> I decide it is ready to install.

That is a good reason. However, for your information there is the variant ~git
commit --amend~, which as the option suggests amends the *current* commit. Just
~git add~ the files you changed and run ~git commit --amend~. It also lets you edit
the commit message. After discovering this option, I find I am less fearful of
making premature commits, since they are easily fixed. (But not after pushing,
of course. That way lies madness.)

*** Change your last commit

This will help when we need to change the most recent commit.

#+begin_warning
~git commit --amend~ is a dangerous operation.  Someone might forget that the
current commit has already been pushed, and amend it anyway.  What will they do
then?

Try to push the result, see a message about non-fast-forward pushes being not
allowed, then go along the "If pushing fails" section (pull, resolve, commit,
push), and we'll have two similar commits in the history.
#+end_warning

#+begin_verse
The key to understanding that is that Git does not rewrite history, it creates
new history and calls that reality.  The commits in this history have different
IDs (because the ID is the content plus the ID of its parent, changing just one
commit means everything after it must change).  If you push this new history
(with --force) everyone else will have the old divergent history.  All their
work will be on top of this divergent history.  They have to do the surgery to
put their work on your new history.

When users do a "git pull", git doesn't store that you did a rebase (it would be
nice if it did) so it assumes something has gone wrong and refuses to pull.  Git
gets a human to look at the divergence and decide what to do with it.
Unfortunately, most people don't know what to do with a divergent repository.

And yes, this applies to amended commits.

This is a common question answered on Stack Overflow.
https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase

This answer isn't specifically about rebase, but it illustrates how Git creates
new history.
https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938
#+end_verse

Modify the *last* commit, amending with the same message (without your editor
prompting you for the message you've already entered):

#+begin_src conf
    # Append additional (staged) changes to the PREVIOUS commit.
    fixup = commit -v --amend --reuse-message HEAD
    # fixlastcommit?

    # Commit changes to current HEAD (modified and deleted files) as amended commit.
    plus = commit -a -v --amend --reuse-message HEAD

    # Change previous commit's message to what you type in.
    medit = commit --amend -m

    # Credit an author on the LATEST commit.
    credit = "!f() { git commit --amend --author \"$1 <$2>\" --reuse-message HEAD; }; f"
#+end_src

Note that the ~-a~ switch which tells Git to automatically *stage all your changes*,
as if you ran ~git add .~ (stage all local modifications/additions) right before
the commit.

#+begin_warning
*Never amend a commit* that you've *already pushed* to a remote repository.
https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message
#+end_warning

Solution for *amending older commits*:
https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit
(see 1st and 2nd answers!)

*** Unmodify a modified file / Undelete a deleted file

*Undo* the local changes *in the working directory*: roll a file back to its last
committed version.

#+begin_tip
It can also recover *deleted files* -- if the deletion has not been committed.
#+end_tip

#+begin_src conf
    unmodify = checkout --
    undelete = checkout --
#+end_src

#+begin_note
The two dashes there (canonically called the "bare double dashes") ensure that
the checkout command know that we are trying to roll back a file and not /change
branches/ (the typical usage of the checkout command).
#+end_note

When you grab a file from a previous time, it sits *in your index*, modified.

*** Unstage a staged file

*Remove* the specified *files from the index* (proposed next commit, staging area):

#+begin_src conf
    unstage = reset HEAD --
# OK
#+end_src

~unstage~ is the opposite of ~git add~. It lets you remove items from the staging
area.  This makes it a very useful tool when you're deciding which files to
stage for a commit.  If you've accidentally added something to the staging area,
just use ~unstage~ to remove it.

*** Throw away a commit

http://www.vogella.com/tutorials/Git/article.html#resetcommits
http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
http://git-scm.com/2011/07/11/reset.html

~git reset~ is a simple way to undo changes that haven't been shared with anyone
else.

See « Undo 'git add' before commit ».

**** Do not touch the index file or the working tree at all

Go back before last commit, with files in uncommitted state:

#+begin_src conf
    uncommit = reset --soft HEAD~1
# OK (or undolast)
#+end_src

~uncommit~ *removes the last commit* from your repository, and *puts the changes into
your index*, keeping changes in the working directory -- it doesn't touch it.
It's like going back in time to the moment right before you committed.

#+begin_note
~uncommit~ here means to do just the reverse of commit, i.e. just like commit it
shouldn't touch the files's contents, only the metadata.
#+end_note

This is a useful technique in resuming work on an unfinished changeset.

**** Reset the index (but not the working tree)

Reset the previous commit, but *puts* all *the changes* from that commit *in the
working directory*:

#+begin_src conf :tangle no
    undo = reset --mixed HEAD~1
# popcommit?
#+end_src

#+begin_note
~--mixed~ with paths is deprecated; use ~git reset -- <paths>~ instead.
#+end_note

This is a useful technique if your pull fails to merge the new stuff from
upstream: ~git reset HEAD~1~, pull again, fix the conflicts, then commit your
changes again.

**** Reset both the index and working tree

Remove the last commit, *delete changes in your staging area and in your working
directory*:

#+begin_src conf
    # Reset every file in your working directory to its committed state.
    wipe = reset --hard HEAD~1
# rollback?
#+end_src

If you reset work that you /never committed/, it is gone for good.  Too bad!  This
is quite a dangerous command (~git reset --hard~ is one of the few Git commands
which deletes information with no backout), and must be used with *EXTREME
CAUTION*.

#+begin_warning
This command will also *overwrite changed files* in the working tree!
#+end_warning

#+begin_tip
If you have changes in your working directory or staging area, you'll probably
want to stash them before doing the above.
#+end_tip

Use ~git reset --hard @{u}~ to make sure the integration branch is up-to-date
before merging.

#+begin_note
~git reset --hard~ will not *remove untracked files*, where as ~git clean~ will remove
any files from the tracked root directory that are not under Git tracking.

*WARNING -- BE CAREFUL WITH THIS!*  It is helpful to run a dry-run with ~git clean~
first, to see what it will delete.

Use:
- ~git clean -n~ (dry run) to see what ~git clean -f~ will do, so you can be sure
  it's what you want.
- ~git clean -f~ (to *remove* the *untracked files*) and
- ~git clean -fd~ (to also *remove untracked directories* in addition to untracked
  files).
#+end_note

Nuclear version:

#+begin_src conf
    nevermind = !git reset --hard HEAD && git clean -d -f
#+end_src

which:
- unstages changes in the index,
- discards changes in the working directory, and
- removes any new files.

XXX What is the difference with ~git checkout .~?  See
https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout.

*** Revert a commit

Once you've pushed changes to a remote repository, it is considered dangerous to
modify the history because someone else may have already pulled it.

However, Git offers you an easy way to undo a patch by committing a change that
effectively reverses the patch in question. The simplest usage is to revert an
entire commit:

#+begin_src shell :tangle no
git revert [hash]
#+end_src

This creates a patch that is the opposite of commit ~[hash]~ and commits it to
your repository.

If you want to revert that commit without committing it (putting the reversion
into your index), use:

#+begin_src shell :tangle no
git revert -n [hash]
#+end_src

** UPDATE - Pull

Starting with Git 1.7.0, ~@{u}~ is shorthand for the *current* branch's *upstream*
branch; e.g., ~origin/foo~ (or ~github/foo~, etc., since the remote doesn't have to
be called ~origin~) if the checked out branch is ~foo~.

#+begin_src conf
    r = remote -v
    remotes = remote -v
#+end_src

#+begin_note
~git pull~ is simply ~git fetch && git merge remote~.  Its ~--rebase~ option uses
~rebase~ instead of ~merge~.

That's exactly why some decide to avoid ~rebase~ (but to ~pull~ instead), because it
has bad effects if one merges from another branch and then wants to push.
#+end_note

About rebase (with visual aid):
https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395

The ~in~ command returns a list of *incoming* commits for the *current branch* --
after a ~git fetch~, to fetch down *all the data* it has for the *current remote* that
you do not --, the next time you do a merge.

#+begin_src conf
    in = !(echo "Please fetch origin before." && git log --decorate ..@{u})
    inf = !(git remote update -p              && git log --decorate ..@{u})
#+end_src

#+begin_src conf
    in-stat = log --stat ..@{u}
#+end_src

Show the changes between the last local commit and the *remote* branch:

Show a *single diffstat* (number of added and deleted lines for *all changed
files*):

#+begin_src conf
    in-what = diff --stat ...@{u}
#+end_src

#+begin_warning
The upstream diff ~in-what~ will show the negative of unpushed (rebased) commits,
if any, with the ~..~ notation --- not with the ~...~ notation!
#+end_warning

*** Update with local modifications

#+begin_src conf
    pull = pull -v
#+end_src

#+begin_note
~git pull~ with uncommitted changes can succeed if the newly pulled changes don't
touch the locally changed files, but will fail otherwise.  Which makes a lot of
sense.
#+end_note

Git's fix is to ask you to commit (or stash) before you pull (which is fetch
followed by merge).

#+begin_src conf
    # up = "!git stash && git pull && git stash pop"
#+end_src

#+begin_warning
The above approach is *unsafe*: if there's nothing to stash, the first command
will do nothing, and then ~stash pop~ will unstash some random stuff from before.
#+end_warning

#+begin_src conf
    pull-autostash = ![[ -z $(git status --porcelain -uno) ]] && git pull || git stash save "autostash" && git pull && git stash pop
#+end_src

XXX What about ~git stash --include-untracked~ and ~git stash pop~?

#+begin_src conf
    up = pull --rebase --autostash
    up = !git fetch && git rebase --autostash FETCH_HEAD
#+end_src

See https://www.praqma.com/stories/git-autostash/.

See [[http://aanandprasad.com/git-up/][git-up]] (no longer maintained), which is (roughly) equivalent of executing the following:

#+begin_src shell :tangle no
git stash
git fetch --all
[foreach branch]
    git rebase --preserve-merges <branch> <remote>/<branch>
    git merge --ff-only <branch>
[end foreach]
git checkout <prev_branch>
git stash pop
#+end_src

#+begin_warning
Use with care: the final stash application after a successful rebase might
result in non-trivial conflicts.
#+end_warning

With *all versions* of Git, I recommend using ~git up~ instead of ~git pull~.

#+begin_src conf
    up-tmpname = "!f() { git remote update -p; git merge --ff-only @{u} ; }; f"
#+end_src

It is pretty safe: it will abort the merge if it can't be done using
fast-forward.  (In other words, if the local branch has diverged from the
remote.)

See https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful

~remote update -p~ *fetches* all refs from all remotes, instead of just the needed
one; ~merge~ then merges the appropriate *single branch*.

#+begin_src conf
    # Rebasing non-linear changes (when the fast-forward merge is not possible).
    upr = "!f() { git remote update -p; git rebase -p @{u} ; }; f"
#+end_src

#+begin_src conf
# cleanpull
# update (like svn? if we add a git reset in front?)
# sync
#+end_src

... but read "you're not using git as it was intended" on
https://news.ycombinator.com/item?id=2301765.

Before doing work (in a new branch), *ensure that the working directory is*
*up-to-date* with the ~origin~ (pull and get latest for all submodules):

#+begin_src conf
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive
    update = !git pull                     && git submodule update --init --recursive
#+end_src

[[https://gist.github.com/gitaarik/8735255][Git Submodules basic explanation]]

*** Update all local branches

Pull all:

#+begin_src conf
    pull-all = !"old=$(git rev-parse --abbrev-ref HEAD) ; for b in $(git for-each-ref refs/heads --format='%(refname)') ; do git checkout ${b#refs/heads/} ; git pull --ff-only ; done; git checkout ${old}"
#+end_src

See http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches
(+ interesting comments about *rebase vs merge during a pull*!)

#+begin_src shell :tangle ~/.dotfiles/bin/git-up-all :shebang #!/usr/bin/env bash
REMOTES="$@";
if [ -z "$REMOTES" ]; then
    REMOTES=$(git remote);
fi
REMOTES=$(echo "$REMOTES" | xargs -n 1 echo)

CLB=$(git branch -l | awk '/^\*/{print $2}');

echo "$REMOTES" | while read REMOTE; do
    git remote update --prune $REMOTE
    echo
    git remote show $REMOTE -n \
        | awk '/merges with remote/ {print $5" "$1}' \
        | while read line; do
              RB=$(echo "$line" | cut -f1 -d" ");
              ARB="refs/remotes/$REMOTE/$RB";
              LB=$(echo "$line" | cut -f2 -d" ");
              ALB="refs/heads/$LB";
              NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2> /dev/null) + 0));
              NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2> /dev/null) + 0));
              if [ "$NBEHIND" -gt 0 ]; then
                  if [ "$NAHEAD" -gt 0 ]; then
                      echo -e "[$LB \tis $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB.]  Not possible to fast-forward, aborting.";
                  elif [ "$LB" = "$CLB" ]; then
                      echo -e "[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Fast-forwarding merge...]";
                      # git merge --quiet $ARB;
                      git merge --ff-only --verbose $ARB;
                  else
                      echo -e "[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Resetting local branch to remote...]";
                      # git branch -l -f $LB -t $ARB > /dev/null;
                      git branch -l -f $LB -t $ARB;
                  fi
              else
                  echo -e "$LB \tAlready up to date.";
              fi
              echo
          done
done
#+end_src

XXX Is this ~sync~?

*** Delete all old local branches

Remove local branches no longer on remote (by deleting the local ones that show
they are "gone" in ~git branch -vv~):

#+begin_src conf
    # Git config alias escaping...  This DOES NOT work.
    # prunelocal = !sh -c 'git fetch -p && git branch -vv | grep \": gone]\" | awk \"{print $1}\" | xargs git branch -d'

    # Here is a correct solution (using bash as a command-line).
    prunelocal = "!f() { git fetch -p && git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -d ; }; f"

    # Here is a correct solution (which does not need access to the remote Git repo).
    prunelocal = "!f() { git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -d ; }; f"
#+end_src

What about

: git remote update --prune

instead?

*** Get timestamp of last pull

#+begin_src conf
    when = !stat -c %y .git/FETCH_HEAD | cut -d'.' -f1
#+end_src

** UPDATE - Merge

Merging means to *bring the contents of another branch* (possibly from an external
repository) *into the current branch*. [...]  Merging is performed by an automatic
process that identifies changes made since the branches diverged, and then
applies all those changes together.

: Merge branch 'branch_name' into master

#+begin_src conf
    # Will only try to "merge" if your current HEAD commit is in the branch
    # you're merging in.  This will allow you to merge some commits whilst being
    # sure you won't get conflicts.
    ff = merge --ff-only
    ff = merge --ff-only @{u}

    # Avoid a fast-forward commit.
    mm = merge --no-ff
#+end_src

*** Undo the merge

If you tried a merge which resulted in complex conflicts and want to start over,
you can recover with ~git merge --abort~.  It will allow you to *undo the merge*,
even if it is a fast-forward merge.

*** Dry run (do not make changes)

Naive (but slow) way:

#+begin_src shell :tangle no
rm -Rf /tmp/repository
cp -r repository /tmp/
cd /tmp/repository
git merge ...
# ... If successful, do the real merge.
#+end_src

#+begin_warning
It won't work just cloning to =/tmp=; you need a *copy* in order *to be sure that
uncommitted changes will not conflict*.
#+end_warning

Performing a Git merge with *no commit* and *no fast-forward* will merge the two
code bases together -- it will *modify your working copy*.  This will allow you to
examine, test, and undo the merge if required.

#+begin_src shell :tangle no
git merge --no-commit --no-ff $BRANCH
#+end_src

You can do ~git merge --abort~ after seeing that there are conflicts.

#+begin_src conf
    merge-check = "!f() { git merge --no-commit --no-ff $1; git merge --abort; echo 'Merge aborted'; }; f"
# works for git fetch & git merge
#+end_src

#+begin_warning
If your repository is a live Web server, then you could be serving files with
conflicts in.  That's why you should *never* be *handling merges on a live Web
server*!  Fix up the ~prod~ branch (on your development box) and then push it to
the real webserver with ~git pull --ff-only~.
#+end_warning

See if the merge is applicable to the current working tree and/or the index file
and *detects conflicts*:

#+begin_src conf
    # Check how the merge of `dev' into master will go: git merge-dry-run dev.
    merge-dry-run = "!f() { grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) && echo 'Merge conflicts!' || echo 'No merge conflicts'; }; f"
# DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { git merge-tree $(git merge-base $1 $2) $1 $2 | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' | cdiff; }; f"
#+end_src

*** Branch/Integration manager

If you're the Branch/Integration manager, you can use these aliases to *merge*
stuff (to select the entirety of either our or their file in a 3-way merge).

Often, during a merge, you know you want to take a file from one side wholesale.
The following aliases expose the:

- ~ours~ (stage #2) and
- ~theirs~ (stage #3)

commands which will let you pick a file(s) from

- the current branch (local) or
- the merged branch (remote)

respectively:

#+begin_src conf
    ours   = "!f() { git checkout --ours   $@ && git add $@; }; f"
    theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
#+end_src

#+begin_note
Using ~git checkout~ with ~--ours~ or ~--theirs~ expects at least one argument: the
*path(s)* of the *files / directories* to checkout.  If you use ~git checkout~ without
any files, then it takes the meaning of /switching branches/.
#+end_note

*Best (and safest) way to merge* a Git local branch into ~master~:

#+begin_src shell :tangle no
git checkout master
git pull origin master                  # Get the latest changes from the remote.
git merge test
git push origin master

git branch -d local_branch_name         # Delete local branch.
#+end_src

#+begin_warning
*Update first the branch (to merge in) of the RIGHT LOCAL CLONE.* -- if you do
have many clones on your file system.
#+end_warning

Best answer I have seen on ~git merge~ *strategies*:
https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies

*** List conflicted files

Unmerged files after a merge failure:

#+begin_src conf
    conflicts = "!git ls-files -u | cut -f 2 | sort -u"
#+end_src

** BRANCH - Branch

#+begin_tip
Consistent *naming conventions* (from the [[https://fr.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow][Gitflow]] Git workflow):
- ~master~ (used for deploying *production releases*)
- ~develop~ (used as integration branch for *"next release" development*)
- prefix ~feature/MSW-709-add-support-for-webm~ (for new *features*, such as Jira *stories*)
- prefix ~release/2018-12-24~ (used for preparing and testing *release* tasks)
- prefix ~hotfix/fix-123-for-production~ (used to *urgently fix* a Production branch)
- prefix ~support/~
- prefix ~bugfix/~ (typically used to fix Release branches, such as Jira *bugs*)
#+end_tip

See http://nuclearsquid.com/writings/git-tricks-tips-workflows/ for more
interesting stuff, such as:

- When branching off a remote branch, automatically let the local branch track
  the remote branch.

- When pushing without giving a refspec, push the current branch to its upstream
  branch. See the git config man page for more possible options.

#+begin_src conf
    co = checkout
#+end_src

#+begin_src conf
    # Switch to a branch, creating it if necessary.
    cob = checkout -b
#+end_src

#+begin_note
I think the recommended approach is to create a branch pointing at a
specific commit. So:

: git checkout -b test_branch 7e09ef09

Otherwise you're in a "detached head" state, which can have odd results.
The branch method is at least a little more stable.
#+end_note

#+begin_note
I usually branch off from the commit before the offending
commit and stay there until things are resolved (unless I'm able to
resolve it myself).

Or I branch off master and revert the offending commit until things are
resolved, ie. like so
 git checkout master
 git checkout -b sb-master
 git revert sha1-of-offending-commit
#+end_note

Checkout [[http://nvie.com/posts/a-successful-git-branching-model/][common branches]] (useful if you have feature branches):

#+begin_src conf
    master = checkout master
    develop = checkout develop
#+end_src

In case of error "The following untracked working tree files would be
overwritten by checkout", *move the untracked files*, instead of *deleting them*.
For example:

#+begin_src shell :tangle no
cd "$(git rev-parse --show-toplevel)"
git checkout BRANCH 2>&1 | while read f; do [ ! -e "$f" ] || mv "$f" "$f.bak"; done
#+end_src

*List all branches* (both local remote-tracking and local branches), showing SHA1
and commit subject line for each head, along with the name of the upstream
branch (if any).

#+begin_src conf
    br = branch -a -vv
#+end_src

Delete a *local* branch:

#+begin_src conf
    bd = branch -d
#+end_src

#+begin_note
The -d (--delete) option only deletes the branch if it has already been fully
merged in its upstream branch. You could also use -D, which is an alias
for --delete --force, which deletes the branch "irrespective of its merged
status."
#+end_note

Delete a *remote* branch:

#+begin_src shell :tangle no
git push origin --delete <remote_branch_name>
#+end_src

~git bclean~ is meant to be run from your master (or default) branch and does the
cleanup of merged branches.

#+begin_src conf
    bclean = "!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"
#+end_src

When I'm done with this topic branch and I want to clean everything up on my
local machine, I use ~git bdone~:

1. Switch to master (though you can specify a different default branch)
2. Run git up to bring master up to speed with the origin
3. Delete all branches already merged into master using another alias,
   ~git bclean~

#+begin_src conf
    bdone = "!f() { git checkout ${1-master} && git up && git bclean ${1-master}; }; f"
#+end_src

See http://haacked.com/archive/2014/07/28/github-flow-aliases/.

#+begin_src conf
    # Current branch.
    cb = "name-rev --name-only HEAD"
#+end_src

*** How to git diff all changes since branching from master?

Show all commits in a git branch since original branching point from master:

#+begin_src conf
    diffsincemaster = diff master...
    logsincemaster = log master...
#+end_src

https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git:

#+begin_src conf
    oldest-ancestor = !zsh -c 'diff --old-line-format='' --new-line-format='' <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | head -1' -
    branchdiff = !sh -c 'git diff $(git oldest-ancestor)..'
    branchlog  = !sh -c 'git log $(git oldest-ancestor)..'

    diverges = !sh -c 'git rev-list --boundary "${1:-HEAD}"..."${2:-master}" | grep "^-" | cut -c2-'
#+end_src

When you use three dots, ~git diff~ finds the merge-base between the left and
right side commit SHA1s (as obtained from the names, or defaulting to ~HEAD~) and
substitutes that in for the left-side SHA1. The right-side SHA1 (as resolved
from the name) remains intact.

*** Rename branch

Sometimes we name a branch poorly or maybe we thought the name was "good" but
not meaningful to the work we are doing.

To rename the branch locally:

#+begin_src conf
    rename = branch -m
#+end_src

One thing to keep in mind is that this command works in two different ways:

- If we are on the branch we want to rename, we can just ~git rename <new-name>~.
- If we are not on the branch, we have to use ~git rename <target-branch>
  <new-name>~.

*** List branches that contain a given commit ID (SHA1)

Filter the list of *branches* to only those which have the given *commit ID* among
their ancestors.

#+begin_src conf
    where = "branch -a --contains"

    # Find branches containing commit.
    findb = "!f() { git branch -a --contains $1; }; f"
#+end_src

This also includes *remote tracking branches* in the list, that is "local
branches that have a direct relationship to a remote branch".

List all *tags* that contain a commit ID:

#+begin_src shell :tangle no
git tag --contains a2c71a6
#+end_src

#+begin_src conf
    # Find tags containing commit.
    findt = "!f() { git describe --always --contains $1; }; f"
#+end_src

*** See which changes from a branch are already present upstream

While on "feature" branch:

#+begin_src shell :tangle no
git cherry -v master
#+end_src

#+begin_example
+ 497034f2 Listener.new now accepts a hash of options
- 2d0333ff cache the absolute images path for growl messages
+ e4406858 rename Listener#run to #start
#+end_example

The ~cherry~ command is useful to see which commits have been cherry-picked from
a development branch to the stable branch, for instance. This command compares
changes on the current (~feature~) branch to upstream (~master~) and indicates which
are present on both with the ~-~ sign. Changes still missing from upstream are
marked with ~+~.

*** Recover a branch after its deletion in Git

Most of the time unreachable commits are in the reflog. So, the *first thing to
try is to look at the reflog* using the command ~git reflog~ (which display the
reflog for ~HEAD~).

1. Perhaps something easier if the commit was part of a specific branch still
   existing is to use the command ~git reflog name-of-my-branch~ to *find the SHA1*
   for the commit at the tip of your deleted branch -- It works also with
   a remote, for example if you forced push.  Otherwise, use ~git reflog~.
2. Then, you can just ~git checkout -b <branch> <sha1>~ to recreate the branch
   from there.

See https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git

** Stash

A *stash* is nothing but a *(temporary) branch*.

~git stash~ makes a temporary copy of the changes in your *index* (staging area) and
*working tree*, and clears the decks so you can easily work on something else; it
reverts your local modifications, allowing you to get rid of some incomplete
changes.

#+begin_tip
Use ~git stash~ if Git refused to merge because it foresees conflicts.
#+end_tip

Information that is used by default if you don't provide a message:

#+begin_example
stash@{0}: WIP on <branch>: <sha1 of head> <title line of head>
#+end_example

You can operate on the "stash" ref as if it were any other ref.

*** Stash save

~git stash save~ also optionally takes a message describing the contents of the
stash (much, much more useful):

#+begin_src conf :tangle no
git stash save "DESCRIBE WHAT YOU DID HERE"
#+end_src

#+begin_example
stash@{0}: On <branch>: DESCRIBE WHAT YOU DID HERE
#+end_example

This command is useful in saving all changes not ready to be committed and the
user wants to have an updated repository.

#+begin_src conf
    # Save with name.
    ss = stash save
    ssave = stash save
#+end_src

#+begin_src conf
    sshow = "!f() { git stash show stash^{/$@} -p; }; f" # Like sapply but shows it only

    sapply = "!f() { git stash apply stash^{/$@}; }; f" # Find stash with name like text

    spop = "!f() { git stash pop stash@{$(git stashid $@)}; }; f" # Like sapply but pops it off

    stashid = "!f() { git stash list | grep $@ | head -n 1 | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; }; f" # only accepts single word, no quotations

    hide = stash save --include-untracked # hides all files, including untracked files (faster than using --all)
#+end_src

#+begin_src conf
    sspatch = stash save --patch
    ssscratch = stash save --keep-index
#+end_src

*** Apply the stash only, don't delete it

When you're done, with ~git stash apply~ (top stash by default), you're back where
you were.  But if that doesn't work, for whatever reason, you can use any of
Git's other branch merging tools to put things back they way you want them.

#+begin_src conf
    sa = stash apply
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    sapply = "!f() { git stash apply stash^{/$*}; }; f"
#+end_src

*** Show a list of all stashes

#+begin_src conf
    sl = stash list
    stashes = stash list
#+end_src

*** Stash pop

~git stash pop~ removes the most recent stash or any stash specified and applies
changes as a merge.  If merge fails, the stash is not removed from the list and
must be removed manually.

#+begin_src conf
    sp = stash pop
#+end_src

#+begin_warning
Be aware that, unlike ~git stash apply~ (though it has its use), ~git stash pop~
*deletes the applied stash* -- /only/ if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!
#+end_warning

*** Show the stash

#+begin_src conf
    ssh = stash show -p
    stashdiff = stash show -p
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    sshow = "!f() { git stash show stash^{/$*} -p; }; f"
#+end_src

One very useful feature one may consider is to list contents of all local
stashes:

#+begin_src shell :tangle no
git stash list | awk -F: '{ print "\n\n\n\n"; print $0; print "\n\n"; system("git stash show -p " $1); }'
#+end_src

Press [Q] to exit each stash.

It helped me a lot in the past (cleaning stashes stack).

*** Stash show name-only

#+begin_src conf
    sshno = stash show --name-only
#+end_src

*** Drop the stash

#+begin_src conf
    std = stash drop
#+end_src

*** Take named stash

#+begin_src conf
    snapshot = !git stash save "Snapshot [$(date +\"%F %a %R\")]" && git stash apply "stash@{0}"
#+end_src

#+begin_src conf
    # checkpoint and checkpoint recover
    cp      = !git stash save $(date +%F--%T) && git stash pop --index
    cpr     = "!f() { git fsck | grep commit | cut -d' ' -f3 | while read hash; do git rev-parse --verify --no-revs --quiet $hash^2 2>/dev/null && echo $hash | xargs git rev-list --since=${1:-1day} -1; done | xargs -L 1 git log --format=%at:%h -1 | sort|cut -f2 -d: | xargs -L 1 git log --graph --oneline --format='%Cblue%h %Cgreen(%ar) %Creset%s' -3 ; }; f"
#+end_src

*** Other commands

#+begin_src shell :tangle no
git stash clear
#+end_src

#+begin_src conf
    stash-unapply = !git stash show -p --no-textconv --binary | git apply -R
#+end_src

#+begin_src conf
    # "show-branch -g=N" can't be aliased for N easily, so we stop here:
    sb  = show-branch
    # pg sbt master pu -- if the last line is 'master' and not 'master^'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics
    sbs = show-branch --sha1-name
#+end_src

*** Workflows

Alternative to ~stash~ (writing a commit with a default message):

XXX See doc of git help stash for workflows...

1. Do a regular ~commit~:

   #+begin_src shell :tangle no
   git add -A && git commit -m 'WIP'       # Add all changes (including untracked files).
   #+end_src

2. Do some other work...

3. Return to previous work:

   #+begin_src shell :tangle no
   git reset --mixed                       # Reset the previous commit (but
                                           # keeps all the changes from that
                                           # commit in the working directory).

   git reset --soft                        # Or this one???
   #+end_src

   Or, if I merely need to modify the *previous* commit:

   #+begin_src shell :tangle no
   git commit -a --amend
   #+end_src

   The ~-a~ adds any modifications and deletions of existing files to the commit
   but ignores brand new files.

   The ~--amend~ launches your default commit editor and lets you change the
   commit message of the *most recent* commit.

*** From git help stash

       Pulling into a dirty tree
           When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple git pull will let
           you move forward.

           However, there are cases in which your local changes do conflict with the upstream changes, and git pull refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:

               $ git pull
                ...
               file foobar not up to date, cannot merge.
               $ git stash
               $ git pull
               $ git stash pop

       Interrupted workflow
           When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to
           make the emergency fix, like this:

               # ... hack hack hack ...
               $ git checkout -b my_wip
               $ git commit -a -m "WIP"
               $ git checkout master
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git checkout my_wip
               $ git reset --soft HEAD^
               # ... continue hacking ...

           You can use git stash to simplify the above, like this:

               # ... hack hack hack ...
               $ git stash
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git stash pop
               # ... continue hacking ...

       Testing partial commits
           You can use git stash save --keep-index when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:

               # ... hack hack hack ...
               $ git add --patch foo            # add just first part to the index
               $ git stash save --keep-index    # save all other changes to the stash
               $ edit/build/test first part
               $ git commit -m 'First part'     # commit fully tested change
               $ git stash pop                  # prepare to work on all other changes
               # ... repeat above five steps until one commit remains ...
               $ edit/build/test remaining parts
               $ git commit foo -m 'Remaining parts'

       Recovering stashes that were cleared/dropped erroneously
           If you mistakenly drop or clear stashes, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stashes that are still in your repository, but not reachable any
           more:

               git fsck --unreachable |
               grep commit | cut -d\  -f3 |
               xargs git log --merges --no-walk --grep=WIP

** PUBLISH - Push

It is useful to know if you have any *local commits* that are not in the remote
branch.

#+begin_note
It is a good idea to examine what you are about to push, before actually doing
so, because fixing mistakes before pushing is much easier. To do that, use the
command "git diff origin/master". If you want to show your unpushed commits with
their commit log messages, use "git show origin/master.." instead. If you only
have one local commit you want to push, just "git show" is enough.

> It is not clear to me how these two differ.  Does "git show origin/master.."
> output everything that "git diff origin/master" outputs, plus log messages?

Yes, that's the only real difference between them, when you have no uncommitted
changes.  (When you do have uncommitted changes, "git diff" will include them,
while "git show" will not.)
#+end_note

The ~out~ command returns a list of *unpushed* (outgoing) commits for the *current
branch*, the next time you do a push.

#+begin_src conf
    out = log --date=short @{u}..
    out-stat = log --stat --date=short @{u}..
#+end_src

This causes ~git log~ to show all commits reachable from ~HEAD~ excluding those
reachable from the upstream branch.  The ~@{u}..~ argument is equivalent to
~@{u}..HEAD~, where ~HEAD~ stands for the last commit in your local branch, but ~HEAD~
can be omitted for shorthand purposes.

If you want to see all *unpushed* commits from *all branches*, do this:

#+begin_src conf
    outgoing = log --branches --not --remotes --decorate
#+end_src

*** Upload your changes

Use ~git push -u origin new/branch~ to push the ~new/branch~ branch to the ~origin~
remote and to set up tracking.

#+begin_src conf
    # Get the current branch name (not so useful in itself, but used in other
    # aliases).
    branch-name = !git rev-parse --abbrev-ref HEAD

upstream-name = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)

    # Push the current branch to the remote "origin", and set it to track the
    # upstream branch.
    publish = !git push -u origin $(git branch-name)

    unpublish = !git push origin :$(git branch-name)
#+end_src

~git publish~ is a shortcut for manually typing the branch name:

: git push origin -u <current-branch>

#+begin_src conf
    export-branch = !git format-patch --stdout $1 > ~/$(git branch-name).diff
#+end_src

** PUBLISH - Find out if a change is part of a release

#+begin_src conf
    sha1-tag = '!f() { git name-rev --name-only "$@"; }; f'
#+end_src

The ~name-rev~ command indicates the *position of a commit relative to tags* in the
project. For example, ~v2.3~5~ means that this commit is located 5 commits *before*
the v2.3 tag -- we can be certain that this change is part of v2.3, then.

** PUBLISH - ChangeLog

Generate an Org mode version of your ChangeLog:

#+begin_src conf
    chlogm =  !sh -c 'git log $1...$2  --pretty=format:\"%s [[http://github.com/$3/$4/commit/%H][view commit]]\"' -
#+end_src

Use it like this:

#+begin_src shell :tangle no
git chlogm first_tag last_tag github_user github_repo
#+end_src

See also https://github.com/github-changelog-generator/github-changelog-generator.

** PUBLISH - Prepare a release

Save a repo as a tarball:

#+begin_src conf
    export = archive -o latest.tar.gz -9 --prefix=latest/
#+end_src

#+begin_src conf
  # # Deploy
  # staging = !git push heroku-staging $(git name):master -f && git track 'Deployed to staging ' # push current branch to staging, can add more comments after
  # dev = !git push heroku-dev $(git name):master -f && git track 'Deployed to dev ' # push current branch to dev
  # deploy = !git push heroku $(git name):master -f && git track 'Deployed to produciton ' # push current branch to production
#+end_src

** PUBLISH - Tag

When tagging releases in a version control system, the tag for a version should
be ~X.Y.Z~ (*without* prefix ~v~).  The advantages of ~X.Y.Z~ are that gitweb or GitHub
can automatically offer a tarball or zip download of the form
~packagename-$tag.tar.gz~ (and it's quite established that a tarball should be
named ~package-X.Y.Z.tar.gz~).

Basically, *lightweight tags* are just pointers to specific commits. *No further
information is saved*; on the other hand, *annotated tags* are *regular objects*,
which have an author and a date and can be referred because they have their own
SHA key.

If knowing *who* tagged *what* and *when* is relevant for you, then use annotated
tags. If you *just want to tag a specific point in your development*, no matter
who and when did that, then lightweight tags are good enough.

#+begin_note
Annotated tags are meant for release while lightweight tags are meant for
private or temporary object labels.
#+end_note

#+begin_src shell :tangle no
git tag <tagname>
#+end_src

The tag will be a *lightweight tag* by default.

Show the last tag:

#+begin_src conf
    version = describe --tags
    lasttag = describe --tags --abbrev=0
#+end_src

List tags using (better) version sorting (if your ~sort~ supports it):

#+begin_src conf
    # Show verbose output about tags.
    tags = tag -l
    tags = !git tag | sort -V
#+end_src

You can do a lot better with:

#+begin_src conf
    releases = log --decorate --oneline --simplify-by-decoration --all
#+end_src

** Debugging

Sometimes it's nice to see what is going on under the hood. Try this alias:

#+begin_src conf
    debug  = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"
#+end_src

Just insert ~debug~ between ~git~ and whatever would usually follow; for example:

#+begin_src shell :tangle no
git debug unwip
#+end_src

** Abbreviations

Basic shortcuts.

#+begin_src conf
    ci = commit
#+end_src

#+begin_src conf
    cp = cherry-pick -x
    pick = cherry-pick -s
#+end_src

#+begin_src conf
    h = help
#+end_src

** Get the Git root directory

#+begin_src conf
    root = rev-parse --show-toplevel
#+end_src

#+begin_src conf
    # Get the path cleaned up.
    root = !pwd -P
#+end_src

#+begin_note
This works because Shell aliases are always executed in the top-level directory.
#+end_note

** Remove deleted files

Removing multiple files from a Git repo that have already been deleted from
disk:

#+begin_src conf
    rma = !git ls-files --deleted -z | xargs -0 git rm
#+end_src

** Sync

#+begin_src conf
    sync = !git pull && git push
#+end_src

#+begin_src conf
    sync = !git update && git co master && git pull && git commit @{-1}
#+end_src

That's rather basic - it doesn't actually rebase my branch that I'm on.

Let's do a slightly different command: ~resync~

#+begin_src conf
    # git resync -> sync repository and rebase current branch.
    resync = !sh -c 'BRANCH_NAME=master && git checkout master && git fetch && git reset --hard origin/master && git rebase master'
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
    record = !sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit, it
will ~reset~ the index.

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
    lost = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%C(reset)  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

** Tips and tricks

Directed Acyclic Graph:

#+begin_src conf
    graphviz = "!f() { echo 'digraph git {' ; git log --pretty='format:  %h -> { %p }' \"$@\" | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; echo '}'; }; f"
#+end_src

** TODO To sort out

#+begin_src conf
    # 2009-05-26  (merged-bed-bug) 6fe85ff regenerate rules Brad Bowman
    logdate = log --format=format:'%ad %d %h %s %an%n' --date=short
    br-date = !"sh -c 'for b in $(git branch --no-merged) ; \
               do git logdate -1 -r $b --; done'"
#+end_src

** COMMENT Git and Subversion

#+begin_src conf :tangle no
    spull = svn rebase
    spush = svn dcommit
    slog = svn log --oneline --show-commit
#+end_src

#+begin_src conf :tangle no
    cvs-full-log = log --reverse --pretty=format:'%B\n--------------------------------------------\n'
    cvsmerge = merge --no-ff --log
#+end_src

* What if

... I'm working on master adding a simple feature. After a few minutes I realize
it was not so simple and it should have been better to work into a new branch.

http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master

* If you made a mistake

# Absolutely read https://github.com/blog/2019-how-to-undo-almost-anything-with-git!

* Recover from problems
:PROPERTIES:
:header-args+: :tangle no
:END:

It is POSSIBLE that a safe way to recover from your problems is as follows:

#+begin_src shell
git stash
git reset --hard HEAD
git pull --ff-only
git stash apply
#+end_src

Of course, if any of the commands but the last fails, stop and ask for advice
again. If the last one reports merge conflicts, fix them by hand and run ~git add~
on each file after you fixed it. DO NOT use C-x v v after fixing a merge
conflict, since that runs both git add and git commit, and you are not ready for
the latter until all merge conflicts are dealt with.

In any case, do run git status before finally doing git commit. If all succeeds,
you can clean up with:

#+begin_src shell
git stash drop
#+end_src

** Review which file have conflicts

This command tells you which files have conflicts after merging.

#+begin_src conf :tangle ~/.dotfiles/home/.gitconfig
    conflicts = diff --name-only --diff-filter=U
    unmerged = diff --name-only --diff-filter=U
#+end_src

** Alternative

If your master branch is busted, rename it to something else so that it's out of
the way:

#+begin_src shell
git branch -m master master-busted
#+end_src

Create a new branch ~master~ that tracks the origin:

#+begin_src shell
git branch --track master origin/master
#+end_src

Check it out (be careful, this will discard all your local changes):

#+begin_src shell
git checkout -f master
#+end_src

Make sure the ~master~ is up-to-date:

#+begin_src shell
git pull
#+end_src

** A GitHub test repository to experiment with conflicts

You can experiment with resolving a Git conflict with this repository:
https://github.com/brianleetest/testGit/blob/master/README.md

* GitHub tasks
:PROPERTIES:
:header-args+: :tangle no
:END:

# https://github.com/abo-abo/oremacs/blob/github/etc/org/wiki/git.org

** Force push

#+begin_src shell
git push --force origin master
#+end_src

** Push tags

#+begin_src shell
git push --tags
#+end_src

** Get user pubkeys

#+begin_src shell
curl https://github.com/abo-abo.keys
#+end_src

** Routine

#+begin_src shell
git fetch --all
#+end_src

This results in all pull requests available in the local repo in the local pull/
namespace.

To check out e.g. PR #42:

#+begin_src shell
git checkout -b foo refs/pull/upstream/42
#+end_src

* Git workflows

It may be helpful to do a some background reading on workflows with Git.  Here
is the gitworkflows man page:
https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html

Other doc on branch models:

http://nvie.com/posts/a-successful-git-branching-model/
http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html
http://williamdurand.fr/2012/01/17/my-git-branching-model/

* References

- https://github.com/tj/git-extras
- https://hub.github.com/hub.1.html
- http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
# - [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]

* Free private repositories

I use the *free private repos* from https://bitbucket.org/.
