#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: Pretty format for `git log' and different helpful command aliases
#+KEYWORDS:  git, log, pretty format, alias
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2

#+SETUPFILE: ~/.dotfiles/org/theme-readtheorg.setup

#+EXPORT_EXCLUDE_TAGS: noexport
#+PROPERTY:  header-args :tangle .gitconfig :eval no

XXX Git-extras (extra commands!)
https://github.com/tj/git-extras/blob/master/Commands.md

XXX Hub (extra commands!)
https://github.com/github/hub/blob/master/share/man/man1/hub.1.md

XXX Bitbucket API
https://developer.atlassian.com/bitbucket/api/2/reference/resource/

XXX Bitbucket API client for Browser and Node.js
https://bitbucketjs.netlify.com/

XXX
https://help.github.com/en/github/searching-for-information-on-github/

XXX GitLab API
https://docs.gitlab.com/ee/api/

XXX GitAlias.com file of many git alias items, including shortcuts, helpers, workflows, etc.
https://github.com/gitalias/gitalias/blob/master/gitalias.txt

XXX Today I learned
https://til.hashrocket.com/git

*Commit early, commit often* (and with the right message): it is a bad idea to do
a lot of work without committing... But don't push every single commit: push
when changes are tested!

Branch out often.
http://kentnguyen.com/development/visualized-git-practices-for-team/
(definition of git rebase)

* Overview

- This is Git.  It tracks collaborative work on projects through a beautiful
  distributed graph theory model.

- Cool.  How do we use it?

- No idea.  Just memorize these Shell commands and type them to sync up.  If you
  get errors, save your work elsewhere, delete the project, and download a fresh
  copy.

  If that doesn't fix it, =git.txt= contains the phone number of a friend of mine
  who understands git.  Just wait through a few minutes of 'It's really pretty
  simple, just think of branches as...' and eventually you'll learn the commands
  that will fix everything.

https://bitbucket.org/blog/get-git-guru-gold-with-bitbuckets-glorious-git-guides

These are common Git commands used in various situations:

- start a working area (see also: git help tutorial)
  + clone ::      Clone a repository into a new directory
  + init ::       Create an empty Git repository or reinitialize an existing one

- work on the current change (see also: git help everyday)
  + add ::        Add file contents to the index
  + mv ::         Move or rename a file, a directory, or a symlink
  + reset ::      Reset current HEAD to the specified state
  + rm ::         Remove files from the working tree and from the index

- examine the history and state (see also: git help revisions)
  + bisect ::     Use binary search to find the commit that introduced a bug
  + grep ::       Print lines matching a pattern
  + log ::        Show commit logs
  + show ::       Show various types of objects
  + status ::     Show the working tree status

- grow, mark and tweak your common history
  + branch ::     List, create, or delete branches
  + checkout ::   Switch branches or restore working tree files
  + commit ::     Record changes to the repository
  + diff ::       Show changes between commits, commit and working tree, etc
  + merge ::      Join two or more development histories together
  + rebase ::     Reapply commits on top of another base tip
  + tag ::        Create, list, delete or verify a tag object signed with GPG

- collaborate (see also: git help workflows)
  + fetch ::      Download objects and refs from another repository
  + pull ::       Fetch from and integrate with another repository or a local branch
  + push ::       Update remote refs along with associated objects

* Comments on branching (from Matthias)

If you have finished your work, feel free to merge the branch into =master= (maybe
you want to rebase your WIP branch before based on =master=):

The following sequence is here very helpful:

1. git checkout master
2. git pull (this makes sure that your local =master= branch matches the remote one)
3. git checkout WIP
4. git rebase master
5. git checkout master
6. git merge WIP

after this you can delete your local WIP branch and or if you pushed it the
remote one too.

* TODO See more Git configs (and aliases)

- https://github.com/alikins/gitconfig/blob/master/gitconfig
- https://github.com/GitAlias/gitalias

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *BE EXTREMELY CAREFUL*!
#+end_warning

* COMMENT Tasks

See https://blog.liip.ch/archive/2015/12/11/git-tips-tricks.html!!! XXX

** TODO Look at Git Power Routines [course]

https://www.youtube.com/playlist?list=PLDshL1Z581YYxLsjYwM25HkIYrymXb7H_

** TODO Read about Git

http://marlacorinne.4parkers.com/2012/07/20/git-pull-vs-git-fetch-then-merge/
https://adamcod.es/2014/12/10/git-pull-correct-workflow.html

** TODO Outsource and include private entries in .gitconfig

Git 1.7.10+ supports this syntax in =.gitconfig=:

#+begin_src conf :tangle no
[include]
    path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a =.gitconfig= file for your nonsensitive information and a git ignored
=.githubconfig= file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

Mix professional and personal Git configurations:

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

** TODO git-repos

http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html

** TODO Git Quick Start For Emacs Devs

http://www.emacswiki.org/emacs/GitQuickStartForEmacsDevs

** TODO Work in progress which I can't commit (from Stephen J. Turnbull)

#+begin_verse
 > > With git pull, if there are changes in the working directory, the
 > > merge (i.e. merge from remote/master into master) part of the
 > > operation is aborted before it starts, giving a message describing its
 > > refusal.  It does this even when there are no conflicts to deal with.
 >
 > What are we supposed to do in that case, if we're not yet ready to
 > commit our files?

If you have work-in-progress and feel unable to commit, but at the
same time feel the need to pull into that workspace, I suggest you get
up and walk around, fight off the pull urge, then finish the commit
after your head cools off.

If that isn't satisfactory, then

 > or putting our work into a new branch, like:
 >
 > --8<---------------cut here---------------start------------->8---
 > git create-branch new-branch-name
 > git commit -a -m "Edited"
 > git checkout master
 > git pull
 > ...
 > --8<---------------cut here---------------end--------------->8---

is one way to go.  Another possibility is creating a new workspace,
with cp -a or similar.

If you need the pulled code for your work, then a quick stash is the
better idea.
#+end_verse

** Git the simple guide

http://rogerdudler.github.io/git-guide/

** Git rebase branch

#+begin_src shell :tangle no
git pull --rebase -r origin master
#+end_src

* Settings

** User

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
    name = John Doe
    email = john.doe@example.com

[github]
    user = jdoe
#+end_src

You should "override" the above with your personal details:

#+begin_src conf
[include]
    path = ~/.gitconfig_local
#+end_src

Or create a Git command to set email addresses for you:

#+begin_src conf
[alias]
    workprofile = config user.email \"john@work.com\"
#+end_src

** Core

#+begin_src conf
[core]
    editor = emacsclient
#+end_src

*Text viewer* for use by Git commands.

#+begin_note
When the ~LESS~ environment variable is unset, Git sets it to ~FRSX~.  If the ~LESS~
environment variable is set, Git does not change it at all.

We use ~-R~ in the command itself to be sure to *interpret the color codes* when Git
is run from /Windows/ Emacs (~C-x v l~), with /no/ value for the ~LESS~ /environment
variable/.
#+end_note

#+begin_src conf
    # git-grep to ignore ^M.
    pager = tr -d '\\r' | less -REX
#+end_src

Stop viewing ~^M~ symbols in diff:

#+begin_src conf
    # whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
    whitespace = cr-at-eol
#+end_src

#+begin_src conf :tangle no
    autocrlf = input
    safecrlf = true

    autocrlf = false
    safecrlf = false
#+end_src

Performance:

#+begin_src conf
    # Do filesystem operations in parallel to hide latency (default since v2.1).
    preloadindex = true

    # Fix UAC issues so you don't need to run Git as administrator (default since v2.8).
    fscache = true

[gc]
    # Minimize the number of files in .git/.
    auto = 256
#+end_src

** Log

Get a better date (current format is 2019-11-26 17:35:30 +0100):

#+begin_src conf
[log]
    date = iso
    #+end_src

** Diff

#+begin_src conf
[diff]
    renames = copies
    renameLimit = 30000
#+end_src

Using the patience diff algorithm to compare large swathes of repetitive text
(hello, xml!) often produces a much more readable diff that will reveal context
and therefore hopefully bugs/typos etc.

Here's a quick snippet of a diff to show it helping. Bare LCS-based diff:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
+}
+
+def somethingelse {
+    something += 1
 }

 def thing2 {
     something += 2
 }
#+end_src

With ~patience~ becomes:

#+begin_src diff :tangle no
 def thing1 {
     something += 1
 }

+def somethingelse {
+    something += 1
+}
+
 def thing2 {
     something += 2
 }
#+end_src

Same end result but much easier to read.

    #+begin_src conf
    algorithm = patience
#+end_src

Git diff will use (i)ndex, (w)ork tree, (c)ommit and (o)bject instead of a/b/c/d
as prefixes for patches:

#+begin_src conf
    mnemonicprefix = true
#+end_src

#+begin_src conf
    noprefix = true
#+end_src

*** Use Meld as Git ~difftool~

#+begin_src conf
    tool = meld

[difftool]
    prompt = false

[difftool "meld"]
    cmd = meld "$LOCAL" "$REMOTE"
#+end_src

Use a generic rev syntax (rev-parse) to transparently allow complex rev
expressions.

#+begin_src conf
[alias]
    showtool = "!f() { rev=$(git rev-parse \"${*:-HEAD}\"); git difftool $rev~1 $rev; }; f"
#+end_src

This allows doing nice things like:

#+begin_src shell :tangle no
git showtool :/some nasty bug
#+end_src

Diff the last commit for a given file:

#+begin_src conf
    diff-file-last-commit = "!f() { \
            project_root_dir=$(git root); \
            echo finding full file path of $1 in $project_root_dir; \
            filepath=$(find $project_root_dir -type f -name $1); \
            echo full file path $filepath; \
            last_modified_commit_hash=$(git rev-list -1 HEAD $filepath); \
            echo last commit file modified $last_modified_commit_hash; \
            git difftool $last_modified_commit_hash^ $filepath; \
        }; f"
#+end_src

Usage (no matter where you are in the repo):

#+begin_src shell :tangle no
git diff-file-last-commit File.cpp
#+end_src

This opens your configured ~difftool~ with the changes to File.cpp in the last
commit it was touched.

*** Performing directory diffs (Comparing folders)

The following command makes it similar to the =git-meld.pl= script here:
https://github.com/wmanley/git-meld:

#+begin_src conf
[alias]
    diffall = "!git difftool -t meld --dir-diff"
#+end_src

** Apply

#+begin_src conf
[apply]
    # Detect whitespace errors when applying a patch.
    whitespace = fix
#+end_src

** Fetch

Automatically delete local branches that have been removed from remote on
fetch/pull:

#+begin_src conf :tangle no
[fetch]
    prune = true
#+end_src

** Status

If you are using submodules, it might be useful to turn on the submodule summary.

#+begin_src conf
[status]
    submoduleSummary = true
#+end_src

** Pull

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
    rebase = true
#+end_src

(The merge commit doesn't get deleted!)

** Push

Push *only* the *current working branch* (sane pushing -- instead of pushing all
branches), with an added safety: only if it is /tracking/ a remote upstream branch
with the /same name/.

#+begin_src conf
[push]
    default = simple
#+end_src

(~simple~ is the default in Git 2.x)

** Merge

#+begin_src conf
[merge]
    stat = true
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true
#+end_src

#+begin_src conf
    conflictstyle = diff3
#+end_src

- For small changes, ~git diff~ and ~vc-diff~ are perfect.
- For medium changes, ~magit~ is perfect.
- For large changes, [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD) is perfect.

How to resolve merge conflicts in Git?  Try ~git mergetool~.

*** Emacs as a Git mergetool

Ediff or Emerge?  Or Magit???

#+begin_src conf :tangle no
[merge]
    tool = ediff

[mergetool "ediff"]
    cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
    keepBackup = false
#+end_src

*** Meld as Git mergetool

*How do I set up and use Meld as my git mergetool?*
See https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool.

See ~auto-merge~ in
https://stackoverflow.com/questions/11133290/git-merging-using-meld (first and
second solution).

#+begin_src conf
    tool = meld
#+end_src

Firstly here is what the parameters mean:

- ~$LOCAL~ is the file in the *current branch* (e.g. ~master~).

- ~$REMOTE~ is the file in the *branch being merged* (e.g. ~branch_name~).

- ~$MERGED~ is the *partially merged file* with the merge conflict information in
  it.

- ~$BASE~ is the *common ancestor* of ~$LOCAL~ and ~$REMOTE~, this is to say the file as
  it was (before both changes) when the branch containing ~$REMOTE~ was originally
  created.

I suggest you use either:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$MERGED" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

or:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

The choice is whether to use ~$MERGED~ or ~$BASE~ in between ~$LOCAL~ and ~$REMOTE~.

Either way, Meld will display 3 panes with:

- ~$LOCAL~ in the left pane,
- ~$REMOTE~ in the right pane and
- either ~$MERGED~ or ~$BASE~ in the middle pane.

In BOTH cases, *the middle pane is the file that you should edit to resolve the
merge conflicts*.  The difference is just in which starting edit position you'd
prefer:

- ~$MERGED~ for the file which contains the partially merged file with the merge
  conflict information or

- ~$BASE~ for the shared commit ancestor of ~$LOCAL~ and ~$REMOTE~.

#+begin_note
Since both cmd lines can be useful, I keep them both in my =.gitconfig= file. Most
of the time I use the ~$MERGED~ line and the ~$BASE~ line is commented out, but the
commenting out can be swapped over if I want to use the ~$BASE~ line instead.
#+end_note

#+begin_src conf
[mergetool "meld"]
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    keepBackup = false
#+end_src

** Rebase

Set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they pull.

#+begin_src conf
[rebase]
    stat = true
#+end_src

#+begin_warning
At this point, let us remind you of [[https://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing][the perils of rebasing]].
#+end_warning

** Grep

https://git-scm.com/docs/git-grep

#+begin_src conf
[grep]
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    fullName = true
#+end_src

** Color

Instead of hardcoding colors, I suggest:

#+begin_src conf
[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto
#+end_src

See http://git-scm.com/docs/git-config for the ~slot~ list.

*** Branch

#+begin_src conf
[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse
#+end_src

*** Diff

See http://git-scm.com/docs/git-config for the ~slot~ list.

#+begin_src conf
[color "diff"]
    plain = "#888888"
    meta = yellow bold
    frag = magenta bold
    func = "#cc99cc"
    old = red bold
    new = green bold
    commit = yellow
    whitespace = red reverse
#+end_src

*** Status

#+begin_src conf
[color "status"]
    header = normal
    added = green bold
    changed = yellow bold
    untracked = cyan
    branch = cyan bold
    nobranch = bold ul blink 12
    unmerged = red reverse bold
#+end_src

- added = modified
- changed = updated

*** Grep

The first color given is the foreground; the second is the background.", e.g
~match 10 22~ -- see ~man 1 git-config~ at "CONFIGURATION FILE" > "Values" >
"color".

#+begin_src conf
[color "grep"]
    context = "#888888"
    filename = yellow bold
    function = red
    linenumber = magenta bold
    match = green reverse bold
    matchContext = yellow reverse bold
    matchSelected = yellow bold blue
    separator = red bold
    selected = white
#+end_src

** Proxy

#+begin_src conf :tangle no
[http]
    proxy = http://proxy-guest.forem.be:8080
#+end_src

#+begin_src conf
[alias]
    # Proxy.
    setproxy = !git config --global http.proxy http://proxy-guest.forem.be:8080 && git config --global https.proxy https://proxy-guest.forem.be:8080
    rmvproxy = !git config --global --unset http.proxy && git config --global --unset https.proxy
#+end_src

** Repository administration

If unable to clone Git repository due to *self-signed certificate*...

- For a one-time fix, you can use the ~env~ command to create an environment
  variable of ~GIT_SSL_NO_VERIFY=TRUE~:

  #+begin_src shell :tangle no
  env GIT_SSL_NO_VERIFY=TRUE git <command> <arguments>
  #+end_src

- If you don't want to do this all the time, you can disable Git SSL
  verification:

  #+begin_src conf :tangle no
  [http]
      sslVerify = false
  #+end_src

  Please be advised disabling SSL verification globally *might be considered
  a security risk* and should be implemented only temporary.

** Format

#+begin_src conf
[format]
    pretty = format:%C(yellow)%h%C(reset) %C(green)%ad%C(auto)%d%C(reset) %s %C(blue)<%an>%C(reset)


# https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj
[custom.formats]
    ls   = "[%C(auto,yellow)%<|(10)%h%C(reset)] [%C(auto,bold blue)%<(15trunc)%cn%C(reset)]  %C(auto)%d% C(reset)%s"
    find = "[%C(yellow)%<|(20)%h%C(reset)] [%C(bold blue)%<(10)%cn%C(reset)]  %C(auto)%d %C(reset)  %s"
    graph="%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)%n %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)"

#+end_src

See
- https://devhints.io/git-log-format and
- https://git-scm.com/docs/pretty-formats (XXX)

* Aliases

#+begin_src conf
[alias]
#+end_src

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~ to *print the current list of Git aliases*:

#+begin_src conf
    alias = "!git config -l | grep alias | cut -c 7- | sort"
#+end_src

#+begin_src conf
    # Useful for exploring git.
    type = cat-file -t
    dump = cat-file -p
#+end_src

#+begin_src conf
     catchup = !git fetch; git rebase origin/master
# For catching up those random feature branches you haven't had to touch in months.
#+end_src

(see http://gitimmersion.com/lab_11.html)

Define:

#+begin_src conf
    exec = '!exec '
#+end_src

so that you can do things like ~git exec make~.  This works because Shell aliases
are always executed in the top-level directory.

#+begin_src conf
    # Show the diff between the latest commit and the current state
    d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

    # `git di $number' shows the diff between the state `$number' revisions ago and the current state
    di = !"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull origin master"

    # Commit all changes (all local modifications/additions/deletions).
    ca = !git add -A && git commit -av
#+end_src

Clean up your commits before publishing.  Before you push your commits to the
repository, it's good to revise them.  You can run the git interactive rebase to
squash your commits or modify commit messages.  The goal is to publish only
clean and relevant commits, no experiments or fixing typos.

#+begin_src conf
    # Interactive rebase with the given number of latest commits
    ireb = "!r() { git rebase -i HEAD~$1; }; r"
#+end_src

** SHOW - Check the status of your files

Give the status in the *short-format* (preceded by a line showing the /branch name/
and /tracking info/).

#+begin_src conf
    st = status -s -b
#+end_src

In the following example:

#+begin_example
M  README
 M lisp/mail/rmail.el
MM ChangeLog
#+end_example

- =README= is changed and *staged for commit* (it's *in the index*),
- =lisp/mail/rmail.el= is changed but *not staged for commit*, and
- =Changelog= is changed and staged for commit, then *changed again* and the new
  change is *not staged for commit*.

#+begin_note
Staging for commit is typically done by ~git add~.
#+end_note

** SHOW - View your changes

*** Changes between the working tree and the index (staged for the next commit)

#+begin_src conf
    df = diff
    #+end_src

    #+begin_src conf
    wdiff = diff --word-diff
    dw = diff --word-diff
#+end_src

#+begin_src conf
    # Configure git-diff to produce the absolutely most minimal diff possible.
    wdiff = diff -w --word-diff-regex=. --color-words -U0
#+end_src

#+begin_src conf
    # Diff line-wise
    d = diff

    # Diff word-wise
    dw = diff --color-words

    # Diff character-wise
    dt = diff --word-diff-regex=.
#+end_src

*** Changes between the working tree and the latest commit (HEAD)

#+begin_src shell :tangle no
    diff-all = diff HEAD
#+end_src

*** Changes between the index (staged for the next commit) and the latest commit (HEAD)

Just before committing the *staged* changes, check what your commit changes:

#+begin_src conf
    # Review staged changes (about to be committed).
    dc = diff --cached
#+end_src

#+begin_src conf
    # Diff staged line-wise
    ds = diff --cached

    # Diff staged word-wise
    dws = diff --color-words --cached

    # Diff staged character-wise
    dts = diff --word-diff-regex=. --cached
#+end_src

*** Precommit

This is a key part of my workflow. I run this before every commit to make sure
I don't need to use the undo commands.

#+begin_src conf
    precommit = diff --cached --diff-algorithm=minimal -w
#+end_src

*** Today

Quickly see what you've done today (list commits that aren't merges, on *all
branches*):

#+begin_src conf
    today = !git log --since=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
    yesterday = !git log --since='1 day ago midnight' --until=midnight --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
    this-week = !git log --since=1.weeks --author=\"$(git config user.name)\" --no-merges --all --pretty='%C(green)%ad%C(auto) - %s' --date=format:'%Y-%m-%d %a %H:%M'
#+end_src

#+begin_src conf
    today-all = !git log --since=midnight --no-merges --all
#+end_src

#+begin_src conf
	today2 = !git log --all --since=00:00:00 --oneline --no-merges --author=${1-$(git config user.email)}
	changelog2 = !git log --oneline --no-merges ${1-$(git describe --abbrev=0)}..HEAD
	upstream = !git log --oneline --no-merges HEAD..${1-$(git branch -lvv | perl -ne '/^\\*.*\\[(.*?)\\]/ and print "$1\n"')}
	local = !git log --oneline --no-merges ${1-$(git branch -lvv | perl -ne '/^\\*.*\\[(.*?)\\]/ and print "$1\n"')}..HEAD
#+end_src

Show changes for a daily standup meeting:

#+begin_src conf
    # Summarize your own changes since 24h, suitable for a daily standup meeting.
    log-standup = !git log --since=yesterday --author=\"$(git config user.email)\" --pretty=short

    standup = !"git log --branches \
                        --since=$(if [[ "$(date +%a)" == "Mon" ]]; then \
                                      echo "friday"; \
                                  else \
                                      echo "yesterday"; \
                                  fi) \
                        --author=$(git config --get user.email) \
                        --format=format:'%C(green) %ad %C(yellow)%h %Creset %s %C(green bold)%d' \
                        --date=local"
# XXX git standup W donne un décompte avec une ligne trop peu !
#+end_src

#+begin_src conf
  # Show log of new commits after you fetched, with stats, excluding merges
  log-fresh = log ORIG_HEAD.. --stat --no-merges

  # Show the log for my own user email
  log-me = !git log --author=$(git config user.email)

  # TODO
  log-fetched = log --oneline HEAD..origin/master
#+end_src

*** Finding new commits

Diverging from ~origin/master~, whatever the branch?

#+begin_src conf
    log-local = log --oneline origin..HEAD
#+end_src

*** When

#+begin_src conf
    # When was this file last updated, on each local branch.
    wwflu = "!f() { for b in $(git rev-parse --symbolic --branches); do \
                        echo -e $(git log --format=%at:%ar -1 $b -- \"$1\")\\\\t$b; \
                    done | sort -r | cut -f2 -d:; }; f"
#+end_src

** SHOW - View the commit history

#+begin_note
The ~git log~ command shows, by default, the "author date" -- not the "committer
date".
#+end_note

#+begin_src conf
    ls = log --decorate --date=short
    ld = log --decorate --date=relative
#+end_src

List commits *showing changed files* (prettier and more concise version of
~whatchanged~):

#+begin_src conf
    ll = log --decorate --date=short --stat
#+end_src

#+begin_src conf
    ls-modified  = "!git status --porcelain -uno | awk 'match($1, /M/) {print $2}'"
    ls-added     = "!git status --porcelain -uno | awk 'match($1, /A/) {print $2}'"
    ls-deleted   = "!git status --porcelain -uno | awk 'match($1, /D/) {print $2}'"
    ls-renamed   = "!git status --porcelain -uno | awk 'match($1, /R/) {print $2}'"
    ls-copied    = "!git status --porcelain -uno | awk 'match($1, /C/) {print $2}'"
    ls-updated   = "!git status --porcelain -uno | awk 'match($1, /U/) {print $2}'"
    ls-staged    = "!git status --porcelain -uno | grep -P '^[MA]' | awk '{ print $2 }'"
#+end_src

#+begin_src conf
    ls-del  = ls-files -d
    ls-mod  = ls-files -m   # This will include deleted files also.
    ls-new  = ls-files --exclude-standard -o
    lsfiles = ls-files --exclude-per-directory=.gitignore \
                     --exclude-from=.git/info/exclude \
                     -v -d -o -m -s -u
#+end_src

#+begin_src conf
    last1 = log --decorate --date=short -1 --stat

    # Show the last N commits on the current branch.
    last2 = !git log --name-status -$1 ${*:2}
#+end_src

*** List all the changed files in a commit

*List all the ~changed~ files in a commit*:

#+begin_src conf
    changed = show --pretty="format:" --name-only
    #+end_src

*** Show the history of a file

*List of commits* that modified the *specified file* (will follow renames and
copies!):

#+begin_src conf
    file-history = log --follow --date-order --date=short -C --
#+end_src

#+begin_warning
Put a /end of options/ character (~--~) after ~file-history~ and before the path!!
#+end_warning

#+begin_src conf :tangle no
curl 'https://api.bitbucket.org/2.0/repositories/mcpflow/pflow/filehistory/master/CHANGELOG.org'
#+end_src

#+begin_src conf
    related = !sh -c 'git log --follow --format=format:%H $1 | xargs -L1 git diff-tree --no-commit-id --name-only -r | sort | uniq -c | sort -b -n -r'
#+end_src

*** Inspect the commits for each edit

: git log ... | xargs -n 1 git show

** SHOW - Show blame information about original authors of lines changed or removed

$ git blame -w  # ignores white space
$ git blame -M  # ignores moving text
$ git blame -C  # ignores moving text into other files

git blame -w README.md
The -w option ignores whitespace changes. If a previous author has modified the
spacing of a file by switching from tabs to spaces or adding new lines this,
unfortunately, obscures the output of git blame by showing these changes.

git blame -M README.md
The -M option detects moved or copied lines within in the same file. This will
report the original author of the lines instead of the last author that moved or
copied the lines.

git blame -C README.md
The -C option detects lines that were moved or copied from other files. This
will report the original author of the lines instead of the last author that
moved or copied the lines.

#+begin_src conf
    praise = blame -w
    archeology = blame -w -C -n
    whodoikill = blame -w -C -n
#+end_src

** SHOW - find all "unpushed" commits for all projects in a directory

See https://stackoverflow.com/questions/12499195/git-how-to-find-all-unpushed-commits-for-all-projects-in-a-directory

#+begin_src conf
    status-all = "!for d in $(find . -name \".git\"); do \
                     echo \"\n*** Repository: $d ***\" \
                     && git --git-dir=$d --work-tree=$d/.. status | grep -q \"is ahead of\"; \
                   done"
#+end_src

** Ignoring files

*** List untracked files

Tell if a file is being tracked:

#+begin_src conf
    # List all tracked files.
    ls-tracked = ls-files -t

    tracked1 = "!f() { tracked=$(git ls-files ${1}); if [[ -z ${tracked} ]]; then echo 'File NOT tracked (or No such file)'; else echo 'File tracked'; fi; }; f"

    tracked2 = "!f() { echo -n ${1}': '; if [[ -f ${1} ]]; then tracked=$(git ls-files ${1}); if [[ -z ${tracked} ]]; then echo 'File NOT tracked'; else echo 'File tracked'; fi; else echo 'No such file!'; fi; }; f"
# does not work!?
#+end_src

#+begin_note
~[[~ has fewer surprises and is generally safer to use. But it is not portable --
POSIX doesn't specify what it does and only some shells support it (beside bash,
I heard ksh supports it too). For example, you can do

: [[ -e $b ]]

to test whether a file exists. But with ~[~, you have to quote ~$b~, because it
splits the argument and expands things like ~"a*"~ (where ~[[~ takes it
literally). That has also to do with how ~[~ can be an external program and
receives its argument just normally like every other program (although it can
also be a builtin, but then it still has not this special handling).
#+end_note

List untracked *files ignored* by a =.gitignore= statement somewhere.

#+begin_src conf
    # List all untracked files.
    ls-untracked = ls-files --others
#+end_src

#+begin_src conf
    # this one is a MUST have
    ls-ign  = ls-files --exclude-standard -o -i
    ls-ignored = ls-files --others --ignored --exclude-standard
#+end_src

Remove ignored files that are still on the repository:

#+begin_src shell :tangle ~/.dotfiles/bin/git-delete-ignored :shebang #!/usr/bin/env bash
git ls-ignored | xargs rm
#+end_src

*** Add ignore entry to the repository

- Ignore exact filename: filename
- Ignore everything beneath: folder
- Ignore all files with this extension: pattern
- Ignore custom pattern: pattern

Quickly add a file or directory to =.gitignore=:

#+begin_src conf
    ignore = "!f() { echo \"$1\" >> \"${GIT_PREFIX}.gitignore\"; }; f"
    # ignore=!([ ! -e .gitignore ] && touch .gitignore) | echo $1 >>.gitignore
# XXX What is GIT_PREFIX?

  # Ignore all untracked files by appending them to .gitignore:
  ignore-untracked = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"
#+end_src

*Note that adding the .gitignore and the file specification will have no effect
on files that are already being tracked.* If you're already tracking these,
you'll have to stop tracking them. (Right-click on the folder or file and select
Stop Tracking.) You'll then see them change from having a green/clean or
amber/changed icon to a red/removed icon. On your next commit the files will be
removed from the repository and thereafter appear with a blue/ignored
icon. Another contributor asked why Ignore was disabled for particular files and
I believe it was because he was trying to ignore a file that was already being
tracked. You can only ignore a file that has a blue question mark icon.

*** ~assume-unchanged~ command

Ignore/unignore changes to *tracked file(s)* without =.gitignore=:

#+begin_src conf
    skip = update-index --assume-unchanged
    unskip = update-index --no-assume-unchanged
#+end_src

XXX Have a look at Git lock = skip-worktree

It has to be configured for each project member individually.

#+begin_warning
As stated in [[http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged][git ignore vs. exclude vs. assume-unchanged]],
~git-update-index --assume-unchanged~ was never meant to ignore changes to tracked
files (*only to spare some stats*).  So do not suggest it as a means to achieve
that.
#+end_warning

Skip all:

#+begin_src conf
    skip-all = "!git status -s | awk {'print $2'} | xargs git skip"
#+end_src

Unskip all the skipped files:

#+begin_src conf
    unskip-all = "!git skipped | xargs git update-index --no-assume-unchanged"
#+end_src

List ignored files (*marked unchanged*):

#+begin_src conf
    skipped = "!git ls-files -v | grep '^h' | cut -c 3-"
    # skipped = '!git ls-files -v | grep ^[a-z]'
#+end_src

** REVERT - Undo things

> The reason I don't commit a change immediately after I write it is
> that I want to test it in real (and varied) use.  Sometimes I find
> bugs and have to change it.  After some period in which it works well,
> I decide it is ready to install.

That is a good reason. However, for your information there is the variant ~git
commit --amend~, which as the option suggests amends the *current* commit. Just
~git add~ the files you changed and run ~git commit --amend~. It also lets you edit
the commit message. After discovering this option, I find I am less fearful of
making premature commits, since they are easily fixed. (But not after pushing,
of course. That way lies madness.)

*** Change your last commit

This will help when we need to change the most recent commit.

#+begin_warning
~git commit --amend~ is a dangerous operation.  Someone might forget that the
current commit has already been pushed, and amend it anyway.  What will they do
then?

Try to push the result, see a message about non-fast-forward pushes being not
allowed, then go along the "If pushing fails" section (pull, resolve, commit,
push), and we'll have two similar commits in the history.
#+end_warning

#+begin_verse
The key to understanding that is that Git does not rewrite history, it creates
new history and calls that reality.  The commits in this history have different
IDs (because the ID is the content plus the ID of its parent, changing just one
commit means everything after it must change).  If you push this new history
(with --force) everyone else will have the old divergent history.  All their
work will be on top of this divergent history.  They have to do the surgery to
put their work on your new history.

When users do a "git pull", git doesn't store that you did a rebase (it would be
nice if it did) so it assumes something has gone wrong and refuses to pull.  Git
gets a human to look at the divergence and decide what to do with it.
Unfortunately, most people don't know what to do with a divergent repository.

And yes, this applies to amended commits.

This is a common question answered on Stack Overflow.
https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase

This answer isn't specifically about rebase, but it illustrates how Git creates
new history.
https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938
#+end_verse

Modify the *last* commit, amending with the same message -- without your editor
prompting you for the message you've already entered!

#+begin_src conf
    # Commit changes to current HEAD (modified and deleted files) as amended
    # commit.
    plus = commit -a -v --amend --reuse-message HEAD

    # Append staged changes to the PREVIOUS commit (changes its SHA, keeps the
    # commit message).
    fix = commit -v --amend --reuse-message HEAD

    # Change PREVIOUS commit's message to what you type in.
    medit = commit --amend -m

    # Credit an author on the PREVIOUS commit.
    credit = "!f() { git commit --amend --author=\"$1 <$2>\" --reuse-message HEAD; }; f"
#+end_src

Note that the ~-a~ switch which tells Git to automatically *stage all your changes*,
as if you ran ~git add .~ (stage all local modifications/additions) right before
the commit.

#+begin_warning
*NEVER AMEND a commit* that you've *ALREADY PUSHED* to a remote repository.
https://stackoverflow.com/questions/17176859/amending-a-pushed-commit-message
#+end_warning

Solution for *amending older commits*:
https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit
(see 1st and 2nd answers!)

My new favorite alias is fixup --amend. Lets you amend to a specific commit, *not*
need to be the *latest* one.

#+begin_src conf
    fixup = "!f() { TARGET=$(git rev-parse \"$1\"); \
                    git commit --fixup=$TARGET ${@:2} \
                        && GIT_EDITOR=true git rebase --interactive --autostash --autosquash $TARGET^; }; f"
    # See https://blog.filippo.io/git-fixup-amending-an-older-commit/
#+end_src

For aliases and shell/git configuration, a few pearls:

github.com/zsh-users/antigen
with oh-my-zsh/git and others according to your tastes. (love gloga)

grml.org/zsh/

github.com/zsh-users/zsh-autosugge...

github.com/iam4x/zsh-iterm-touchbar

--rebase by default on git pull is comfortable too.

And obviously for those that didn't know it:
learngitbranching.js.org/

*** Undo changes to one (or more) file(s) in a commit -- instead of reverting the entire commit

: git show commit-hash -- path/to/file.html | git apply --reverse

*** Throw away a commit

http://www.vogella.com/tutorials/Git/article.html#resetcommits
http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
http://git-scm.com/2011/07/11/reset.html

~git reset~ is a simple way to undo changes that haven't been shared with anyone
else.

See « Undo 'git add' before commit ».

**** Soft option -- Do not touch the index file or the working tree at all

Go back before last commit, with files in uncommitted state:

#+begin_src conf
    undo-soft = reset --soft HEAD~1
    uncommit = reset --soft HEAD~1
#+end_src

~uncommit~ *undoes the last commit*, and *puts the changes* in the commit *into your
index* -- keeping changes in the working directory (it doesn't touch it).  It's
like going back in time to the moment right before you committed.

#+begin_note
~uncommit~ here means to do just the reverse of commit, i.e. just like commit it
shouldn't touch the files's contents, only the metadata.
#+end_note

This is a useful technique in resuming work on an unfinished changeset.

Other scenario: squash change in several commits into one commit so that people
think you are smart.

**** Mixed option -- Do not touch the working tree (but regenerate the index)

Reset the previous commit, but *puts* all *the changes* from that commit *in the
working directory*:

#+begin_src conf
    undo-mixed = reset --mixed HEAD~1
    uncommit-unstage = reset --mixed HEAD~1
#+end_src

#+begin_note
~--mixed~ with paths is deprecated; use ~git reset -- <paths>~ instead.
#+end_note

This is a useful technique if your pull fails to merge the new stuff from
upstream: ~git reset HEAD~1~, pull again, fix the conflicts, then commit your
changes again.

Other scenario: slice a single big commit to different small commits to haste
review process.

**** Hard option -- Regenerate both the index and working tree

Remove the last commit, *delete changes in your staging area and in your working
directory*:

#+begin_src conf
    # Erase any changes since your last commit (reset every file in your working
    # directory to its committed state).
    undo = reset --hard HEAD~1
    # Delete last commit.
#+end_src

If you reset work that you /never committed/, it is gone for good.  Too bad!  This
is quite a dangerous command (~git reset --hard~ is one of the few Git commands
which deletes information with no backout), and must be used with *EXTREME
CAUTION*.

#+begin_warning
This command will *overwrite all CHANGED tracked files* in the working tree!
(/Untracked files/ are out of scope.)
#+end_warning

#+begin_tip
If you have changes in your working directory or staging area, you'll probably
want to stash them before doing the above.
#+end_tip

#+begin_note
See the functionality of the partly overlapping ~git checkout .~ command (note
that it will only erase all your unstaged changes: the *files in your staging
index will be untouched*), by comparing [[https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout][git reset and git checkout]].
#+end_note

Use ~git reset --hard @{u}~ to make sure the integration branch is up-to-date
before merging.

Other scenarios:
- Overtime working, did lots of stupid things.  You want to run away from what
  had been done...
- Recover context before a stale merge.

**** Soft option -- Clean branch (clean the untracked files)

~git clean~ will *remove any files* from the tracked root directory *that are not
under Git tracking* (whereas ~git reset --hard~ will /not remove untracked files/).

#+begin_note
*WARNING -- BE CAREFUL WITH THIS!*  It is helpful to run a dry-run with ~git clean~
first, to see what it will delete.
#+end_note

Usage:
- ~git clean -n~ (dry run) to see what ~git clean -f~ will do, so you can be sure
  it's what you want.
- ~git clean -f~ (to *remove* the *untracked files*) and
- ~git clean -d -f~ (to also *remove untracked directories* in addition to untracked
  files).

#+begin_src conf
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED.
    # Files and directories in .gitignore will be preserved.
    clear-soft = !git clean -d -f && git reset --hard
    # Discard current changes and throw out new files.
#+end_src

which:
- unstages changes in the index,
- discards changes in the working directory, and
- removes any new files (*all untracked changes will be lost*).

If you want to save your current branch's state before doing this (just in
case), you can do:

#+begin_src shell :tangle no
git commit -a -m "Saving my work, just in case"
git branch my-saved-work
#+end_src

**** Hard option -- Clean branch (clean the ignored files in addition to the untracked files)

*NUCLEAR VERSION* which will wipe out all your changes, all the files not in Git,
and start from the ~HEAD~.

#+begin_src conf
    # THIS COMMAND MAY DELETE FILES THAT CANNOT BE RECOVERED,
    # including those in .gitignore.
    clear = git clean -d -f -x && git reset --hard
#+end_src

*** Revert a commit

Once you've pushed changes to a remote repository, it is considered dangerous to
modify the history because someone else may have already pulled it.

However, Git offers you an easy way to undo a patch by committing a change that
effectively reverses the patch in question. The simplest usage is to revert an
entire commit:

#+begin_src shell :tangle no
git revert [hash]
#+end_src

This creates a patch that is the opposite of commit ~[hash]~ and commits it to
your repository.

If you want to revert that commit without committing it (putting the reversion
into your index), use:

#+begin_src shell :tangle no
git revert -n [hash]
#+end_src

*** Squash

Squash commits:
https://bitbucket.org/blog/git-squash-commits-merging-bitbucket

#+begin_src conf
    squash = "!f() { git reset --soft HEAD~${1} && \
                     git commit --edit -m\"$(git log --format=%B --reverse HEAD..HEAD@{1})\"; }; f"
#+end_src

Now it is possible to use this command to *combine together the last N commits*
into one commit:

: git squash N

** Merge

#+begin_src conf
  # Given a merge commit, find the span of commits that exist(ed).
  # Not so useful in itself, but used by other aliases.
  # Thanks to Rob Miller for the merge-span-* aliaes.
  merge-span = !"f() { echo $(git log -1 $2 --merges --pretty=format:%P | cut -d' ' -f1)$1$(git log -1 $2 --merges --pretty=format:%P | cut -d' ' -f2); }; f"

  # Find the commits that were introduced by a merge
  merge-span-log = "!git log `git merge-span .. $1`"

  # Show the changes that were introduced by a merge
  merge-span-diff = !"git diff `git merge-span ... $1`"

  # Show the changes that were introduced by a merge, in your difftool
  merge-span-difftool = !"git difftool `git merge-span ... $1`"
#+end_src

** UPDATE - Pull

Starting with Git 1.7.0, ~@{u}~ is shorthand for the *current* branch's *upstream*
branch; e.g., ~origin/foo~ (or ~github/foo~, etc., since the remote doesn't have to
be called ~origin~) if the checked out branch is ~foo~.

#+begin_src conf
    r = remote -v
    remotes = remote -v
#+end_src

#+begin_note
~git pull~ is simply ~git fetch && git merge remote~.  Its ~--rebase~ option uses
~rebase~ instead of ~merge~.

That's exactly why some decide to avoid ~rebase~ (but to ~pull~ instead), because it
has bad effects if one merges from another branch and then wants to push.
#+end_note

About rebase (with visual aid):
https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395

The ~in~ command returns a list of *incoming* commits for the *current branch* --
after a ~git fetch~, to fetch down *all the data* it has for the *current remote* that
you do not --, the next time you do a merge.

#+begin_src conf
    in = !(echo "Please fetch origin before." && git log --decorate ..@{u})
    inf = !(git remote update -p              && git log --decorate ..@{u})
#+end_src

#+begin_src conf
    in-stat = log --stat ..@{u}
#+end_src

Show the changes between the last local commit and the *remote* branch:

Show a *single diffstat* (number of added and deleted lines for *all changed
files*):

#+begin_src conf
    in-what = diff --stat ...@{u}

    du = diff @{u} HEAD
    # diff with upstream branch
#+end_src

#+begin_warning
The upstream diff ~in-what~ will show the negative of unpushed (rebased) commits,
if any, with the ~..~ notation --- not with the ~...~ notation!
#+end_warning

*** Update with local modifications

#+begin_src conf
    pull = pull -v
#+end_src

#+begin_note
~git pull~ with uncommitted changes can succeed if the newly pulled changes don't
touch the locally changed files, but will fail otherwise.  Which makes a lot of
sense.
#+end_note

Git's fix is to ask you to commit (or stash) before you pull (which is fetch
followed by merge).

#+begin_src conf
    # up = "!git stash && git pull && git stash pop"
#+end_src

#+begin_warning
The above approach is *unsafe*: if there's nothing to stash, the first command
will do nothing, and then ~stash pop~ will unstash some random stuff from before.
#+end_warning

#+begin_src conf
    pull-autostash = ![[ -z $(git status --porcelain -uno) ]] && git pull || git stash push -m "autostash" && git pull && git stash pop
# XXX Does not work in WSL (unexpected operator [[)
#+end_src

XXX What about ~git stash push --include-untracked~ and ~git stash pop~?

#+begin_src conf
    up = pull --rebase --autostash
    up = !git fetch && git rebase --autostash FETCH_HEAD
    up= "!git fetch origin && git branch -v -a"
#+end_src

See https://www.praqma.com/stories/git-autostash/.

: git rebase -i --autosquash --autostash

Really handy in projects that don't do merge commits.

See [[http://aanandprasad.com/git-up/][git-up]] (no longer maintained), which is (roughly) equivalent of executing the following:

#+begin_src shell :tangle no
git stash
git fetch --all
[foreach branch]
    git rebase --rebase-merges <branch> <remote>/<branch>
    git merge --ff-only <branch>
[end foreach]
git checkout <prev_branch>
git stash pop
#+end_src

#+begin_warning
Use with care: the final stash application after a successful rebase might
result in non-trivial conflicts.
#+end_warning

With *all versions* of Git, I recommend using ~git up~ instead of ~git pull~.

#+begin_src conf
    up-tmpname = "!f() { git remote update -p; git merge --ff-only @{u}; }; f"
#+end_src

It is pretty safe: it will abort the merge if it can't be done using
fast-forward.  (In other words, if the local branch has diverged from the
remote.)

See https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful

~remote update -p~ *fetches* all refs from all remotes, instead of just the needed
one; ~merge~ then merges the appropriate *single branch*.

#+begin_src conf
    # Rebasing non-linear changes (when the fast-forward merge is not possible).
    upr = "!f() { git remote update -p; git rebase -p @{u}; }; f"
#+end_src

#+begin_src conf
# cleanpull
# update (like svn? if we add a git reset in front?)
# sync
#+end_src

... but read "you're not using git as it was intended" on
https://news.ycombinator.com/item?id=2301765.

Before doing work (in a new branch), *ensure that the working directory is*
*up-to-date* with the ~origin~ (pull and get latest for all submodules):

#+begin_src conf
    # Get everything new.
    update = !git pull                     && git submodule update --init --recursive
    get    = !git pull --rebase            && git submodule update --init --recursive
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive
#+end_src

[[https://gist.github.com/gitaarik/8735255][Git Submodules basic explanation]]

*** Update all local branches

Pull all:

#+begin_src conf
  # Do a push/pull for just one branch
  push1 = "!git push origin $(git branch-name)"
  pull1 = "!git pull origin $(git branch-name)"

    pull-all = !"old=$(git current-branch); \
                 for b in $(git for-each-ref refs/heads --format='%(refname)'); do \
                     git checkout ${b#refs/heads/}; \
                     git pull --ff-only; \
                 done; \
                 git checkout ${old}"
#+end_src

See http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches
(+ interesting comments about *rebase vs merge during a pull*!)

#+begin_src shell :tangle ~/.dotfiles/bin/git-up-all :shebang #!/usr/bin/env bash
REMOTES="$@";
if [ -z "$REMOTES" ]; then
    REMOTES=$(git remote);
fi
REMOTES=$(echo "$REMOTES" | xargs -n 1 echo)

CLB=$(git branch -l | awk '/^\*/{print $2}');

echo "$REMOTES" | while read REMOTE; do
    git remote update --prune $REMOTE
    echo
    git remote show $REMOTE -n \
        | awk '/merges with remote/ {print $5" "$1}' \
        | while read line; do
              RB=$(echo "$line" | cut -f1 -d" ");
              ARB="refs/remotes/$REMOTE/$RB";
              LB=$(echo "$line" | cut -f2 -d" ");
              ALB="refs/heads/$LB";
              NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2> /dev/null) + 0));
              NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2> /dev/null) + 0));
              if [ "$NBEHIND" -gt 0 ]; then
                  if [ "$NAHEAD" -gt 0 ]; then
                      echo -e "[$LB \tis $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB.]  Not possible to fast-forward, aborting.";
                  elif [ "$LB" = "$CLB" ]; then
                      echo -e "[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Fast-forwarding merge...]";
                      # git merge --quiet $ARB;
                      git merge --ff-only --verbose $ARB;
                  else
                      echo -e "[$LB \tis $NBEHIND commit(s) behind of $REMOTE/$RB.  Resetting local branch to remote...]";
                      # git branch -l -f $LB -t $ARB > /dev/null;
                      git branch -l -f $LB -t $ARB;
                  fi
              else
                  echo -e "$LB \tAlready up to date.";
              fi
              echo
          done
done
#+end_src

XXX Is this ~sync~?

*** Get timestamp of last pull

#+begin_src conf
    # For the latest pull (even if there's nothing new).
    last-pulled = !stat -c %y $(git root)/.git/FETCH_HEAD | cut -d'.' -f1

    # For the latest pull resulting in changes coming in from the remote master
    # branch (the timestamp won't change when git pull reports there are no
    # changes).
    last-updated = !stat -c %y $(git root)/.git/refs/heads/$(git current-branch) | cut -d'.' -f1
#+end_src

** UPDATE - Merge

Merging means to *bring the contents of another branch* (possibly from an external
repository) *into the current branch*. [...]  Merging is performed by an automatic
process that identifies changes made since the branches diverged, and then
applies all those changes together.

: Merge branch 'branch_name' into master

#+begin_src conf
    # Will only try to "merge" if your current HEAD commit is in the branch
    # you're merging in.  This will allow you to merge some commits whilst being
    # sure you won't get conflicts.
    mff = merge --ff-only
    mff = merge --ff-only @{u}

    # Avoid a fast-forward commit.
    mnf = merge --no-ff

    cvsmerge = merge --no-ff --log
#+end_src

*** Merge master

#+begin_src conf
    # Merge remote master into the current branch.
    mm = !git fetch -p && git merge origin/master
#+end_src

*** Undo the merge

If you tried a merge which resulted in complex conflicts and want to start over,
you can recover with ~git merge --abort~.  It will allow you to *undo the merge*,
even if it is a fast-forward merge.

*** Merge current branch into another one

On projects where we work with a staging or test branch, I regularly merge my
work in progress into it so others can test it.

#+begin_src conf
    m = "!f() { OLD=$(git current-branch); \
                git co \"$1\" && git pu && git merge $OLD && git p && git co $OLD; }; f"
#+end_src

If you now type ~git m staging~ while on the ~feature~ branch, this will happen:

- First, the function checks out the ~staging~ branch.
- It then pulls the latest changes to the ~staging~ branch from origin.
- Then it merges ~feature~ into ~staging~.
- Next, it pushes the updated ~staging~ branch back to origin.
- Finally, it checks out the ~feature~ branch again.

Such a timesaver!

*** Dry run (do not make changes)

Naive (but slow) way:

#+begin_src shell :tangle no
rm -Rf /tmp/repository
cp -r repository /tmp/
cd /tmp/repository
git merge ...
# ... If successful, do the real merge.
#+end_src

#+begin_warning
It won't work just cloning to =/tmp=; you need a *copy* in order *to be sure that
uncommitted changes will not conflict*.
#+end_warning

Performing a Git merge with *no commit* and *no fast-forward* will merge the two
code bases together -- it will *modify your working copy*.  This will allow you to
examine, test, and undo the merge if required.

#+begin_src shell :tangle no
git merge --no-commit --no-ff $BRANCH
#+end_src

You can do ~git merge --abort~ after seeing that there are conflicts.

#+begin_src conf
    # Run merge test (before merge) to check for any conflicts beforehand.
    mergetest = "!f() { git merge --no-commit --no-ff \"$1\"; git merge --abort; echo \"Merge aborted\"; }; f"
#+end_src

#+begin_warning
If your repository is a live Web server, then you could be serving files with
conflicts in.  That's why you should *never* be *handling merges on a live Web
server*!  Fix up the ~prod~ branch (on your development box) and then push it to
the real webserver with ~git pull --ff-only~.
#+end_warning

See if the merge is applicable to the current working tree and/or the index file
and *detects conflicts*:

#+begin_src conf
    # Check how the merge of `dev' into master will go: git merge-dry-run dev.
    merge-dry-run = "!f() { grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) && echo 'Merge conflicts!' || echo 'No merge conflicts'; }; f"
# DOESN'T work for git fetch & git merge

    # Extract the "changed in both" lines as well as the conflicting parts.
    merge-dry-run-conflicts = "!f() { git merge-tree $(git merge-base $1 $2) $1 $2 | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' | cdiff; }; f"
#+end_src

*** Branch/Integration manager

Often, during a *merge*, you know you want to take a file from one side wholesale;
that is, to select the entirety of either our or their file.

Pick a file(s) from:

- the *current branch*

#+begin_src conf
    ours   = "!f() { git checkout --ours   $@ && git add $@; }; f"
#+end_src

- the *branch being merged in*

#+begin_src conf
    theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
#+end_src

#+begin_warning
During a *rebase*, the commits being merged into the current branch /are/ the
commits from your original feature branch.  So ~--ours~ and ~--theirs~ will appear
to be *flipped* around.
#+end_warning

#+begin_note
Using ~git checkout~ with ~--ours~ or ~--theirs~ expects at least one argument: the
*path(s)* of the *files / directories* to checkout.  If you use ~git checkout~ without
any files, then it takes the meaning of /switching branches/.
#+end_note

*Best (and safest) way to merge* a Git local branch into =master=:

#+begin_src shell :tangle no
git checkout master
git pull origin master                  # Get the latest changes from the remote.
git merge test
git push origin master

git branch -d local_branch_name         # Delete local branch.
#+end_src

#+begin_warning
*Update first the branch (to merge in) of the RIGHT LOCAL CLONE.* -- if you do
have many clones on your file system.
#+end_warning

Best answer I have seen on ~git merge~ *strategies*:
https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies

*** List conflicted files

Unmerged files after a merge failure:

#+begin_src conf
    conflicts = "!git ls-files -u | cut -f 2 | sort -u"
#+end_src

*** Review which file have conflicts

This command tells you which files have conflicts after merging.

#+begin_src conf
    conflicts = diff --name-only --diff-filter=U
    unmerged = diff --name-only --diff-filter=U
#+end_src

** BRANCH - Branch

*** Feature Branches

#+begin_src conf
    # Create a feature branch.
    feature = "!f() { git create-branch feature/$1 develop; }; f"
    # XXX or feature-start?

    # Incorporate a finished feature on develop.
    feature-finish = "!f() { git checkout develop; \
                             git merge --no-ff feature/$1 \
                             && git delete-local-branch feature/$1; }; f"

    # XXX Also bug and refactor.

    # XXX release-start
    # XXX release-finish
#+end_src

https://medium.com/gumgum-tech/git-and-git-flow-a-guide-871d46a0ebcb

Alias configuration for our feature branches, like a simple git flow for feature
stories, or hotfix patches, etc.

Create a new feature branch:

: feature-start = '!branch=$1; git checkout master; git pull; git create-branch "$branch" master'

Update the feature branch:

: feature-pull = '!branch=$(git current-branch); git checkout master; git pull; git checkout "$branch"; git rebase master'

Share the feature branch:

: feature-push = '!branch=$(git current-branch); git push -u origin "$branch"'

If your team uses a different feature flow, you may want to skip including these
aliases, or you may want to edit these aliases to match your team's feature flow.

*** Git workflows

It may be helpful to do a some background reading on workflows with Git.  Here
is the gitworkflows man page:
https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html

Other doc on branching models:

http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html
http://williamdurand.fr/2012/01/17/my-git-branching-model/

*** General

See http://nuclearsquid.com/writings/git-tricks-tips-workflows/ for more
interesting stuff, such as:

- When branching off a remote branch, automatically let the local branch track
  the remote branch.

- When pushing without giving a refspec, push the current branch to its upstream
  branch. See the git config man page for more possible options.

#+begin_src conf
    # Shortcut for checkout.
    co = checkout
#+end_src

Check out the next commit in the commit history -- quite useful for demos to
jump across commits:

#+begin_src conf
    next = "!f() { git checkout $(git rev-list --topo-order HEAD..master | tail -1; }; f"
#+end_src

*** If you get the error "The following untracked working tree files would be overwritten by checkout"

#+begin_src text :tangle no
error: Your local changes to the following files would be overwritten by checkout:
        WEB-INF/config/afm-projects.xml.DEV-fni
        WEB-INF/config/context/logging/logging.xml
Please commit your changes or stash them before you switch branches.
error: The following untracked working tree files would be overwritten by checkout:
        WEB-INF/config/afm-projects.xml
Please move or remove them before you switch branches.
#+end_src

One solution is to *move the untracked files*, instead of *deleting them*.  For
example:

#+begin_src shell :tangle no
cd "$(git root)"
git checkout $BRANCH 2>&1 | while read f; do [ ! -e "$f" ] || mv -v "$f" "$f.bak"; done
#+end_src

Another is to throw away local changes using a *forced checkout*:

: git checkout -f some-branch

*** GitHub Pages

#+begin_src conf :tangle no
echo 'setting up gh-pages'
echo '-------------------'

echo 'Tell me your github account username: '
read username

echo 'Now, tell me your repository name: '
read repository

git stash \
&& git create-branch 'gh-pages' \
&& echo 'My Page' > index.html \
&& git add . \
&& git commit -a -m 'Initial commit' \
&& git remote add origin https://github.com/"$username"/"$repository".git \
&& git push -u origin gh-pages \
&& echo 'Complete' \
&& echo '-------------------' \
&& echo 'You can find your last changes in the stash!'
#+end_src

*** Show the history difference between a local branch and its remote

#+begin_src conf
    divergence = log --left-right --graph --cherry-pick --oneline $1...origin/$1
#+end_src

    # Quickly solve conflicts using an editor and then add the conflicted files
    edit-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; vim $(f)"
    add-unmerged = "!f() { git diff --name-status --diff-filter=U | cut -f2 ; }; git add $(f)"

*** Diff all changes since branching from master

Show all commits in a git branch since original branching point from =master=:

#+begin_src conf
    # log since master.
    missing-master = log master...

    # diff since master.
    missing-master-diff = diff master...
#+end_src

*** Delta

*** Branch point

https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git:

#+begin_src conf
    oldest-ancestor = !zsh -c 'diff --old-line-format='' --new-line-format='' <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | head -1' -
    branch-log  = !sh -c 'git log $(git oldest-ancestor)..'
    branch-diff = !sh -c 'git diff $(git oldest-ancestor)..'

    diverges = !sh -c 'git rev-list --boundary "${1:-HEAD}"..."${2:-master}" | grep "^-" | cut -c2-'
#+end_src

When you use three dots (...), ~git diff~ finds the merge-base between the left
and right side commit SHAs (as obtained from the names, or defaulting to =HEAD=)
and substitutes that in for the left-side SHA. The right-side SHA (as resolved
from the name) remains intact.

*** Rename branch

Sometimes we name a branch poorly or maybe we thought the name was "good" but
not meaningful to the work we are doing.

To rename the branch locally:

#+begin_src conf
    rename-branch = branch -m
#+end_src

One thing to keep in mind is that this command works in two different ways:

- If we are on the branch we want to rename, we can just
  ~git rename-branch <new-name>~.

- If we are not on the branch, we have to use
  ~git rename-branch <target-branch> <new-name>~.

*** List branches that contain a given commit ID (SHA)

Filter the list of *branches* to only those which have the given *commit ID* among
their ancestors.

#+begin_src conf
    where = "branch -a --contains"

    # Find branches containing commit.
    findb = "!f() { git branch -a --contains $1; }; f"
#+end_src

This also includes *remote tracking branches* in the list, that is "local
branches that have a direct relationship to a remote branch".

List all *tags* that contain a commit ID:

#+begin_src shell :tangle no
git tag --contains a2c71a6
#+end_src

#+begin_src conf
    # Find tags containing commit.
    findt = "!f() { git describe --always --contains $1; }; f"
#+end_src

*** Comparing the commits between branches

Sometimes I lose track of which branch contains which other branch. This
shortcut (an idea borrowed from Bazaar) shows the unique revisions in the
current branch and the specified branch.

#+begin_src conf
missing = "!f() { git rev-list ..$1 --oneline | sed -e '1 iOnly in other:'; git rev-list $1.. --oneline | sed -e '1 iOnly in HEAD:'; }; f"
#+end_src

*** See which changes from a branch are already present upstream

While on =feature= branch:

#+begin_src shell :tangle no
git cherry -v master
#+end_src

#+begin_example
+ 497034f2 Listener.new now accepts a hash of options
- 2d0333ff Cache the absolute images path for growl messages
+ e4406858 Rename Listener#run to #start
#+end_example

The ~cherry~ command is useful to see which commits have been cherry-picked from
a development branch to the stable branch, for instance. This command compares
changes on the current (=feature=) branch to upstream (=master=) and indicates which
are present on both with the ~-~ sign. Changes still missing from upstream are
marked with ~+~.

*** Recover a branch after its deletion in Git

Most of the time unreachable commits are in the reflog. So, the *first thing to
try is to look at the reflog* using the command ~git reflog~ (which display the
reflog for =HEAD=).

1. Perhaps something easier if the commit was part of a specific branch still
   existing is to use the command ~git reflog name-of-my-branch~ to *find the SHA*
   for the commit at the tip of your deleted branch -- It works also with
   a remote, for example if you forced push.  Otherwise, use ~git reflog~.
2. Then, you can just ~git create-branch <branch> <sha1>~ to recreate the branch
   from there.

See https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git

*** Show branches and their commits

#+begin_src conf
    # "show-branch -g=N" can't be aliased for N easily, so we stop here:
    sb  = show-branch
    # pg sbt master pu -- if the last line is 'master' and not 'master^'
    # or 'master~N' then pu is a descendent of master
    sbt = show-branch --topics
    sbs = show-branch --sha1-name
#+end_src

** Stash

A *stash* is nothing but a *(temporary) branch*.

~git stash~ makes a temporary copy of the changes in your *index* (staging area) and
*working tree*, and clears the decks so you can easily work on something else; it
reverts your local modifications, allowing you to get rid of some incomplete
changes.

#+begin_tip
Use ~git stash~ if Git refused to merge because it foresees conflicts.
#+end_tip

If you anticipate that you might have trouble merging the work you want to stash
with the work you're about to do on the clean tree, you can create a new branch
with ~git stash branch <new branchname>~.

Information that is used by default if you don't provide a message:

#+begin_example
stash@{0}: WIP on <branch>: <sha1 of head> <title line of head>
#+end_example

You can operate on the "stash" ref as if it were any other ref.

*** Stash push

~git stash push~ also optionally takes a message describing the contents of the
stash (much, much more useful):

#+begin_src conf :tangle no
git stash push -m "DESCRIBE WHAT YOU DID HERE"
#+end_src

#+begin_example
stash@{0}: On <branch>: DESCRIBE WHAT YOU DID HERE
#+end_example

This command is useful in saving all changes not ready to be committed and the
user wants to have an updated repository.

#+begin_src conf
    spush = stash push
#+end_src

#+begin_src conf
    sshow = "!f() { git stash show stash^{/$@} -p; }; f" # Like sapply but shows it only

    sapply = "!f() { git stash apply stash^{/$@}; }; f" # Find stash with name like text

    spop = "!f() { git stash pop stash@{$(git stash-id $@)}; }; f" # Like sapply but pops it off

    stash-id = "!f() { git stash list | grep $@ | head -n 1 | sed -n 's/stash@{\\(.*\\)}.*/\\1/p'; }; f" # only accepts single word, no quotations
#+end_src

#+begin_src conf
    hide = stash push --include-untracked # Hide all files, including untracked files (faster than using --all).
#+end_src

*** Take named stash

"WIP:"

#+begin_src conf
    snapshot = !git stash push -m "snapshot-$(date +%Y%m%d_%H%M)" \
                    && git stash apply "stash@{0}"
#+end_src

#+begin_src conf
    # checkpoint
    cp = !git stash push -m "$(date +%F--%T)" && git stash pop --index

    # checkpoint recover
    cpr = "!f() { git fsck | grep commit | cut -d' ' -f3 | \
                  while read hash; do \
                      git rev-parse --verify --no-revs --quiet $hash^2 2>/dev/null && echo $hash | xargs git rev-list --since=${1:-1day} -1; \
                  done | xargs -L 1 git log --format=%at:%h -1 | sort | cut -f2 -d: | xargs -L 1 git log --graph --oneline --format='%Cblue%h %Cgreen(%ar) %Creset%s' -3; }; f"
#+end_src

*** Show a list of all stashes

#+begin_src conf
    stashes = stash list --date=local
#+end_src

*** Show the stash

#+begin_src conf
    stash-diff = stash show -p
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    sshow = "!f() { git stash show stash^{/$*} -p; }; f"
#+end_src

One very useful feature one may consider is to list contents of all local
stashes:

#+begin_src shell :tangle no
git stashes | awk -F: '{ print "\n\n\n\n"; print $0; print "\n\n"; system("git stash show -p " $1); }'
#+end_src

Press [Q] to exit each stash.

It helped me a lot in the past (cleaning stashes stack).

*** Show name-only

#+begin_src conf
    sshno = stash show --name-only
#+end_src

*** Apply the stash only, don't delete it from the stash list

When you're done, with ~git stash apply~ (top stash by default), you're back where
you were.  But if that doesn't work, for whatever reason, you can use any of
Git's other branch merging tools to put things back they way you want them.

#+begin_src conf
    sa = stash apply
#+end_src

https://stackoverflow.com/questions/11269256/how-to-name-and-retrieve-a-stash-by-name-in-git:

#+begin_src conf
    sapply = "!f() { git stash apply stash^{/$*}; }; f"
#+end_src

#+begin_src conf
    stash-unapply = !git stash show -p --no-textconv --binary | git apply -R
#+end_src

*** Stash pop

~git stash pop~ removes the most recent stash or any stash specified and applies
changes as a merge.  If merge fails, the stash is not removed from the list and
must be removed manually.

#+begin_src conf
    sp = stash pop
#+end_src

#+begin_warning
Be aware that, unlike ~git stash apply~ (though it has its use), ~git stash pop~
*deletes the applied stash* -- /only/ if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!
#+end_warning

*** Drop the stash

#+begin_src conf
    std = stash drop
#+end_src

*** Clear

#+begin_src shell :tangle no
git stash clear
#+end_src

*** Workflows

Alternative to ~stash~ (writing a commit with a default message):

XXX See doc of git help stash for workflows...

1. Do a regular ~commit~:

   #+begin_src shell :tangle no
   git add -A && git commit -m 'WIP'       # Add all changes (including untracked files).
   #+end_src

2. Do some other work...

3. Return to previous work:

   #+begin_src shell :tangle no
   git reset --mixed                       # Reset the previous commit (but
                                           # keeps all the changes from that
                                           # commit in the working directory).

   git reset --soft                        # Or this one???
   #+end_src

   Or, if I merely need to modify the *previous* commit:

   #+begin_src shell :tangle no
   git commit -a --amend
   #+end_src

   The ~-a~ adds any modifications and deletions of existing files to the commit
   but ignores brand new files.

   The ~--amend~ launches your default commit editor and lets you change the
   commit message of the *most recent* commit.

*** From git help stash

       Pulling into a dirty tree

           When you are in the middle of something, you learn that there are
           upstream changes that are possibly relevant to what you are
           doing. When your local changes do not conflict with the changes in
           the upstream, a simple git pull will let you move forward.

           However, there are cases in which your local changes do conflict with
           the upstream changes, and git pull refuses to overwrite your
           changes. In such a case, you can stash your changes away, perform
           a pull, and then unstash, like this:

               $ git pull
                ...
               file foobar not up to date, cannot merge.
               $ git stash
               $ git pull
               $ git stash pop

       Interrupted workflow

           When you are in the middle of something, your boss comes in and
           demands that you fix something immediately. Traditionally, you would
           make a commit to a temporary branch to store your changes away, and
           return to your original branch to make the emergency fix, like this:

               # ... hack hack hack ...
               $ git create-branch my_wip
               $ git commit -a -m "WIP"
               $ git checkout master
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git checkout my_wip
               $ git reset --soft HEAD^
               # ... continue hacking ...

           You can use git stash to simplify the above, like this:

               # ... hack hack hack ...
               $ git stash
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git stash pop
               # ... continue hacking ...

       Testing partial commits

           You can use git stash push --keep-index when you want to make two or
           more commits out of the changes in the work tree, and you want to
           test each change before committing:

               # ... hack hack hack ...
               $ git add --patch foo            # add just first part to the index
               $ git stash push --keep-index    # save all other changes to the stash
               $ edit/build/test first part
               $ git commit -m 'First part'     # commit fully tested change
               $ git stash pop                  # prepare to work on all other changes
               # ... repeat above five steps until one commit remains ...
               $ edit/build/test remaining parts
               $ git commit foo -m 'Remaining parts'

       Recovering stashes that were cleared/dropped erroneously

           If you mistakenly drop or clear stashes, they cannot be recovered
           through the normal safety mechanisms. However, you can try the
           following incantation to get a list of stashes that are still in your
           repository, but not reachable any more:

               git fsck --unreachable |
               grep commit | cut -d\  -f3 |
               xargs git log --merges --no-walk --grep=WIP

** PUBLISH - Push

It is useful to know if you have any *local commits* that are not in the remote
branch.

#+begin_note
It is a good idea to examine what you are about to push, before actually doing
so, because fixing mistakes before pushing is much easier. To do that, use the
command "git diff origin/master". If you want to show your unpushed commits with
their commit log messages, use "git show origin/master.." instead. If you only
have one local commit you want to push, just "git show" is enough.

> It is not clear to me how these two differ.  Does "git show origin/master.."
> output everything that "git diff origin/master" outputs, plus log messages?

Yes, that's the only real difference between them, when you have no uncommitted
changes.  (When you do have uncommitted changes, "git diff" will include them,
while "git show" will not.)
#+end_note

The ~out~ command returns a list of *unpushed* (outgoing) commits for the *current
branch*, the next time you do a push.

#+begin_src conf
    out = log --date=short @{u}..
    out-stat = log --stat --date=short @{u}..
#+end_src

This causes ~git log~ to show all commits reachable from =HEAD= excluding those
reachable from the upstream branch.  The ~@{u}..~ argument is equivalent to
~@{u}..HEAD~, where =HEAD= stands for the last commit in your local branch, but =HEAD=
can be omitted for shorthand purposes.

If you want to see all *unpushed* commits from *all branches*, do this:

#+begin_src conf
    outgoing = log --branches --not --remotes --decorate
#+end_src

*** Upload your changes

#+begin_src conf
    # Get the upstream branch name.
    upstream-name = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)
#+end_src

** PUBLISH - Find out if a change is part of a release

#+begin_src conf
    sha1-tag = '!f() { git name-rev --name-only "$@"; }; f'
#+end_src

The ~name-rev~ command indicates the *position of a commit relative to tags* in the
project. For example, ~v2.3~5~ means that this commit is located 5 commits *before*
the v2.3 tag -- we can be certain that this change is part of v2.3, then.

** Create patches

#+begin_src conf
    lll = log -u
#+end_src

*** Creating a patch

1. Make your changes and commit them.

2. Run

   : git format-patch COMMIT_REFERENCE

   to convert all commits since the referenced commit (not including it) into
   patch files.

   For example:

   : git format-patch HEAD~

*** Using the patch

: git am *.patch

Error while applying a patch

: git am--ignore-whitespace 0001-my-awesome-change.patch

When ~git apply~ is working normally, you get no output at all:

: git apply 0001-my-awesome-change.patch

[nothing returned]

If you want to see what's going on behind the scenes, you can use the ~-v~
(verbose) flag:

: git apply -v 0001-my-awesome-change.patch

Use ~patch -p1 < filename.patch~. Whereas ~git-apply~ altogether rejects a patch
with any errors, ~patch -p1~ works hunk by hunk, applying as many individual
changes as it can. It backs up each file as =filename.ext.orig= before modifying
it and saves rejected hunks in =filename.ext.rej=. Discard the =.orig= files and
manually apply the changes left in the =.rej=. This is an easy strategy for small
patches.

*Applying Patches* with different line endings error on Cygwin:

: patch -t -N -r - -p1 -i 0001-my-awesome-change.patch

*** Apply patches from URL

#+begin_src conf
    # Apply a patch to files and/or to the index from URL.
    apply-url = "!f() { curl -s $1 2>nul | git apply ${@:2}; }; f"
#+end_src

: git apply-url http://example.org/sample.patch args

#+begin_src conf
    # Apply a series of patches from an URL.
    am-url = "!f() { curl -s $1 2>nul | git am ${@:2}; }; f"
#+end_src

: git am-url http://example.org/sample.patch args

*** Apply a patch interactively

#+begin_src conf
    # Interactive apply patch.
    ipatch = "!f() { git apply $1; git add -p; }; f"
#+end_src

: git ipatch mypatchfile

*** Patch shortcuts

#+begin_src conf :tangle no
# Copy a patch URL to the clipboard, then run one of these commands to download
# the patch and apply it. Hat tip to @chrisjlee for making me reconsider curl.

# Apply
alias cap='curl $(pbpaste) | git apply -v'

# Apply and stage
alias cape='curl $(pbpaste) | git apply -v --index'

# Apply with `patch'
alias capp='curl $(pbpaste) | patch -p1'

# Reverse apply
alias carp='curl $(pbpaste) | git apply -Rv'

# Reverse apply and stage
alias carpe='curl $(pbpaste) | git apply -Rv --index'

# Verify patch
alias cav='curl $(pbpaste) | git apply -v --check'

# Verify patch with `patch'
alias capv='curl $(pbpaste) | patch -p1 --dry-run'
#+end_src

** PUBLISH - Prepare a release

Save a repo as a tarball:

#+begin_src conf
    export = archive -o latest.tar.gz -9 --prefix=latest/
#+end_src

#+begin_src conf
    # Best common ancestor (when it was branched off).
    mbase = !git show --summary $(git merge-base origin/$1 $(git current-branch))
#+end_src

*** ChangeLog

Generate the ChangeLog (for your [[https://keepachangelog.com/][CHANGELOG.md]]) with all commit message since the
last tag.

#+begin_src conf
    # Detailed list of changes.
    changelog = !sh -c 'git log --no-merges --pretty=format:\"* %s\" $(git last-tag)...' -
    changelog-org = !sh -c 'git log --no-merges --pretty=format:\"- %s\" $(git last-tag)...' -
#+end_src

XXX git log --pretty=format:"- %s" 2019.10.10...HEAD displays too many entries on mcpflow repo

Use it like this:

#+begin_src shell :tangle no
git changelog <first-tag-name> <last-tag-name>
#+end_src

See also https://github.com/github-changelog-generator/github-changelog-generator.

*** Release assets

Generate =zip= archived source code from the given Git tag.

I usfe this when zipping the current branch with the name of the zip file as the
current tag.  Useful for uploading to Elasticbeanstalk.

#+begin_src conf
    current-tag = tag --points-at HEAD
    zip = "!f() { git archive --format=zip -o $(git current-tag).zip HEAD; }; f"
#+end_src

#+begin_src conf
    export-branch = !git format-patch --stdout $1 > ~/$(git current-branch).diff
#+end_src

#+begin_src conf
    export-commit = "!f() { git changed ${1:-HEAD} | xargs zip -9 $(git repo-slug)-commit-${1:-HEAD}.zip; }; f"
#+end_src

** PUBLISH - Tag

When tagging releases in a version control system, the tag for a version should
be ~X.Y.Z~ (*without* prefix ~v~).  The advantages of ~X.Y.Z~ are that gitweb or GitHub
can automatically offer a tarball or zip download of the form
=packagename-$tag.tar.gz= (and it's quite established that a tarball should be
named =package-X.Y.Z.tar.gz=).

Savoir quels sont les commits de ma branche courante depuis le dernier tag, afin
de savoir ce qu'embarquera la « prochaine release » de mon projet.

#+begin_src conf
    # le dernier tag, ainsi que la liste des commits ayant eu lieu depuis sur la
    # branche courante.
    unreleased = !git log --oneline $(git last-tag)...HEAD && git last-tag
#+end_src

You can do a lot better with:

#+begin_src conf
    releases = log --decorate --no-merges --all --simplify-by-decoration --oneline --graph
    # XXX Add date

    show-tree = log --decorate --all --simplify-by-decoration --oneline --date=short --graph
#+end_src

** Debugging

Sometimes it's nice to see what is going on under the hood. Try this alias:

#+begin_src conf
    debug = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"
#+end_src

Just insert ~debug~ between ~git~ and whatever would usually follow; for example:

#+begin_src shell :tangle no
git debug changed
#+end_src

** Abbreviations

Basic shortcuts.

#+begin_src conf
    cp = cherry-pick -x
    pick = cherry-pick -s

    # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
    cp = cherry-pick

    # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
    cp-nx = cherry-pick --no-commit -x
#+end_src

This command has some useful parameters:
- -e to edit git message
- -x to add a line "Cherry-picked commit" in the commit message
- --no-commit or -n to apply the commit changes in the unstaged area (unstead of
  creating a commit in the branch)

#+begin_src conf
    h = help
#+end_src

** Show the path to root directory of Git repo

#+begin_src conf :tangle no
    # Get the path cleaned up.
    root = !pwd -P
#+end_src

#+begin_note
This works because Shell aliases are always executed in the top-level directory.
#+end_note

#+begin_src conf
    root = rev-parse --show-toplevel
    root-relative = rev-parse --show-prefix
#+end_src

** Sync

Fetch Git objects from upstream and update local branches.

- If the local branch is outdated, fast-forward it;
- If the local branch contains unpushed work, warn about it;
- If the branch seems merged and its upstream branch was deleted, delete it.

#+begin_src conf
    # Pull then push current branch.
    sync = !git pull && git push
#+end_src

#+begin_src conf
    sync = !git update && git co master && git pull && git commit @{-1}
#+end_src

That's rather basic -- it doesn't actually rebase my branch that I'm on.

Let's do a slightly different command: ~resync~

#+begin_src conf
    # git resync -> sync repository and rebase current branch.
    resync = !sh -c 'git checkout master && git fetch && git reset --hard origin/master && git rebase master'
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
    record = !sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit, it
will ~reset~ the index.

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
    lost = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA: %C(yellow)%h%C(reset)  %s' --stdin | awk '/SHA/ {sub(\"SHA: \", \"\"); print}'"
    lost = !"git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset %f' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

** TODO To sort out

#+begin_src conf
    logdate = log --format=format:'%ad %d %h %s %an%n' --date=short
    branch-date = !"sh -c 'for branch in $(git branch --no-merged); do \
                               git logdate -1 -r $branch --; \
                           done'"
#+end_src

** Git and Subversion

#+begin_src conf :tangle no
    spull = svn rebase
    spush = svn dcommit
    slog = svn log --oneline --show-commit
#+end_src

#+begin_src conf :tangle no
    cvs-full-log = log --reverse --pretty=format:'%B------------------------------------------------------------------------'
#+end_src

* All repositories

The biggest use I get out of this alias is making sure I have everything
committed. Sometimes I'll work on a project and then forget about it for
a little while without committing. When I want to double-check that I'm not
forgetting anything, I run ~git all status --short~ to quickly scan which repos
have uncommitted changes that I need to take care of.

#+begin_src conf
    all = "!find . -type d -name .git -prune -execdir pwd ';' -execdir git $@ ';' #"
#+end_src

* ------------------------------------------------------------------------------

* Repository

** Create a repository locally

#+begin_src conf
    create-repository = !git init \
                             && ( [[ -n $(ls) ]] || touch .gitignore ) \
                             && git add . \
                             && git commit -m \"Initial commit\"
#+end_src

** Clone a repository

Clone an existing repository including all submodules.

#+begin_src conf
    cl = clone --recursive
#+end_src

#+begin_tip
For *passwordless Git pull* (permanently authenticating with Git repositories),
*use SSH* when cloning, and *add* your *public key* to the remote server.
#+end_tip

** Create and add your SSH public key to a repository management platform

https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html

It is best practice to use Git over SSH (instead of Git over HTTP).  In order to
use SSH, you will need to:

*** Create an SSH key pair on your local computer

Generate a new ED25519 (should always be favored) SSH key pair:

: ssh-keygen -t ed25519 -C "email@example.com"

Or, if you want to use RSA:

: ssh-keygen -t rsa -b 4096 -C "email@example.com"

*** Add the key to the repository management platform

*** Testing that everything is set up correctly

** Create a repository in GitHub

#+begin_src conf :tangle no
    create-repository-gh = "!f() { username=$1; repo_slug=$2; \
        curl -u \"$1\" \
            https://api.github.com/user/repos -d \"{\"name\":\"$2\"}\"; }; f"
#+end_src

#+begin_src conf
    username = "XXX"
    repo-slug = "!f() { git remote show origin -n \
                            | grep 'Fetch URL:' \
                            | sed -E 's#^.*/(.*)$#\\1#' \
                            | sed 's#.git$##'; }; f"
#+end_src

#+begin_tip
The ~sed~ strings contain ~$#~, which will be replaced by the number of arguments to
the current script/function (generally 0 for an interactive shell).  This is
part of the basic Bourne shell syntax, so *single quotes* will be needed under any
*Bourne-like shell* (even pre-POSIX ones) on any OS.  Read the standard for more
information:
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html.
#+end_tip

* Source Files

** Search for files

Search file (by file path) in the current branch.

#+begin_src conf
    # BUG This is case-sensitive...
    find-file = !git ls-tree -r --name-only $(git current-branch) | grep --color=auto
#+end_src

Search file in all branches.

#+begin_src conf
    find-file-all = "!f() { for branch in $(git for-each-ref --format=\"%(refname)\" refs/heads); do \
                            echo \"${branch}:\"; \
                                git ls-tree -r --name-only $branch | nl -bn -w3 | grep --color=auto \"$1\"; \
                            done; }; f"
#+end_src

** Search for code

*Code search* looks through all lines of code of all the files (by *file contents*)
from the working directory (and its subdirectories).

https://confluence.atlassian.com/bitbucketserver/search-for-code-in-bitbucket-server-814204781.html

#+begin_src conf
    search-code = "grep -i --line-number --break --heading -C 1"
# XXX Is it really case-insensitive?

# ack = '-c color.grep.linenumber="bold yellow"
#     -c color.grep.filename="bold green"
#     -c color.grep.match="reverse yellow"
#     grep --break --heading --line-number'
#+end_src

Find all instances of the specified string in code files *with a certain file
extension*.

#+begin_src conf
    search-code-extension = "XXX"
#+end_src

Find all instances of the specified string in code *in the specified path*.

#+begin_src conf
    search-code-path = "XXX"
#+end_src

*** Pattern in working directory (and its subdirectories)

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- files registered in the index, rather than the working tree,
- for your regexp in some files from another branch (XXX does not work? XXX).

#+begin_note
It doesn't search files that are not revisioned (untracked, excluded/ignored,
etc.).
#+end_note

Example:

#+begin_src shell :tangle no
git grep "foo" -- '*.java'
#+end_src

More readable output, *with grouping* (like Ripgrep, ~rg~, or ~ack~):

#+begin_src conf
# In all commits, not in all branches!!! Lots of duplicates!!!
grep-all = "!f() { git rev-list --all | xargs git grep $1; }; f"
#+end_src

Broader search (*case-sensitive*), output *without grouping*:

#+begin_src conf
    # `-I' = Don't match the pattern in binary files.
    g = "grep -I"

    # Name only.
    gno = "grep -I --files-with-matches"
#+end_src

*** Find files that contain some terms, not necessarily on the same line

Match any of these patterns, but print matches only from files that have /all/ of
them (files must have lines that match each of them):

#+begin_src shell :tangle no
git grep --all-match -e <regexp> -e <regexp>
#+end_src

** Undo local changes

See https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/
and http://gitimmersion.com/lab_14.html.

**** Before you staged (in unstaged state)

*Undo* the local changes *in the working directory*: roll a file back to its last
committed version, removing all the changes detected by Git.

#+begin_tip
It can also recover *deleted files* -- if the deletion has not been committed.
#+end_tip

#+begin_src conf
    unmodify = checkout --
    undelete = checkout --
#+end_src

#+begin_note
The two dashes there (canonically called the "bare double dashes") ensure that
the checkout command know that we are trying to roll back a file and not /change
branches/ (the typical usage of the checkout command).
#+end_note

When you grab a file from a previous time, it sits *in your index*, modified.

**** Before you committed (in staged state)

*Remove* the specified *files from the index* (proposed next commit, staging area):

#+begin_src conf
    unstage = reset HEAD --
    unadd = reset HEAD --
#+end_src

~unstage~ is the opposite of ~git add~.  It lets you remove items from the staging
area.  This makes it a very useful tool when you're deciding which files to
stage for a commit.  If you've accidentally added something to the staging area,
just use ~unstage~ to remove it.

* Commits

** Create a commit

#+begin_src conf
    # Shortcut for commit.
    ci = commit
#+end_src

A useful template for good commit messages (see
https://medium.com/compass-true-north/writing-good-commit-messages-fc33af9d6321):

Implementing a Strong Code-Review Culture
https://www.youtube.com/watch?v=PJjmw9TRB7s

#+begin_src text :tangle ~/.git_commit_template.txt
## 50-character subject line #####################
# If applied, this commit will...
# [Add / Fix / Remove / Update / Refactor / Document] [issue #id] [summary]

# :new: Add ...
# :bug: Fix ...
# :x: Remove ...
# :hammer: Update ...
# :recycle: Refactor ...
# :computer: Tool ...

## 72-character wrapped longer description #############################
# This should answer:
# - Why is this change necessary?  (goals, use cases, stories, etc.?)
# - How does this change address the issue?  (implementations, algorithms, etc.?)
# - What side effects does this change have?

# Include a link to the ticket, if any.
# close #ISSUE_NUMBER
#+end_src

# https://www.webfx.com/tools/emoji-cheat-sheet/

# https://help.github.com/en/github/managing-your-work-on-github/closing-issues-using-keywords
# https://confluence.atlassian.com/bitbucket/resolve-issues-automatically-when-users-push-code-221451126.html
# https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#default-closing-pattern

and you'll be guided into writing concise commit subjects in the imperative
mood -- a good practice. See rule 5 of Chris Beam's "How to write a commit
message" for the inspiration of this tip and more reasoning on the use of the
imperative mood.

#+begin_src conf
[commit]
    template = ~/.git_commit_template.txt

[alias]
#+end_src

** Get a commit detail

** Get the diff for a commit

** Get the references the commit has been pushed to (branches and tags)

** Search for commits

#+begin_note
Just for the record -- searching anything "in a branch" is not possible due to
the principle of branches.  Branch is only a pointer to a single commit, which
is considered to be "the last commit of the branch", and commits itself do not
"belong to a branch" anyhow else.

Therefore, Git cannot determine "which branch was which" before merge commits.
#+end_note

: curl --request GET --header "PRIVATE-TOKEN: <your_access_token>" https://gitlab.example.com/api/v4/search?scope=commits&search=bye
: curl --request GET --header "PRIVATE-TOKEN: <your_access_token>" https://gitlab.example.com/api/v4/groups/3/search?scope=issues&search=file

*** Search within Commit Messages

You can find commits that contain particular words in the commit message. For
example, ~fix typo~ matches commits containing the words ~fix~ *and* ~typo~.

If you want to find all commits (*across all branches*, showing names and status
of changed files) where *log message* matches a specified pattern (regular
expression), use ~find~.

#+begin_src conf
    findc1 = "log --decorate -i --all --date=short --grep"
    findc2 = "!f() { git log --decorate --grep=$1 -i --all --date=short; }; f"
#+end_src

#+begin_tip
If you only add options to one single ~git~ command, there is no benefit to the
function wrapper.  On the contrary, you can't add other options.
#+end_tip

#+begin_src conf
    # Search for commits (Filter by commit message).
    search-commits = "!f() { str=\"git log --all-match\"; \
                             for var in \"$@\"; do \
                                 str=\"$str --grep '$var'\"; \
                             done; \
                             eval $str; }; f"
#+end_src

#+begin_src conf :tangle no
curl -H "Accept: application/vnd.github.cloak-preview" \
    https://api.github.com/search/commits\?q\=repo:fniessen/org-html-themes+local+css \
    | jq '.items[] | {commit}'
#+end_src

Here's the alias which simply loops over each argument and calls ~git
log --grep~. Equivalent of calling ~git log --grep <a> --grep <b> --grep <c> ...~:

#+begin_src conf
    search = "!f() { for l in \"$@\"; do git log --grep \"$l\"; done; }; f"
# XXX Add i, all, date short...
#+end_src



You may want to add history to search through the whole repository, by adding
rev-list to your git log:

#+begin_src conf
    search2 = "!f() { git log --grep \"$1\" $(git rev-list --all); }; f"
#+end_src

Add ~--name-status~ to show only names and status of *changed files*.

To find commits that match *either* of patterns (implicit *OR* semantic), you can
use:

#+begin_src shell :tangle no
git log --grep=<foo> --grep=<bar>
#+end_src

To find /commit/ that has *both* line matching first and line matching second
somewhere, use the *AND* semantic:

#+begin_src shell :tangle no
git log --all-match --grep=<foo> --grep=<bar>
#+end_src

Show the *last commit* whose *message matches a regexp*:

#+begin_src shell :tangle no
# Show the LATEST commit which has the text "fix: font" in its message.
git log :/"fix: font"
git show :/"fix: font"

# Show the LATEST merge commit.
git show :/^Merge
#+end_src

*** Search by Author

#+begin_src conf
    search-author = "log --decorate -i --all --date=short --author"
    recap = !git log --all --oneline --no-merges --author=${1-$(git config user.email)}
#+end_src

*** Search on File Changes

**** Search string (added/removed) in code

If you want to find all commits where a *string* was *added or removed* in the /file
contents/ (to be more exact: where its *number of occurrences changed* in the
source file), i.e. search the /commit contents/, use ~-S~.

You can dig up commits that have, for example,
- removed calls to a specific function, or
- added a certain CSS classname.

#+begin_warning
If the number of times "foo" appears in the file is the same before and after
a commit, it will not match using ~-S "foo"~.
#+end_warning

In other words, to find the following commit:

#+begin_src diff :tangle no
@@ -4211,9 +4211,10 @@ public class MovesHandler extends EventHandlerBase {
      */

     private boolean actionsNotCompleted(final EventHandlerContext context, final String mo_id) {
         final Object found_mo_id =
                 selectDbValue(context, "activity_log", "activity_log_id", "mo_id=" + mo_id
-                    + " AND status NOT IN ('COMPLETED-V','REJECTED','CANCELLED')");
+                    + " AND status NOT IN ('COMPLETED-V','CLOSED','REJECTED','CANCELLED')");
         return (found_mo_id != null);
     }
#+end_src

you *need to search on 'CLOSED'*.  Searching on 'COMPLETED-V' would not bring back
that commit!

#+begin_src shell :tangle no
git log --all -S "foo" --since="1 week ago"
#+end_src

#+begin_src conf
    whatwhen = log --decorate --date=short -p -S
#+end_src

Prettier ~whatchanged~ with full diffs based on text search:

#+begin_src conf
    # Find commits by source code.
    search-commits-contents = "!f() { git log --decorate --date=short -S $1; }; f"
# XXX Does not work for strings with spaces in them...
#+end_src

#+begin_src conf
    grep4d = !sh -c 'git log -p -S'$1' $2' -
# Not the best example, but: git grep4d CLOSED '*.java'
#+end_src

By default, ~-S~ accepts a string, but can be modified to accept a *regexp* with
~--pickaxe-regex~.

**** Search regexp (added/removed/changed?) in code

String contained in added/removed lines from Commit contents (Diff)

With the ~-G~ option, the commit is shown in the log if your *regexp* search matches
any *line* that was added, removed, or changed.

#+begin_src shell :tangle no
git log --all -G "foo" --since="1 week ago"
git log --all -G "foo" --full-history --since="1 week ago"
#+end_src

** Push

** Undo changes

See https://docs.gitlab.com/ee/topics/git/numerous_undo_possibilities_in_git/
and http://gitimmersion.com/lab_16.html.

*** Undo local changes which were not pushed to remote repository (after you committed)

*** Undo changes after they are pushed to remote repository

**** Without history modification (preferred way)

**** With history modification (requires coordination with team and force pushes)

* Branches

** Branching model

Consistent *naming conventions* (from the [[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow][Gitflow]] Git workflow):

- =master= (used for *production releases*)

  It should be the most stable branch. Merges commits from develop, release and
  hotfix branches.

- =develop= (used as integration branch for *"next release" development*)

  It has the newest features and fixes. Merges commits from feature and bugfix
  branches.

- prefix =feature/MSW-709-add-support-for-webm= (for new *features*, such as Jira
  *stories*)

  These branches are short lived as they only exist while a specific feature is
  being developed. Usually does not merge any commits unto it, unless there is
  another feature derived from it.

- prefix =bugfix/= (typically used to fix Release branches, such as Jira *bugs*)

  Used to fix bugs found that either exist in develop but have not made it into
  production, or that do exist in production but can wait until the next
  release. These branches merge into develop.

- prefix =release/2018-12-24= (used for preparing and testing *release* tasks)

- prefix =hotfix/fix-123-for-production= (used to *urgently fix* bugs on *production*,
  that have high impact)

  Used to fix pressing issues that are found in production. Hotfix branches
  merge directly to master.

Alternative: https://about.gitlab.com/blog/2014/09/29/gitlab-flow/

** Create a branch

Create a new branch, and then switch to it:

#+begin_src conf
    create-branch = checkout -b
#+end_src

#+begin_note
To create a branch from a specific commit:

: git create-branch test_branch 7e09ef09

Otherwise you're in a "detached head" state, which can have odd results.
The branch method is at least a little more stable.
#+end_note

#+begin_note
I usually branch off from the commit before the offending
commit and stay there until things are resolved (unless I'm able to
resolve it myself).

Or I branch off =master= and revert the offending commit until things are
resolved, ie. like so
 git checkout master
 git create-branch sb-master
 git revert sha1-of-offending-commit
#+end_note

** Publish a branch

Push the ~<current-branch>~ branch to the =origin= remote and set up tracking:

#+begin_src conf
    # Push current branch to remote server (create a copy of the current branch
    # on the remote "origin", and set it to track the upstream branch).
    publish = !git push -u origin $(git current-branch)

    # Delete current branch on remote server.
    unpublish = !git push origin :$(git current-branch)
#+end_src

#+begin_src conf
    # Get the current branch name (not so useful in itself, but used in other
    # aliases).  Works well in detached mode.
    current-branch = name-rev --name-only HEAD
    # current-branch = !git branch --show-current # v2.22+
#+end_src

Then:
1. [[id:a7039f6e-825c-484c-8739-f3e32a9c45fc][Create a pull request]].
2. Your team lead will review the code & merge it to the main branch.

** List branches

*** Show all branches

*List all branches* (both local remote-tracking and local branches), showing SHA
and commit subject line for each head, along with the name of the upstream
branch (if any).

(Sort by Last updated)

: git for-each-ref --format="%(refname:short) %(upstream:track)" refs/heads

fco="!f() { git branch -a -vv --color=always --format='%(refname)' | sed "s_refs/heads/__" | sed "s_refs/remotes/__" | fzf --query="$@" --height=40% --ansi --tac --color=16 --border | awk '{print $1}' | xargs git co; }; f"
(fuzzy checkout a git branch)

#+begin_src conf
    # Show local and remote branches.
    br = branch -a -vv
#+end_src

#+begin_src conf
    be = branch --edit-description
#+end_src

#+begin_src conf
    track = for-each-ref --format='%(refname:short) <- %(upstream:short)' refs/heads
#+end_src

#+begin_src conf
    # Show info for branches which have been checked out locally...
    branches = !git for-each-ref \
                    --sort=-committerdate refs/heads/ \
                    --format='%(HEAD) %(color:green bold)%(refname:short)%(color:reset) - %(color:yellow)%(objectname:short)%(color:reset) %(color:red bold)%(upstream:track)%(color:reset) %(contents:subject) %(color:blue)<%(authorname)>%(color:reset) (%(color:green)%(committerdate:relative)%(color:reset))'
#+end_src

#+begin_src conf
    # Sort by date for branches; can be useful for spring cleaning
    refs-by-date = for-each-ref --sort=-committerdate --format='%(committerdate:short) %(refname:short)'
#+end_src

*** Show my branches

*** Show active branches

*** Show merged branches

List branches whose tips are reachable from the specified commit (HEAD if not
specified).

#+begin_src conf
    branches-merged = "!f() { git branch --merged | grep -v '\\*'; }; f"
#+end_src

*** Show stale branches

"Stale branches" are Git branches *without commits* for the last few months.  This
generally indicates old, unmaintained branches for unreleased, incomplete
features.

For Github, such period of inactivity is *3 months* (see
https://help.github.com/articles/viewing-branches-in-your-repository/).

** [#A] Switch

Checkout [[http://nvie.com/posts/a-successful-git-branching-model/][*common branches*]] (useful if you have feature branches):

#+begin_src conf
    master = checkout master
    develop = checkout develop
#+end_src

** Delete a branch

*** Delete a local branch

Delete a *local* branch:

#+begin_src conf
    # Politely ask Git to delete a local branch.
    delete-local-branch = branch -d
#+end_src

#+begin_note
The ~-d~ (~--delete~) option only deletes the branch if it has already been fully
merged in its upstream branch.

You could also use ~-D~, which is an alias for ~--delete --force~, which deletes the
branch "irrespective of its merged status."
#+end_note

*** Delete the merged branches

~delete-merged-branches~ *removes* (in bulk) *all* the *local branches* that have been
*merged to the current branch* that you are in.

#+begin_src conf
    # Clean up.
    delete-merged-branches = "!f() { git branch --no-color --merged | grep -v '\\*' | \
                                     egrep -v \"(master|develop)\" | \
                                     xargs -n 1 git delete-local-branch; }; f"

    # # https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
    # sweep = '!git branch --merged $([[ $1 != "-f" ]] && git rev-parse master) | \
    #           egrep -v "(^\*|^\s*(master|develop)$)" | \
    #           xargs git branch -d'
#+end_src

#+begin_tip
In the event that you accidentally delete ~master~, get it back with:

: git create-branch master origin/master
#+end_tip

See http://haacked.com/archive/2014/07/28/github-flow-aliases/.

#+begin_src conf
    delete-merged-remote-branches = "XXX"
#+end_src

- https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
- https://github.com/arc90/git-sweep

*** Delete remote branch

Delete a *remote* branch:

#+begin_src conf
    # Delete remote branch.
    delete-remote-branch = push origin --delete
#+end_src

*** Delete all old local branches

Once you delete the branch from the remote, you can *remove all stale
remote-tracking branches that you have locally*, but are *no more present in the
remote repository* (~origin~) with:

: git remote prune origin

#+begin_src conf
    # Prune all your stale remote branches: there's no way to tell git remote
    # update to prune stale branches, and git remote prune does not
    # understand --all.
    prune-all = !git remote | xargs -n 1 git remote prune
#+end_src

#+begin_tip
Use the ~--dry-run~ flag to only see what branches will be pruned, but not
actually prune them:

: git remote prune origin --dry-run
#+end_tip

#+begin_tip
If you want this to be run automatically every time you fetch/pull:

: git config --global fetch.prune true
#+end_tip

or prune individual remote tracking branches with:

: git branch -dr branchname

*Remove stale branches in your local repository* that *no longer exist in the
remote* one (by deleting the local ones that show they are "gone" in ~git
branch -vv~):

#+begin_src conf
    prune-local-branches = "!f() { git branch -vv | grep ': gone]' | \
                                   awk '{print $1}' | \
                                   xargs git delete-local-branch; }; f"
#+end_src

* Tags

Tags give the ability to *mark a specific commit* in your repository history as
being important.

** Create a tag

While Git supports annotated and lightweight tags, you can only *create*
- *annotated tags* in /Bitbucket/ and in /GitLab/, and
- *lightweight tags* via /GitHub/ interface (for releases).

*Annotated tags* are *regular objects* in the repository, which means they have an
author, a date, a message, and can be referred because they have their own SHA
key.

*Lightweight tags* are just pointers to specific commits.  They *don't include any
further information*.

If knowing *who* tagged *what* and *when* is relevant for you, then use annotated
tags. If you *just want to tag a specific point in your development*, no matter
who and when did that, then lightweight tags are good enough.

#+begin_note
Annotated tags are meant for *release* while lightweight tags are meant for
private or temporary object labels.
#+end_note

Create an annotated tag:

#+begin_src shell :tangle no
git tag -a <tag-name> -m '<tag-message>'
#+end_src

Create a lightweight tag (/no message!/):

#+begin_src shell :tangle no
git tag <tag-name>
#+end_src

** See the commits for a tag

See the list of all the commits for that tag.

#+begin_src shell :tangle no
git ls <tag>
#+end_src

** Push a tag to your repository

Push all your tags (a regular push won't push a tag):

#+begin_src shell :tangle no
git push --tags                         # Only tags.
git push --tags origin master           # Code and tags.
#+end_src

** List the repository tags

List tags using (better) version sorting (not going from =v0.1= to =v0.10=):

#+begin_src conf
    # Show verbose output about tags.
    tags = !git tag -l --sort=v:refname -n1
#+end_src

#+begin_src shell :tangle no
# Show annotated and lightweight tags.
git show-ref -d --tags       |
cut -b 42-                   | # Remove the commit-id.
sort                         |
sed 's/\^{}//'               | # Remove ^{} markings.
uniq -c                      | # Count identical lines.
sed 's/2\ refs\/tags\// a /' | # 2 identicals = annotated.
sed 's/1\ refs\/tags\//lw /'
#+end_src

Show the last tag /in the current branch/:

#+begin_src conf
    last-tag = describe --tags --abbrev=0
#+end_src

Show latest annotated tag /in all branches/:

#+begin_src conf
    last-tagged = !git describe --tags $(git rev-list --tags --max-count=1)
#+end_src

** Rename a tag

#+begin_src conf
    # Rename a tag (locally and remotely).
    rename-tag = "!f() { git tag $2 $1; \
                         git tag -d $1; \
                         git push origin $2; \
                         git push origin :refs/tags/$1; \
                       }; f"
#+end_src

** Remove a tag from a repository

Delete similar tags:

: git delete-tag 'v0.8.*'

#+begin_src conf
    # Delete local and remote tags.
    delete-tag = "!f() { [ -z ${1} ] \
                         && echo \"No tags given as an argument!\" \
                         || (git tag -l ${1} | \
                             xargs -I % echo \"git tag -d % \
                                            && git push --delete origin %\" | \
                             sh); \
                       }; f"
#+end_src

* Compare Revisions (commits, branches or tags)

*See what's changed*: easily determine which commits are on the "compare" source
but not on the "base" destination.

You can see:
- a list of commits,
- a diff, and
- any pull requests merged between the two versions.

See + in Bitbucket (Get to work)

** Commits

: git log --pretty=oneline DST...SRC

** Files changed

List all the changed files *between 2 commits*:

: git log --stat DST...SRC
: git diff --stat DST...SRC
: git diff --stat v1...v2

See the changed files in a branch *since it was forked from another branch*:

: git diff --stat forked_from_branch...my_forked_branch

See the changed files in a branch since the last merge with the origin branch:

: git diff --stat origin/master...my_forked_branch

#+begin_src conf
    # Show the names of all files changed between two commits.  Usage: "git diffn SHAv1 SHAv2".
    diffn = diff --name-only

    # diff status: A git diff, but with only the filenames (which reminds me of git status)
    diffst = diff --name-only
#+end_src

(See ~git what~ as well!)
(Use Tig?  Use git blame?)

XXX They don't show the same files (test with ~git changed HEAD~1~ and ~git diffn HEAD~1~) XXX

#+begin_src shell :tangle no
git changed                             # List files modified in last commit.
git changed bada55                      # List files modified in this commit.
git changed bada55..ff0021              # List files modified between those commits.
#+end_src

** Diff

- Inline diff (unified)

  #+begin_src conf
    # git compare-revisions SOURCE TARGET = git diff TARGET...SOURCE
    # Example: git compare-revisions master v1.0.0
    compare-revisions = "!f() { git diff $2...$1; }; f"
  #+end_src

- Side-by-side diff (split)

** Merged pull requests

* ?Releases

You can create a release to package software, along with release notes and links
to binary files, for other people to use.

Releases are based on *Git tags*: tags are used to mark *release* versions, with the
*version number* as the *tag name*.

We recommend naming tags that fit within [[https://semver.org/][semantic versioning]], i.e. having the
form ~v<major>.<minor>.<patch>~:
- *Major* release (from ~v0.8.1~ to ~v1.0.0~) for bug fixes and new features that
  break backwards compatibility,
- *Minor* release (from ~v0.8.1~ to ~v0.9.0~) for bug fixes and new features that
  maintain backwards compatibility, and
- *Patch* release (from ~v0.8.1~ to ~v0.8.2~) only for bug fixes.

#+begin_note
It's common practice to prefix your version names with the letter ~v~.
#+end_note

Tag and push changes to the repository:

#+begin_src conf
    release = "!f() { git tag -a v$1 -m \"Release version $1\" \
                   && git push origin --tags \
                   && git push origin; }; f"
#+end_src

Remove Git from current project:

#+begin_src conf :tangle no
find . -name '.git' -exec rm -rf {} \;
#+end_src

* ?Contributors

** Show a "top contributors" list

Show a "top contributors" list (rank), excluding merge commits:

#+begin_src conf
    contributors = shortlog -n -s -e --no-merges --
    whorank = shortlog --summary --numbered --no-merges
#+end_src

#+begin_note
The ~--~ signals the /end of options/, that the rest of the parameters are limiters.
#+end_note

* ?Graph

See example at https://gitlab.com/procps-ng/procps/-/network/master

To see real *timeline* of who is working on what and when:

#+begin_src conf
    graph = log --graph -25 --branches --remotes --tags --format=format:'%C(yellow)%h %C(reset) %<(75,trunc)%s <%cn> (%cr) %C(red)%d' --date-order

    # Show log as a graph
    log-graph = log --graph --all --oneline --decorate
#+end_src

#+begin_src conf
    hist = log --date=short --graph
#+end_src

Directed Acyclic Graph:

  # Use graphviz for display.
  # This produces output that can be displayed using dotty, for example:
  #   $ git graphviz HEAD~100..HEAD~60 | dotty /dev/stdin
  #   $ git graphviz --first-parent master | dotty /dev/stdin

#+begin_src conf
    graphviz = "!f() { echo 'digraph git {' ; \
                           git log --pretty='format:  %h -> { %p }' \"$@\" \
                               | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; \
                       echo '}'; }; f"
#+end_src

* Pull requests

XXX See https://github.com/github/hub/

** Create a pull request
:PROPERTIES:
:ID:       a7039f6e-825c-484c-8739-f3e32a9c45fc
:END:

Create pull request against the default branch:

#+begin_src conf
    pull-request-bb = "!f() { username=$1; repo_slug=$2; \
        curl --user $username \
            https://bitbucket.org/fniessen/$(git repo-slug)/pull-requests/new?source=$(git current-branch)&t=1; }; f"
#+end_src

Add a comment in github pull request:

: curl -s -H \"Authorization: token ${GITHUB_TOKEN}\" -X POST -d '{\"body\": \"${text_pr}\"}' \"https://api.github.com/repos/${repository_name}/issues/${ghprbPullId}/comments\""

** List

- Pull Requests assigned to me
- Pull Requests I've created

- Open
- Merged
- Closed
- All

Git aliases for pull requests and other useful stuff
https://gist.github.com/metlos/9368527

For GitHub
: git ls-remote origin 'refs/pull/*'

** Show

** Check out pull request

Sometimes, just reading the code of a pull request might not be enough to verify
if it should be merged.  Maybe you want to add something, or some tests are
failing, and you want to run them locally on your computer.

*Check out* a *pull request* locally (for [[https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally][GitHub]] project):

#+begin_src conf
    # For GitHub.
    pr-gh = "!f() { git fetch origin pull/$1/head:pr/$1 \
                        && git checkout pr/$1; }; f"
#+end_src

With this Git alias, you can checkout any PR:

: git pr 5150

** Push changes to a pull request

In case you don't want to enter the branch to push to, you can use this small
snippet:

#+begin_src shell :tangle no
#!/bin/bash
tmpfile=$(mktemp)
repoSlug=$(git remote -v | grep '^upstream' | head -n1 | perl -lne 's/github.com:?\/?(.*)\/([^.]*)([.]git| )// or next; print $1,"/",$2')
prNumber=$(git rev-parse --abbrev-ref HEAD | cut -d/ -f 2)
curl -s https://api.github.com/repos/${repoSlug}/pulls/${prNumber} > $tmpfile
trap "{ rm -f $tmpfile; }" EXIT
headRef=$(cat $tmpfile | jq -r '.head.ref')
headSlug=$(cat $tmpfile | jq -r '.head.repo.full_name')
git push -f git@github.com:${headSlug} HEAD:${headRef}
#+end_src

For more details on pushing changes to a PR, please see [[https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/allowing-changes-to-a-pull-request-branch-created-from-a-fork][the official article]].

** Merge pull request

#+begin_src conf
    # For GitHub.
    mpr = "!f() { \
            declare currentBranch=\"$(git symbolic-ref --short HEAD)\"; \
            declare branch=\"${2:-$currentBranch}\"; \
            if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
                git fetch origin refs/pull/$1/head:pr/$1 && \
                git checkout -B $branch && \
                git rebase $branch pr/$1 && \
                git checkout -B $branch && \
                git merge --ff-only pr/$1 && \
                git delete-local-branch pr/$1; \
            fi \
        }; f"

    # merges given pull request into the current branch
    # the commit message will have the same for as if done using the
    # merge button on github.com
    #
    # git merge-pr origin 5
    merge-pr = "!sh -c '\
        user_and_repo=`git remote show $1 | grep \"Fetch URL\" | sed -E \"s/.*github.com[:\\/]([a-zA-Z_\\-]+)\\/([a-zA-Z_\\-]+)\\.git$/\\1 \\2/\"`; \
        user=`echo $user_and_repo | cut -d\" \" -f1`; \
        repo=`echo $user_and_repo | cut -d\" \" -f2`; \
        tmpfile=`mktemp`; \
        curl -si https://api.github.com/repos/$user/$repo/pulls/$2 > $tmpfile; \
        pull_author=`cat $tmpfile | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"login\\\": \\\"/) value=\\\\$2}{if (head && value) print value; if (head && value) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"`; \
        pull_ref=`cat $tmpfile | awk \"{if (/ *\\\"head\\\"/) head=\\\\$1; if (/ *\\\"ref\\\": \\\"/) label=\\\\$2}{if (head && label) print label; if (head && label) exit}\" | sed -E \"s/\\\"([^\\\"]+)\\\".*/\\1/\"`; \
        pull_title=`cat $tmpfile | grep \"\\\"title\\\": \" | sed \"s/^ *\\\"title\\\": \\\"//\" | sed \"s/\\\",$//\"`; \
        rm $tmpfile; \
        git fetch $1 pull/$2/head; \
        git merge --no-ff -m \"Merged pull request #$2 from $pull_author/$pull_ref\n\n$pull_title\" FETCH_HEAD; \
        ' -"
#+end_src

This is actually quite useful if you are a maintainer of a project on
GitHub.

There are two ways you can call it:

- ~git mpr 123~

  This will merge pull request number 123 on top of the current branch.

- ~git mpr 123 master~.

  This will merge pull request number 123 on top of the branch called master.

If you are using GitHub, you can easily merge a pull request using the web
interface, but if you want a bit more control over how you are merging the pull
requests (for example, I'm using the ~git merge --ff-only~ option, while GitHub
will use ~git merge --no-ff~), or you just want to merge a bunch of pull requests
without leaving your terminal -- this function will help you.

** Clean up old branch

#+begin_src conf
    pr-clean = delete-local-branch pr/$1
#+end_src

** How?

#+begin_src shell :tangle no
git fetch --all
#+end_src

This results in all pull requests available in the local repo in the local pull/
namespace.

To check out e.g. PR #42:

#+begin_src shell :tangle no
git create-branch foo refs/pull/upstream/42
#+end_src

** Who?

Extra script (called [[https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten][git-overwritten]]) which shows blame information about
original authors of lines changed or removed in a given branch:

#+begin_src shell :tangle no
git overwritten feature origin/master
#+end_src

This is useful when opening pull requests per GitHub Flow; you'll want your pull
request reviewed by colleagues but you might not be sure who to ping. With
git-overwritten you'll get the names of people who wrote the lines you just
changed, so you'll know who to @-mention when opening a pull request.

> So, given a patch (or a branch) together with a "base revision", you'd get
> a list of code chunks modified by that patch, then run "annotate" on the
> base revision, and look for those code chunks, collecting the names of
> corresponding authors.

Sounds like git-guilt (which I've just read about today), might be
relevant: https://bitbucket.org/tpettersen/git-guilt

** Find the pull request that introduced a commit

#+begin_src conf
    searchprcommit = "! sh -c 'git log $1..master --ancestry-path --merges --oneline | tail -n1 ' -"
#+end_src

Example:

#+begin_src shell :tangle no
> git searchprcommit a361e276756e6585258dda4014472ca6b3888a7c
b965075 Merge pull request #255 from yammer/s2s_auth_p4
#+end_src

In this case, the commit comes from pull request 255.

** Saved replies

GitHub allows to [[https://github.blog/2016-03-29-saved-replies/][save replies]]. You can set them in [[https://github.com/settings/replies][your GitHub settings]].  Here
are a couple of commonly used replies:

Missing changelog

#+begin_src text :tangle no
This still lacks a changelog entry. Please see [the changelog folder](../tree/master/changelog) for instructions.
Hence, I added the "pending changelog" label.
#+end_src

Missing spec PR

#+begin_src text :tangle no
This still needs a PR to the [specification](https://github.com/dlang/dlang.org/tree/master/spec) at [dlang.org](https://github.com/dlang/dlang.org). Hence, I added the label "missing spec PR".

Please refer to the [dlang.org CONTRIBUTING guide](https://github.com/dlang/dlang.org/blob/master/CONTRIBUTING.md) for instructions to build dlang.org locally. If you use Windows, don't worry, you can do your changes "blindly" and preview them at DAutoTest.
#+end_src

Phantom Zone

#+begin_src text :tangle no
This PR entered the Phantom Zone
-----------------------------------------------


This PR has entered the [Phantom Zone](http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org) as it still needs to have the reviewers' concerns addressed and rebased.

Reason for entering the Phantom Zone
----------------------------------------------------

This PR is nice, and normally I would revive such a PR if the author was no longer active. I would also revive it if it were an important bug fix or something of higher priority.  This PR, however, is just a refactoring, so I'm going to put it in the [Phantom Zone](http://forum.dlang.org/post/ouuutodvhmnghzbeoqen@forum.dlang.org) and close it for now.

How do I get this PR out of the Phantom Zone
-------------------------------------------------------------

Easy: Address the comments -> open a new PR (mention this one + short summary in the description).
#+end_src

* Pipelines

* Deployments (to different environments)

(see structure of actions in BitBucket)

#+begin_src conf
# Deploy a branch to review server (https://review-feature-1.example.com).
deploy-review =

# Deploy master to staging server (https://staging.example.com).
deploy-staging =

# Deploy master to production server (https://example.com).
deploy-prod =

  # # Deploy
  # staging = !git push heroku-staging $(git current-branch):master -f && git track 'Deployed to staging ' # push current branch to staging, can add more comments after
  # dev = !git push heroku-dev $(git current-branch):master -f && git track 'Deployed to dev ' # push current branch to dev
  # deploy = !git push heroku $(git current-branch):master -f && git track 'Deployed to production ' # push current branch to production


 # deploy='git push production master && terminal-notifier-notify -title "Deploy" -message "Deploy complete"'
 # stage='git push staging $(git current-branch):master'
#+end_src

* Issues

** Create Issue

Open an issue in the current repository.

#+begin_src conf
    create-issue = XXX
#+end_src

Issue template:

#+begin_src text :tangle ~/.issue_template.txt
### Expected behavior
### Actual behavior
### Steps to reproduce the behavior
#+end_src

See https://github.com/devspace/awesome-github-templates
and https://jwong.co.uk/blog/2018/09/01/useful-github-features/#emoji-organising

** List All Issues

#+begin_src conf
    issues = "!f() { username=$1; \
        curl --user $username \
            https://api.bitbucket.org/2.0/repositories/$username/$(git repo-slug)/issues \
            | jq --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]' \
            | sed \"s#\"open\"#$(tput setaf 2)&$(tput sgr0)#\"; }; f"
# --data-urlencode 'priority >= \"major\"'
#+end_src

Set color to red or green, depending on issue state.

#+begin_src conf :tangle no
# Works!  Need to put quotes around the URL!
curl -u $username -X GET 'https://api.bitbucket.org/2.0/repositories/$username/$(git repo-slug)/issues?pagelen=100' \
    | jq --compact-output '.values | .[] | [.id, .title, .type, .priority, .state, .votes, .assignee.display_name, .created_on, .updated_on]'
# curl -s -S
#+end_src

** List Open Issues

#+begin_src conf
    issues-open = XXX
#+end_src

** List My Issues (assigned to me)

#+begin_src conf
    issues-assigned-to-me = XXX
#+end_src

** List Issues I've created

#+begin_src conf
    issues-created-by-me = XXX
#+end_src

** Show Issue

Show an existing issue specified by NUMBER.

#+begin_src conf
    show-issue = XXX
#+end_src

** Open Issues in a web browser

#+begin_src conf
    browse-issues = '!f() { URL=$(git config --get remote.origin.url); open ${URL/.git}/issues/$1; }; f'
#+end_src

* Downloads

Download repository, tag or branch.

#+begin_src conf
    # Put everything in the current repo in a Zip archive.
    download-repository = "!f() { git archive ${1:-HEAD} --format=zip \
                                      -o $(basename $(git root))-commit-$(git rev-parse ${1:-HEAD}).zip; }; f"
#+end_src

* Settings

** SSH keys

List the user's public SSH keys:

#+begin_src shell :tangle no
curl -O https://github.com/fniessen.keys

curl https://api.bitbucket.org/2.0/users/fniessen/ssh-keys | jq '.values'
#+end_src

* ------------------------------------------------------------------------------

* Download repository

** Easily launch a temporary one-off Git server from any local repository, to enable a peer-to-peer Git workflow

#+begin_src conf
    serve = "daemon --verbose --export-all --base-path=.git --reuseaddr --strict-paths .git/"
    serve = "-c daemon.receivepack=true daemon --base-path=. --export-all --reuseaddr --verbose"
#+end_src

1. Run git serve. "Ready to rumble," it will report. Git is bad-ass.
2. Find out your IP address. Say it's 192.168.1.123.
3. Say "hey Jane, I'm not ready/able to push these commits up to origin, but you
   can fetch my commits into your clone by running git fetch
   git://192.168.1.123/"
4. Press ctrl+c when you don't want to serve that repo any longer.

* What if

... I'm working on =master= adding a simple feature. After a few minutes I realize
it was not so simple and it should have been better to work into a new branch.

http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master

* If you made a mistake

Absolutely read https://github.com/blog/2019-how-to-undo-almost-anything-with-git!

* If you get errors...
:PROPERTIES:
:header-args+: :tangle no
:END:

Many situations may cause "errors":

- merge conflicts (two people editing the same part of the same file)

- unmerged changes (another person committed a change before you did, so you
  need to merge their changes first)

- attempting to recover from a situation such as an accidental merge, and making
  the situation worse.

https://explainxkcd.com/wiki/index.php/1597:_Git

** Method 1

It is POSSIBLE that a safe way to recover from your problems is as follows:

#+begin_src shell
git stash
git reset --hard HEAD
git pull --ff-only
git stash apply
#+end_src

Of course, if any of the commands but the last fails, stop and ask for advice
again. If the last one reports merge conflicts, fix them by hand and run ~git add~
on each file after you fixed it. DO NOT use C-x v v after fixing a merge
conflict, since that runs both git add and git commit, and you are not ready for
the latter until all merge conflicts are dealt with.

In any case, do run git status before finally doing git commit. If all succeeds,
you can clean up with:

#+begin_src shell
git stash drop
#+end_src

** Alternative

If your =master= branch is busted, rename it to something else so that it's out of
the way:

#+begin_src shell
git branch -m master master-busted
#+end_src

Create a new branch =master= that tracks the origin:

#+begin_src shell
git branch --track master origin/master
#+end_src

Check it out (be careful, this will discard all your local changes):

#+begin_src shell
git checkout -f master
#+end_src

Make sure the =master= is up-to-date:

#+begin_src shell
git pull
#+end_src

** A GitHub test repository to experiment with conflicts

You can experiment with resolving a Git conflict with this repository:
https://github.com/brianleetest/testGit/blob/master/README.md

* GitHub tasks
:PROPERTIES:
:header-args+: :tangle no
:END:

# https://github.com/abo-abo/oremacs/blob/github/etc/org/wiki/git.org

** Force push

#+begin_src shell
git push --force origin master
#+end_src

*** Doc about push failure

If a push fails, that does not necessarily indicate a "bad state" -- it simply
represents that your history is different than what the remote server has, and
that the tip of the branch you are pushing to cannot simply be "fast-forwarded"
to your commit.

After a failed push, you are in no different state than you were before the push
(aside from a possibly puzzled mental state).

In your case, since you just want to commit and push in one operation, you
likely want to run ~git pull --rebase~, which would get those changes and then
automatically re-commit your work on top of them, as if you had those changes
all along.  You could then push.  So, something like:

#+begin_src shell :tangle no
# Commit all changes and attempt to push, pulling in changes if necessary and
# re-pushing; on failure, restore to previous state with changes uncomitted.
git commit -am Foo \
  && {
    git push \
      |   | { |
        { git pull --rebase || handle-pull-conflicts; } \
          && git push;
      }
  } \
  |   | { |
    git reset --soft HEAD^
    echo 'Commit failed.'
  }
#+end_src

But what if rebasing fails?  Then you are left resolving a conflict before you
can attempt the push operation again.  I do not know how you would want to
handle this.  ~handle-pull-conflicts~ might simply perform a ~git rebase --abort~
and exit with a non-zero status, or it may open a UI/shell to help resolve
changes.  If you are pushing after every change, this amounts to correcting
a single commit, so it might be worth having VC maintain the state here, allow
you to correct your commit, and then the vc-next-action would be to run ~git
rebase --continue~ after adding the files that conflicted.

This will be how the majority of Git users will resolve rejected pushes.

Does that make sense?

  [Aside: ~git pull~ without ~--rebase~ performs a ~git fetch && git merge
  whatever-branch-you-are-tracking~, which has the unfortunate side-effect of
  creating a merge commit if histories are different; this muddies up history.
  ~git pull --rebase~ performs ~git fetch && git rebase
  whatever-branch-you-are-tracking~.  The difference in the two styles of
  conflicts here is that, with rebasing, since you are re-committing each and
  every changeset, you may get multiple conflicts on any number of commits,
  whereas a merge will give you a single conflict that must be resolved at once.
  The benefit of rebasing is that it gives you a clean history and does not
  produce an unnecessary merge conflict which you would then push to origin,
  akin to leaving a bag of poop on origin's doorstep.]

For other users, it may represent a wholly different problem.  For example, if
I were to push to GNU ease.js' repo and get that message, that would be
a problem, since that means that someone has committed to my repository without
my permission.  An automatic pull and re-push would be bad in this case, since
that makes it look like I'm okay with that.

A failed push could also mean that you are tracking the wrong branch, or pushing
to the wrong repository.  Git allows you to set a "tracking branch", which can
be anything---a local branch, a remote branch, or a branch in an entirely
different repository, local or remote.  Further, you can override the tracking
branch by specifying which remote to push to as part of the ~push~ command.

In your case, you'd always want to respect the tracking branch and assume that
there are no problems pushing, since you use only one remote, and the tracking
branch is always a branch of the same name on origin.

A failed push could also mean that someone rudely rewrote history on the remote
branch (using ~git push --force~) and someone needs a talkin' to.

* References

- https://github.com/tj/git-extras
- https://hub.github.com/hub.1.html
- http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
# - [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]

* Free private repositories

I use the *free private repos* from https://bitbucket.org/.

* Use Git and SVN together

You can combine both Git and SVN on the same project codebase, *in the same
working directory*:

- http://www.netinstructions.com/git-and-svn-together/
- https://www.belatrixsf.com/blog/a-happy-way-to-combine-svn-and-git

* Run on all repositories

    print-reponame-then-run = "!f() { echo "======"; basename `git rev-parse --show-toplevel`; echo "======"; git "$@";}; f"

    # run commands for each repository in the current directory
    all = "!f() { ls -R -d */.git | sed s,/.git,, | xargs -I{} git -C {} print-reponame-then-run "$@"; }; f"
