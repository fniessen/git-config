#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION: Pretty format for `git log' and different helpful command aliases
#+KEYWORDS:  git, log, pretty format, alias
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2

#+SETUPFILE: ~/.dotfiles/org/theme-readtheorg.setup

#+EXPORT_EXCLUDE_TAGS: noexport
#+PROPERTY:  header-args :tangle ~/.dotfiles/home/.gitconfig :eval no

*Commit early, commit often*: it is a bad idea to do a lot of work without
committing.

* TODO See more Git configs (and aliases)

- https://github.com/alikins/gitconfig/blob/master/gitconfig
- https://github.com/GitAlias/gitalias

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *BE EXTREMELY CAREFUL*!
#+end_warning

* COMMENT Tasks

See https://blog.liip.ch/archive/2015/12/11/git-tips-tricks.html!!! XXX

** TODO Look at Git Power Routines [course]

https://www.youtube.com/playlist?list=PLDshL1Z581YYxLsjYwM25HkIYrymXb7H_

** TODO Read about Git

http://marlacorinne.4parkers.com/2012/07/20/git-pull-vs-git-fetch-then-merge/
https://adamcod.es/2014/12/10/git-pull-correct-workflow.html

** TODO Add doc about push failure

If a push fails, that does not necessarily indicate a "bad state"---it
simply represents that your history is different than what the remote
server has, and that the tip of the branch you are pushing to cannot
simply be "fast-forwarded" to your commit.

After a failed push, you are in no different state than you were before
the push (aside from a possibly puzzled mental state).

In your case, since you just want to commit and push in one operation,
you likely want to run `git pull --rebase`, which would get those
changes and then automatically re-commit your work on top of them, as if
you had those changes all along.  You could then push.  So, something
like:

#+begin_src sh :tangle no
# Commit all changes and attempt to push, pulling in changes if necessary and
# re-pushing; on failure, restore to previous state with changes uncomitted.
git commit -am Foo \
  && {
    git push \
      |   | { |
        { git pull --rebase || handle-pull-conflicts; } \
          && git push;
      }
  } \
  |   | { |
    git reset --soft HEAD^
    echo 'Commit failed.'
  }
#+end_src

But what if rebasing fails?  Then you are left resolving a conflict
before you can attempt the push operation again.  I do not know how you
would want to handle this.  `handle-pull-conflicts` might simply perform
a `git rebase --abort` and exit with a non-zero status, or it may open a
UI/shell to help resolve changes.  If you are pushing after every
change, this amounts to correcting a single commit, so it might be worth
having VC maintain the state here, allow you to correct your commit, and
then the vc-next-action would be to run `git rebase --continue` after
adding the files that conflicted.

This will be how the majority of Git users will resolve rejected pushes.

Does that make sense?

  [Aside: `git pull` without `--rebase` performs a `git fetch && git
  merge whatever-branch-you-are-tracking`, which has the unfortunate
  side-effect of creating a merge commit if histories are different;
  this muddies up history.  `git pull --rebase` performs `git fetch &&
  git rebase whatever-branch-you-are-tracking`.  The difference in the
  two styles of conflicts here is that, with rebasing, since you are
  re-committing each and every changeset, you may get multiple
  conflicts on any number of commits, whereas a merge will give you a
  single conflict that must be resolved at once.  The benefit of
  rebasing is that it gives you a clean history and does not produce an
  unnecessary merge conflict which you would then push to origin, akin
  to leaving a bag of poop on origin's doorstep.]

For other users, it may represent a wholly different problem.  For
example, if I were to push to GNU ease.js' repo and get that message,
that would be a problem, since that means that someone has committed to
my repository without my permission.  An automatic pull and re-push
would be bad in this case, since that makes it look like I'm okay with
that.

A failed push could also mean that you are tracking the wrong
branch, or pushing to the wrong repository.  Git allows you to set a
"tracking branch", which can be anything---a local branch, a remote
branch, or a branch in an entirely different repository, local or
remote.  Further, you can override the tracking branch by specifying
which remote to push to as part of the `push` command.

In your case, you'd always want to respect the tracking branch and
assume that there are no problems pushing, since you use only one
remote, and the tracking branch is always a branch of the same name on
origin.

A failed push could also mean that someone rudely rewrote history on the
remote branch (using `git push --force`) and someone needs a talkin' to.

** TODO Outsource and include private entries in .gitconfig

Git 1.7.10+ supports this syntax in =.gitconfig=:

#+begin_src conf :tangle no
[include]
    path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a =.gitconfig= file for your nonsensitive information and a git ignored
=.githubconfig= file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

Mix professional and personal Git configurations:

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

** TODO git-repos

http://osiux.com/2015-01-14-sincronizar-repositorios-git-repos.html

** TODO Git Quick Start For Emacs Devs

http://www.emacswiki.org/emacs/GitQuickStartForEmacsDevs

** TODO Work in progress which I can't commit (from Stephen J. Turnbull)
[2015-03-31 Tue 16:35]

#+begin_verse
 > > With git pull, if there are changes in the working directory, the
 > > merge (i.e. merge from remote/master into master) part of the
 > > operation is aborted before it starts, giving a message describing its
 > > refusal.  It does this even when there are no conflicts to deal with.
 >
 > What are we supposed to do in that case, if we're not yet ready to
 > commit our files?

If you have work-in-progress and feel unable to commit, but at the
same time feel the need to pull into that workspace, I suggest you get
up and walk around, fight off the pull urge, then finish the commit
after your head cools off.

If that isn't satisfactory, then

 > or putting our work into a new branch, like:
 >
 > --8<---------------cut here---------------start------------->8---
 > git checkout -b new-branch-name
 > git commit -a -m "Edited"
 > git checkout master
 > git pull
 > ...
 > --8<---------------cut here---------------end--------------->8---

is one way to go.  Another possibility is creating a new workspace,
with cp -a or similar.

If you need the pulled code for your work, then a quick stash is the
better idea.
#+end_verse

From [[gnus:INBOX#87vbhhi69x.fsf@uwakimon.sk.tsukuba.ac.jp][Email from Stephen J. Turnbull: Re: VC mode and git]]

** Git the simple guide

http://rogerdudler.github.io/git-guide/

** Git rebase branch

#+begin_src sh :tangle no
git pull --rebase -r origin master
#+end_src

* User                                                                 :ARCHIVE:

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
    name = John Doe
    email = johndoe@example.com

[github]
    user = jdoe
#+end_src

You should "override" the above with your personal details:

#+begin_src conf
[include]
    path = ~/.gitconfig_local
#+end_src

Or create a Git command to set email addresses for you:

#+begin_src conf
[alias]
    workprofile = config user.email \"john@work.com\"
#+end_src

* Core                                                                 :ARCHIVE:

#+begin_src conf
[core]
    editor = emacsclient
#+end_src

*Text viewer* for use by Git commands.

#+begin_note
When the ~LESS~ environment variable is unset, Git sets it to ~FRSX~.  If the ~LESS~
environment variable is set, Git does not change it at all.

We use ~-R~ in the command itself to be sure to *interpret the color codes* when Git
is run from /Windows/ Emacs (~C-x v l~), with /no/ value for the ~LESS~ /environment
variable/.
#+end_note

#+begin_src conf
    pager = "less -R"
#+end_src

#+begin_src conf
#    whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

#+begin_src conf :tangle no
    autocrlf = input
    safecrlf = true
#+end_src

#+begin_src conf
[gc]
    auto = 1
#+end_src

* Diff                                                                 :ARCHIVE:

#+begin_src conf
[diff]
    renames = copies
    renameLimit = 12000
    algorithm = patience
#+end_src

Git diff will use (i)ndex, (w)ork tree, (c)ommit and (o)bject instead of a/b/c/d
as prefixes for patches:

#+begin_src conf
    mnemonicprefix = true
#+end_src

#+begin_src conf
    tool = meld
#+end_src

* Apply                                                                :ARCHIVE:

#+begin_src conf
[apply]
    # Detect whitespace errors when applying a patch.
    whitespace = fix
#+end_src

* Pull                                                                 :ARCHIVE:

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
    rebase = preserve
#+end_src

(The merge commit doesn't get deleted!)

* Push                                                                 :ARCHIVE:

Push *only* the *current working branch* (sane pushing -- instead of pushing all
branches), with an added safety: only if it is /tracking/ a remote upstream branch
with the /same name/.

#+begin_src conf
[push]
    default = simple
#+end_src

(~simple~ is the default in Git 2.x)

* Merge                                                                :ARCHIVE:

#+begin_src conf
[merge]
    stat = true
    summary = true

    # Include summaries of merged commits in newly created merge commit messages.
    log = true
#+end_src

#+begin_src conf
    conflictstyle = diff3
#+end_src

- For small changes, ~git diff~ and ~vc-diff~ are perfect.
- For medium changes, ~magit~ is perfect.
- For large changes, [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD) is perfect.

** Emacs as a Git mergetool

Ediff or Emerge?  Or Magit???

#+begin_src conf :tangle no
[merge]
    tool = ediff

[mergetool "ediff"]
    cmd = emacsclient -c -a \"\"  --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
#+end_src

** Meld as Git mergetool

*How do I set up and use Meld as my git mergetool?*
See https://stackoverflow.com/questions/34119866/setting-up-and-using-meld-as-your-git-difftool-and-mergetool.

See ~auto-merge~ in
https://stackoverflow.com/questions/11133290/git-merging-using-meld (first and
second solution).

#+begin_src conf
    tool = meld
#+end_src

Firstly here is what the parameters mean:

- ~$LOCAL~ is the file in the *current branch* (e.g. ~master~).

- ~$REMOTE~ is the file in the *branch being merged* (e.g. ~branch_name~).

- ~$MERGED~ is the *partially merged file* with the merge conflict information in
  it.

- ~$BASE~ is the *common ancestor* of ~$LOCAL~ and ~$REMOTE~, this is to say the file as
  it was (before both changes) when the branch containing ~$REMOTE~ was originally
  created.

I suggest you use either:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$MERGED" "$REMOTE" --output "$MERGED"
#+end_src

or:

#+begin_src conf :tangle no
[mergetool "meld"]
    cmd = meld "$LOCAL" "$BASE" "$REMOTE" --output "$MERGED"
#+end_src

The choice is whether to use ~$MERGED~ or ~$BASE~ in between ~$LOCAL~ and ~$REMOTE~.

Either way, Meld will display 3 panes with:

- ~$LOCAL~ in the left pane,
- ~$REMOTE~ in the right pane and
- either ~$MERGED~ or ~$BASE~ in the middle pane.

In BOTH cases, *the middle pane is the file that you should edit to resolve the
merge conflicts*.  The difference is just in which starting edit position you'd
prefer:

- ~$MERGED~ for the file which contains the partially merged file with the merge
  conflict information or

- ~$BASE~ for the shared commit ancestor of ~$LOCAL~ and ~$REMOTE~.

#+begin_note
Since both cmd lines can be useful, I keep them both in my =.gitconfig= file. Most
of the time I use the ~$MERGED~ line and the ~$BASE~ line is commented out, but the
commenting out can be swapped over if I want to use the ~$BASE~ line instead.
#+end_note

#+begin_src conf
[mergetool "meld"]
    cmd = meld --diff "$LOCAL" "$MERGED" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
    # cmd = meld --diff "$LOCAL" "$BASE" "$REMOTE" --diff "$BASE" "$LOCAL" --diff "$BASE" "$REMOTE" --output "$MERGED"
#+end_src

* Rebase                                                               :ARCHIVE:

Also set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they
pull.

#+begin_src conf
[rebase]
    stat = true
#+end_src

* Grep                                                                 :ARCHIVE:

https://git-scm.com/docs/git-grep

#+begin_src conf
[grep]
    lineNumber = true

    # # Allow extended regular expressions
    # extendedRegexp = true

    fullName = true
#+end_src

* Color                                                                :ARCHIVE:

Instead of hardcoding colors, I suggest:

#+begin_src conf
[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto
    interactive = auto
#+end_src

See http://git-scm.com/docs/git-config for the ~slot~ list.

** Branch

#+begin_src conf
[color "branch"]
    current = cyan bold
    local = green bold
    remote = red bold
    upstream = red bold
    plain = yellow reverse
#+end_src

** Diff

#+begin_src conf
[color "diff"]
    plain = normal
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold
    commit = yellow
    whitespace = red reverse
#+end_src

** Status

#+begin_src conf
[color "status"]
    header = normal
    added = green
    updated = yellow
    changed = magenta
    untracked = red
    branch = cyan bold
    nobranch = red reverse
#+end_src

** Grep

#+begin_src conf
[color "grep"]
    filename = yellow bold
    linenumber = magenta bold
    match = green reverse bold
    separator = red bold
    selected = white bold
    context = black
    function = red
#+end_src

* Format

#+begin_src conf
[format]
    pretty = format:%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset
    # pretty = format:%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset
#+end_src

* Aliases

#+begin_src conf
[alias]
#+end_src

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~ to *print the current list of Git aliases*:

#+begin_src conf
    alias = "!git config -l | grep alias | cut -c 7- | sort"
#+end_src

#+begin_src conf
    type = cat-file -t
    dump = cat-file -p
#+end_src

(see http://gitimmersion.com/lab_11.html)

#+begin_src conf
    exec = '!exec '
#+end_src

#+begin_src conf
    # Show the diff between the latest commit and the current state
    d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

    # `git di $number` shows the diff between the state `$number` revisions ago and the current state
    di = !"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"

    # Pull in remote changes for the current repository and all its submodules
    p = !"git pull; git submodule foreach git pull origin master"

    # Commit all changes
    ca = !git add -A && git commit -av

    # Credit an author on the LATEST commit
    credit = "!f() { git commit --amend --author \"$1 <$2>\" -C HEAD; }; f"
#+end_src

Clean up your commits before publishing.  Before you push your commits to the
repository, it's good to revise them.  You can run the git interactive rebase to
squash your commits or modify commit messages.  The goal is to publish only
clean and relevant commits, no experiments or fixing typos.

#+begin_src conf
    # Interactive rebase with the given number of latest commits
    ireb = "!r() { git rebase -i HEAD~$1; }; r"
#+end_src

#+begin_src conf
    # Find branches containing commit
    fb = "!f() { git branch -a --contains $1; }; f"

    # Find tags containing commit
    ft = "!f() { git describe --always --contains $1; }; f"

    # Find commits by source code
    fc = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short -S$1; }; f"

    # Find commits by commit message
    fm = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short --grep=$1; }; f"
#+end_src

#+begin_src conf
    # Remove branches that have already been merged with master
    dm = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"
#+end_src

So, I can do things like ~git exec make~. This works because shell aliases are
always executed in the top-level directory.

** Debugging

Sometimes it's nice to see what is going on under the hood. Try this alias:

#+begin_src conf
    debug  = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git"
#+end_src

Just insert ~debug~ between ~git~ and whatever would usually follow; for example:

#+begin_src sh :tangle no
git debug unwip
#+end_src

** Abbreviations

Basic shortcuts.

#+begin_src conf
    ci = commit
#+end_src

#+begin_src conf
    cp = cherry-pick -x
    pick = cherry-pick -s
#+end_src

#+begin_src conf
    ls = ls-files
#+end_src

#+begin_src conf
    h = help
#+end_src

** TODO To sort out

#+begin_src conf
    grep4d = !sh -c 'git log -p -S'$1' $2' -

    # 2009-05-26  (merged-bed-bug) 6fe85ff regenerate rules Brad Bowman
    logdate = log --format=format:'%ad %d %h %s %an%n' --date=short
    brdate = !"sh -c 'for b in `git branch --no-merged` ; \
               do git logdate -1 -r $b --; done'"
#+end_src

** Getting a Git repository

*** Initialize a repository

#+begin_src conf
    this = !git init && git add . && git commit -m \"Initial commit\"
    this = !git init && ( [[ -n $(ls) ]] || touch .gitignore ) && git add . && git commit -m \"Initial commit\"
# plant?
#+end_src

*** Clone an existing repository

#+begin_src conf
    # Clone a repository including all submodules.
    cl = clone --recursive
#+end_src

** Check the status of your files

Give the status in the *short-format* (preceded by a line showing the /branch name/
and /tracking info/).

#+begin_src conf
    st = status -s -b
#+end_src

In the following example:

#+begin_example
M  README
 M lisp/mail/rmail.el
MM ChangeLog
#+end_example

- =README= is changed and *staged for commit* (it's *in the index*),
- =lisp/mail/rmail.el= is changed but *not staged for commit*, and
- =Changelog= is changed and staged for commit, then *changed again* and the new
  change is *not staged for commit*.

#+begin_note
Staging for commit is typically done by ~git add~.
#+end_note

** Ignoring files

*** ~git ignore~ command

Quickly add a file or directory to =.gitignore=:

#+begin_src conf
    ignore = "!f() { echo $1 >> \"${GIT_PREFIX}.gitignore\"; }; f"
#+end_src

List untracked *files ignored* by a =.gitignore= statement somewhere.

#+begin_src conf
    ignored = ls-files --others --ignored --exclude-standard
#+end_src

*** ~assume-unchanged~ command

Ignore/unignore changes to *tracked file(s)* without =.gitignore=:

#+begin_src conf
    assume = update-index --assume-unchanged
    unassume = update-index --no-assume-unchanged
#+end_src

It has to be configured for each project member individually.

#+begin_warning
As stated in [[http://stackoverflow.com/questions/23097368/git-ignore-vs-exclude-vs-assume-unchanged][git ignore vs. exclude vs. assume-unchanged]],
~git-update-index --assume-unchanged~ was never meant to ignore changes to tracked
files (*only to spare some stats*).  So do not suggest it as a means to achieve
that.
#+end_warning

List ignored files (*marked unchanged*):

#+begin_src conf
    assumed = "!git ls-files -v | grep '^h' | cut -c 3-"
#+end_src

** View your changes

*** Changes between the working tree and the index (staged for the next commit)

#+begin_src conf
    df = diff
    dw = diff --word-diff
#+end_src

*** Changes between the working tree and the latest commit (HEAD)

#+begin_src sh :tangle no
    diff-all = diff HEAD
#+end_src

*** Changes between the index (staged for the next commit) and the latest commit (HEAD)

Just before committing the *staged* changes, check what your commit changes:

#+begin_src conf
    dc = diff --cached
#+end_src

*** Precommit

This is a key part of my workflow. I run this before every commit to make sure
I don't need to use the undo commands.

#+begin_src conf
    precommit = diff --cached --diff-algorithm=minimal -w
#+end_src

*** Today

Quickly see what you've done today (commits that aren't merges on all branches):

#+begin_src conf
    today = !git log --since=midnight --author=\"`git config user.name`\" --no-merges --all
#+end_src

#+begin_src conf
    today-all = !git log --since=midnight --no-merges --all
#+end_src

*** Diff of branch

Getting the diff of a branch since it forked from another branch, or since the
last merge.

To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:

#+begin_src conf
    forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
#+end_src

It uses ~git merge-base~ to determine the fork-point (the commit that is common
to both the branches) and does a ~git diff~ between that commit and the second
branch.

Usage:

: git forkdiff <forked from branch> <forked branch> [git-diff-options]

Example:

: git forkdiff origin/master my_forked_branch --stat

*** Finding new commits

Diverging from ~origin/master~, whatever the branch?

#+begin_src conf
    log-local = log --oneline origin..HEAD
#+end_src

** Remove deleted files

Removing multiple files from a Git repo that have already been deleted from
disk:

#+begin_src conf
    rma = !git ls-files --deleted -z | xargs -0 git rm
#+end_src

** View the commit history

#+begin_src conf
    lp = log -p
    lg = log --decorate --oneline --graph
    lgr = log --decorate --date=relative --graph
    lga = log --decorate --date=short --graph

    ll = log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --numstat
    ld = log --pretty=format:"%C(yellow)%h\\ %C(green)%ad%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --date=short --graph
    ls = log --pretty=format:"%C(green)%h\\ %C(yellow)[%ad]%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --date=relative
    ls = "!git status -suno"

    lg50 = "!git log --graph --abbrev-commit --date=relative --pretty=format:'%x00%h%x00%s%x00%cd%x00%an%x00%d' | gawk -F '\\0' '{ printf \"%s\\033[31m%s\\033[0m %-50s \\033[32m%14s\\033[0m \\033[30;1m%s\\033[0m\\033[33m%s\\n\", $1, $2, gensub(/(.{49}).{2,}/, \"\\\\1...\",\"g\",$3), $4, $5, $6 }' | less -R"
    lg80 = "!git log --graph --abbrev-commit --date=relative --pretty=format:'%x00%h%x00%s%x00%cd%x00%an%x00%d' | gawk -F '\\0' '{ printf \"%s\\033[31m%s\\033[0m %-80s \\033[32m%14s\\033[0m \\033[30;1m%s\\033[0m\\033[33m%s\\n\", $1, $2, gensub(/(.{79}).{2,}/, \"\\\\1...\",\"g\",$3), $4, $5, $6 }' | less -R"
#+end_src

To see real *timeline* of who is working on what and when:

#+begin_src conf
    graph = log --graph -10 --branches --remotes --tags --format=format:'%C(yellow)%h %Creset %<(75,trunc)%s (%cN, %cr) %Cred%d' --date-order
#+end_src

#+begin_src conf
    ls-modified  = "!git status --porcelain -uno | awk 'match($1, /M/) {print $2}'"
    ls-added     = "!git status --porcelain -uno | awk 'match($1, /A/) {print $2}'"
    ls-deleted   = "!git status --porcelain -uno | awk 'match($1, /D/) {print $2}'"
    ls-renamed   = "!git status --porcelain -uno | awk 'match($1, /R/) {print $2}'"
    ls-copied    = "!git status --porcelain -uno | awk 'match($1, /C/) {print $2}'"
    ls-updated   = "!git status --porcelain -uno | awk 'match($1, /U/) {print $2}'"
    ls-staged    = "!git status --porcelain -uno | grep -P '^[MA]' | awk '{ print $2 }'"
    ls-untracked = "!git status --porcelain -uall | awk '$1 == \"??\" {print $2}'"
#+end_src

#+begin_src conf
    # List all untracked files.
    untracked = ls-files --others
#+end_src

#+begin_src conf
    heads = !"git log --format='%C(yellow)%h%Creset;%C(cyan)%H%Creset;%s %Cgreen<%an>%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"
#+end_src

#+begin_note
The ~git log~ command shows, by default, the "author date" -- not the "committer
date".
#+end_note

#+begin_src conf
    last = log -1 --stat
#+end_src

*** What changed

Prettier and concise ~whatchanged~:

#+begin_src conf
    what = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=short --stat
#+end_src

Prettier ~whatchanged~ with full diffs based on text search:

#+begin_src conf
    whatwhen = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=iso -p -S
#+end_src

*** List all the changed files in a commit

*List all the ~changed~ files in a commit*:

#+begin_src conf
    changed = show --pretty="format:" --name-only
    #+end_src

List all the changed files *between 2 commits*:

    #+begin_src conf
    diffn = diff --name-only
#+end_src

(See ~git what~ as well!)
(Use Tig?  Use git blame?)

XXX They don't show the same files (test with ~git changed HEAD~1~ and ~git diffn HEAD~1~) XXX

#+begin_src sh :tangle no
git changed                             # List files modified in last commit.
git changed bAda55                      # List files modified in this commit.
git changed bAda55..ff0021              # List files modified between those commits.
#+end_src

*** List all commits that changed a specific file

*List all commits* that changed a *specific file* (it accounts for renames!):

#+begin_src conf
    lf = "log --follow"
    logfile = log --follow -C
#+end_src

#+begin_warning
Put a end of options character (--) after lf and before the path!!
#+end_warning

*** Show a "top contributors" list

Show a "top contributors" list:

#+begin_src conf
    who = shortlog -n -s --
    # who = shortlog -n -s -e --
#+end_src

#+begin_note
The ~--~ signals the end of options, that the rest of the parameters are limiters.
#+end_note

** Undo things

*** Change your last commit

> The reason I don't commit a change immediately after I write it is
> that I want to test it in real (and varied) use.  Sometimes I find
> bugs and have to change it.  After some period in which it works well,
> I decide it is ready to install.

That is a good reason. However, for your information there is the variant “git
commit --amend”, which as the option suggests amends the *current* commit. Just
“git add“ the files you changed and run “git commit --amend”. It also lets you
edit the commit message. After discovering this option, I find I am less fearful
of making premature commits, since they are easily fixed. (But not after
pushing, of course. That way lies madness.)

#+begin_verse
The key to understanding that is that Git does not rewrite history, it creates
new history and calls that reality.  The commits in this history have different
IDs (because the ID is the content plus the ID of its parent, changing just one
commit means everything after it must change).  If you push this new history
(with --force) everyone else will have the old divergent history.  All their
work will be on top of this divergent history.  They have to do the surgery to
put their work on your new history.

When users do a "git pull", git doesn't store that you did a rebase (it would be
nice if it did) so it assumes something has gone wrong and refuses to pull.  Git
gets a human to look at the divergence and decide what to do with it.
Unfortunately, most people don't know what to do with a divergent repository.

And yes, this applies to amended commits.

This is a common question answered on Stack Overflow.
https://stackoverflow.com/questions/8939977/git-push-rejected-after-feature-branch-rebase

This answer isn't specifically about rebase, but it illustrates how Git creates
new history.
https://stackoverflow.com/questions/27692954/change-mail-address-in-each-commit/27709938#27709938
#+end_verse

Amend with the same message (without your editor prompting you for the message
you've already entered).

#+begin_src conf
    amend = "!git log -n 1 --pretty=tformat:%s%n%n%b | git commit -F - --amend"
#+end_src

Modify the *last* commit:

#+begin_src conf
    amend = commit -a -v --amend
    amend = commit --amend
# fixlastcommit?

# Commit changes to current head as amended commit.
    plus = commit --amend -a -C HEAD

# Append additional changes to the previous commit.
    fixup = commit --amend --reuse-message HEAD
#+end_src

Note that the ~-a~ switch which tells Git to automatically *stage all your changes*,
as if you ran ~git add .~ right before the commit.

#+begin_src sh :tangle no
git commit --amend                      # Correct the PREVIOUS commit, with the staged changes.
#+end_src

#+begin_warning
Never do this to a commit that you've already pushed to a remote repository.
#+end_warning

Solution for *amending older commits*:
https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit
(see 1st and 2nd answers!)

*** Unmodify a modified file / Undelete a deleted file

*Undo* the local changes *in the working directory*: roll a file back to its last
committed version.

#+begin_tip
It can also recover *deleted files* -- if the deletion has not been committed.
#+end_tip

#+begin_src conf
    unmodify = checkout --
    undelete = checkout --
#+end_src

#+begin_note
The two dashes there (canonically called the "bare double dashes") ensure that
the checkout command know that we are trying to roll back a file and not /change
branches/ (the typical usage of the checkout command).
#+end_note

When you grab a file from a previous time, it sits *in your index*, modified.

*** Unstage a staged file

*Remove* the specified files *from the index* (proposed next commit):

#+begin_src conf
    unstage = reset HEAD --
# OK
#+end_src

~unstage~ is the opposite of ~git add~. It lets you remove items from the staging
area.  This makes it a very useful tool when you're deciding which files to
stage for a commit.  If you've accidentally added something to the staging area,
just use ~unstage~ to remove it.

*** Throw away a commit

http://www.vogella.com/tutorials/Git/article.html#resetcommits
http://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
http://git-scm.com/2011/07/11/reset.html

~git reset~ is a simple way to undo changes that haven't been shared with anyone
else.

See « Undo 'git add' before commit ».

**** Do not touch the index file or the working tree at all

Go back before last commit, with files in uncommitted state:

#+begin_src conf
    uncommit = reset --soft HEAD~1
# OK (or undolast)
#+end_src

~uncommit~ *removes the last commit* from your repository, and *puts the changes
into your index*, keeping changes in the working tree. It's like going back in
time to the moment right before you committed.

#+begin_note
~uncommit~ here means to do just the reverse of commit, i.e. just like commit it
shouldn't touch the files's contents, only the metadata.
#+end_note

This is a useful technique in resuming work on an unfinished changeset.

**** Reset the index (but not the working tree)

Reset the previous commit, but *puts* all *the changes* from that commit *in the
working directory*:

#+begin_src conf :tangle no
    undo = reset --mixed HEAD~1
# popcommit?
#+end_src

#+begin_note
~--mixed~ with paths is deprecated; use ~git reset -- <paths>~ instead.
#+end_note

This is a useful technique if your pull fails to merge the new stuff from
upstream: ~git reset HEAD~1~, pull again, fix the conflicts, then commit your
changes again.

**** Reset both the index and working tree

Remove the last commit, *delete changes in your staging area and in your working
directory*:

#+begin_src conf
    wipe = reset --hard HEAD~1
# rollback?
#+end_src

If you reset work that you /never committed/, it is gone for good.  Too bad!  This
is quite a dangerous command (~git reset --hard~ is one of the few Git commands
which deletes information with no backout), and must be used with *extreme
caution*.

#+begin_warning
This command will also *overwrite changed files* in the working tree!
#+end_warning

#+begin_tip
If you have changes in your working directory or staging area, you'll probably
want to stash them before doing the above.
#+end_tip

Use ~git reset --hard @{u}~ to make sure the integration branch is up-to-date
before merging.

#+begin_note
~git reset --hard~ will not *remove untracked files*, where as ~git clean~ will remove
any files from the tracked root directory that are not under Git tracking.

*WARNING -- BE CAREFUL WITH THIS!*  It is helpful to run a dry-run with ~git clean~
first, to see what it will delete.

Use:
- ~git clean -n~ to see what ~git clean -f~ will do, so you can be sure it's what
  you want.
- ~git clean -f~ (to *remove* the *untracked files*) and
- ~git clean -fd~ (to also *remove untracked directories*).
#+end_note

Nuclear version:

#+begin_src conf
    nevermind = !git reset --hard HEAD && git clean -d -f
#+end_src

which:
- unstages changes in the index,
- discards changes in the working directory, and
- removes any new files.

XXX What is the difference with ~git checkout .~?  See
https://wiki.mozilla.org/Cjku/git#git-reset_and_git-checkout.

*** Revert a commit

Once you've pushed changes to a remote repository, it is considered dangerous to
modify the history because someone else may have already pulled it.

However, Git offers you an easy way to undo a patch by committing a change that
effectively reverses the patch in question. The simplest usage is to revert an
entire commit:

#+begin_src sh :tangle no
git revert [hash]
#+end_src

This creates a patch that is the opposite of commit ~[hash]~ and commits it to
your repository.

If you want to revert that commit without committing it (putting the reversion
into your index), use:

#+begin_src sh :tangle no
git revert -n [hash]
#+end_src

** Work with remotes

Starting with Git 1.7.0, ~@{u}~ is shorthand for the *current* branch's *upstream*
branch; e.g., ~origin/foo~ (or ~github/foo~, etc., since the remote doesn't have to
be called ~origin~) if the checked out branch is ~foo~.

#+begin_src conf
    r = "remote -v"
    remotes = remote -v
#+end_src

*** Pull

#+begin_note
~git pull~ is simply ~git fetch && git merge remote~.  Its ~--rebase~ option uses
~rebase~ instead of ~merge~.

That's exactly why some decide to avoid ~rebase~ (but to ~pull~ instead), because it
has bad effects if one merges from another branch and then wants to push.
#+end_note

The ~in~ command returns a list of *incoming* commits for the *current branch* --
after a ~git fetch~, to fetch down *all the data* it has for the *current remote* that
you do not --, the next time you do a merge.

#+begin_src conf
    in = !(echo "Please fetch origin before." && git log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset' ..@{u})
    inf = !(git remote update -p && git log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset' ..@{u})
#+end_src

#+begin_src conf
    incoming = log ..@{u} --stat
#+end_src

Show the changes between the last local commit and the *remote* branch:

Show a *single diffstat* (number of added and deleted lines for *all changed
files*):

#+begin_src conf
    in-what = diff --stat ...@{u}
#+end_src

#+begin_warning
The upstream diff ~in-what~ will show the negative of unpushed (rebased) commits,
if any, with the ~..~ notation --- not with the ~...~ notation!
#+end_warning

*** Update with local modifications

#+begin_note
~git pull~ with uncommitted changes can succeed if the newly pulled changes don't
touch the locally changed files, but will fail otherwise.  Which makes a lot of
sense.
#+end_note

Before doing work (in a new branch), *ensure that the working directory is*
*up-to-date* with the ~origin~ (pull and get latest for all submodules):

#+begin_src conf
    update = !git pull --rebase --prune $@ && git submodule update --init --recursive
    update = !git pull && git submodule update --init --recursive
#+end_src

[[https://gist.github.com/gitaarik/8735255][Git Submodules basic explanation]]

#+begin_src conf
    up = pull --rebase --autostash
# `up' used many times
#+end_src

See [[http://aanandprasad.com/git-up/][git-up]] (no longer maintained).

#+begin_warning
Use with care: the final stash application after a successful rebase might
result in non-trivial conflicts.
#+end_warning

With *all versions* of Git, I recommend using ~git up~ instead of ~git pull~.

#+begin_src conf
    up = "!f() { git remote update -p; git merge --ff-only @{u} ; }; f"
# `up' used many times
#+end_src

is pretty safe.  It will abort the merge if it can't be done using fast-forward.
(In other words, if the local branch has diverged from the remote.)

See https://stackoverflow.com/questions/15316601/in-what-cases-could-git-pull-be-harmful

#+begin_src conf
    # Rebasing non-linear changes (when the fast-forward merge is not possible).
    upr = "!f() { git remote update -p; git rebase -p @{u} ; }; f"
#+end_src

*** Update all local branches

Pull all:

#+begin_src conf
    pull-all = !"old=$(git rev-parse --abbrev-ref HEAD) ; for b in $(git for-each-ref refs/heads --format='%(refname)') ; do git checkout ${b#refs/heads/} ; git pull --ff-only ; done; git checkout ${old}"
#+end_src

See http://stackoverflow.com/questions/4318161/can-git-pull-all-update-all-my-local-branches
(+ interesting comments about *rebase vs merge during a pull*!)

#+begin_src sh :tangle ~/.dotfiles/bin/git-up-all
#!/bin/bash

REMOTES="$@";
if [ -z "$REMOTES" ]; then
    REMOTES=$(git remote);
fi
REMOTES=$(echo "$REMOTES" | xargs -n1 echo)

CLB=$(git branch -l | awk '/^\*/{print $2}');

echo "$REMOTES" | while read REMOTE; do
    git remote update $REMOTE
    git remote show $REMOTE -n \
        | awk '/merges with remote/ {print $5" "$1}' \
        | while read line; do
              RB=$(echo "$line" | cut -f1 -d" ");
              ARB="refs/remotes/$REMOTE/$RB";
              LB=$(echo "$line" | cut -f2 -d" ");
              ALB="refs/heads/$LB";
              NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2> /dev/null) + 0));
              NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2> /dev/null) + 0));
              if [ "$NBEHIND" -gt 0 ]; then
                  if [ "$NAHEAD" -gt 0 ]; then
                      echo -e "$LB \tis $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB.  Could not be fast-forwarded";
                  elif [ "$LB" = "$CLB" ]; then
                      echo -e "$LB \twas $NBEHIND commit(s) behind of $REMOTE/$RB.  Fast-forwarding merge...";
                      echo git merge -q $ARB;
                  else
                      echo -e "$LB \twas $NBEHIND commit(s) behind of $REMOTE/$RB.  Resetting local branch to remote...";
                      echo git branch -l -f $LB -t $ARB > /dev/null;
                  fi
              fi
    done
done
#+end_src

*** Delete all old local branches

Remove local branches no longer on remote (by deleting the local ones that show
they are "gone" in ~git branch -vv~):

#+begin_src conf
    # Git config alias escaping...  This DOES NOT work.
    # prunelocal = !sh -c 'git fetch -p && git branch -vv | grep \": gone]\" | awk \"{print $1}\" | xargs git branch -d'

    # Here is a correct solution (using bash as a command-line).
    prunelocal = "!f() { git fetch -p && git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -d ; }; f"

    # Here is a correct solution (which does not need access to the remote Git repo).
    prunelocal = "!f() { git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -d ; }; f"
#+end_src

*** Get timestamp of last pull

#+begin_src conf
    when = !stat -c %y .git/FETCH_HEAD
#+end_src

*** Push

It is useful to know if you have any *local commits* that are not in the remote
branch.

#+begin_note
It is a good idea to examine what you are about to push, before actually doing
so, because fixing mistakes before pushing is much easier (see the next
section). To do that, use the command "git diff origin/master". If you want to
show your unpushed commits with their commit log messages, use "git show
origin/master.." instead. If you only have one local commit you want to push,
just "git show" is enough.

> It is not clear to me how these two differ.  Does "git show origin/master.."
> output everything that "git diff origin/master" outputs, plus log messages?

Yes, that's the only real difference between them, when you have no
uncommitted changes.  (When you do have uncommitted changes, "git
diff" will include them, while "git show" will not.)
#+end_note

The ~out~ command returns a list of *unpushed* (outgoing) commits for the *current
branch*, the next time you do a push.

#+begin_src conf
    out = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset' @{u}..
#+end_src

#+begin_src conf
    outgoing = log @{u}.. --stat
#+end_src

This causes git log to show all commits reachable from ~HEAD~ excluding those
reachable from the upstream branch. The ~@{u}..~ argument is equivalent to
~@{u}..HEAD~, where ~HEAD~ stands for the last commit in your local branch, but ~HEAD~
can be omitted for shorthand purposes.

#+begin_note
Use ~git push -u origin new/branch~ to push the ~new/branch~ branch to the ~origin~
remote and to set up tracking.
#+end_note

If you want to see all *unpushed* commits from *all branches*, do this:

#+begin_src conf
    out-all = log --branches --not --remotes --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset'
#+end_src

*** Sync

#+begin_src conf
    sync = !git pull && git push
#+end_src

#+begin_src conf
    sync = !git update && git co master && git pull && git co @{-1}
#+end_src

That's rather basic - it doesn't actually rebase my branch that I'm on.

Let's do a slightly different command: ~resync~

#+begin_src conf
    # git resync -> sync repository and rebase current branch.
    resync = !sh -c 'BRANCH_NAME=master && git co master && git fe && git reset --hard origin/master && git rebase master'
#+end_src

** Tag

List tags using (better) version sorting (if your ~sort~ supports it):

#+begin_src conf
    # Show verbose output about tags.
    tags = tag -l
    tags = !git tag | sort -V
#+end_src

You can do a lot better with:

#+begin_src conf
    releases = log --decorate --oneline --simplify-by-decoration --all
#+end_src

Show the last tag:

#+begin_src conf
    lasttag = describe --tags --abbrev=0
#+end_src

** Branch

See http://nuclearsquid.com/writings/git-tricks-tips-workflows/ for more
interesting stuff, such as:

- When branching off a remote branch, automatically let the local branch track
  the remote branch:

- When pushing without giving a refspec, push the current branch to its upstream
  branch. See the git config man page for more possible options.

#+begin_src conf
    co = checkout
#+end_src

#+begin_src conf
    # Switch to a branch, creating it if necessary.
    go = checkout -B

    cob = checkout -b
# grow?
#+end_src

#+begin_note
I think the recommended approach is to create a branch pointing at a
specific commit. So:

git checkout -b test_branch 7e09ef09

Otherwise you're in a "detached head" state, which can have odd results.
The branch method is at least a little more stable.
#+end_note

#+begin_note
I usually branch off from the commit before the offending
commit and stay there until things are resolved (unless I'm able to
resolve it myself).

Or I branch off master and revert the offending commit until things are
resolved, ie. like so
 git checkout master
 git checkout -b sb-master
 git revert sha1-of-offending-commit

(that's what I did with gnus, when cram-md5 auth disappeared from nnimap
with SSL/TLS...)
#+end_note

Checkout [[http://nvie.com/posts/a-successful-git-branching-model/][common branches]] (useful if you have feature branches):

#+begin_src conf
    master = checkout master
    develop = checkout develop
#+end_src

*List all branches* (both remote-tracking and local branches), showing SHA1 and
commit subject line for each head, along with the name of the upstream branch
(if any).

#+begin_src conf
    br = branch -a -vv
#+end_src

~git bclean~ is meant to be run from your master (or default) branch and does the
cleanup of merged branches.

#+begin_src conf
    bclean = "!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"
#+end_src

When I'm done with this topic branch and I want to clean everything up on my
local machine, I use git bdone:

1. Switch to master (though you can specify a different default branch)
2. Run git up to bring master up to speed with the origin
3. Delete all branches already merged into master using another alias,
   ~git bclean~

#+begin_src conf
    bdone = "!f() { git checkout ${1-master} && git up && git bclean ${1-master}; }; f"
#+end_src

See http://haacked.com/archive/2014/07/28/github-flow-aliases/.

#+begin_src conf
    # Current branch.
    cb = "name-rev --name-only HEAD"
#+end_src

*** How to git diff all changes since branching from master?

Show all commits in a git branch since original branching point from master:

#+begin_src conf
    sincemaster = diff master...
#+end_src

When you use three dots, ~git diff~ finds the merge-base between the left and
right side commit SHA-1s (as obtained from the names, or defaulting to ~HEAD~) and
substitutes that in for the left-side SHA-1. The right-side SHA-1 (as resolved
from the name) remains intact.

** Merge

Merging means to *bring the contents of another branch* (possibly from an external
repository) *into the current branch*. [...]  Merging is performed by an automatic
process that identifies changes made since the branches diverged, and then
applies all those changes together.

#+begin_src conf
    # Will only try to "merge" if your current HEAD commit is in the branch
    # you're merging in.  This will allow you to merge some commits whilst being
    # sure you won't get conflicts.
    ff = merge --ff-only
    ff = merge --ff-only @{u}

    # Avoid a fast-forward commit.
    mm = merge --no-ff
#+end_src

*** Undo the merge

If you tried a merge which resulted in complex conflicts and want to start over,
you can recover with ~git merge --abort~.  It will allow you to *undo the merge*,
even if it is a fast-forward merge.

*** Dry run (do not make changes)

Naive (but slow) way:

#+begin_src sh :tangle no
rm -Rf /tmp/repository
cp -r repository /tmp/
cd /tmp/repository
git merge ...
# ... If successful, do the real merge.
#+end_src

#+begin_warning
It won't work just cloning to =/tmp=; you need a *copy* in order *to be sure that
uncommitted changes will not conflict*.
#+end_warning

Performing a Git merge with *no commit* and *no fast-forward* will merge the two
code bases together -- it will *modify your working copy*.  This will allow you to
examine, test, and undo the merge if required.

#+begin_src sh :tangle no
git merge --no-commit --no-ff $BRANCH
#+end_src

#+begin_warning
If your repository is a live Web server, then you could be serving files with
conflicts in.  That's why you should *never* be *handling merges on a live Web
server*!  Fix up the ~prod~ branch (on your development box) and then push it to
the real webserver with ~git pull --ff-only~.
#+end_warning

See if the merge is applicable to the current working tree and/or the index file
and *detects conflicts*:

#+begin_src conf
    mergetest = "!f() { git merge --no-commit --no-ff $1; git merge --abort; echo 'Merge aborted'; }; f"

    # Check how the merge of `dev' into master will go: git mergedryrun dev.
    mergedryrun = "!f() { grep -q 'changed in both' <<< $(git merge-tree $(git merge-base FETCH_HEAD $1) FETCH_HEAD $1) && echo 'Merge conflict detected' || echo 'Merged cleanly'; }; f"

    # Extract the "changed in both" lines as well as the conflicting parts.
    mergedryrunconflicts = "!f() { git merge-tree $(git merge-base $1 $2) $1 $2 | sed -n '/+<<<<<<< .our/,/+>>>>>>> .their/p;/^changed in both/{n;N;N;s/^/#/mg;p}' | cdiff; }; f"
#+end_src

*** Branch/Integration manager

If you're the Branch/Integration manager, you can use these aliases to *merge*
stuff (to select the entirety of either our or their file in a 3-way merge).

Often, during a merge, you know you want to take a file from one side
wholesale. The following aliases expose the ~ours~ and ~theirs~ commands which will
let you pick a file(s) from the current branch or the merged branch
respectively:

#+begin_src conf
    ours = "!f() { git checkout --ours $@ && git add $@; }; f"
    theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
#+end_src

Best (and safest) way to merge a Git local branch into ~master~:

#+begin_src sh :tangle no
git checkout master
git pull origin master                  # Get the latest changes from the remote.
git merge test
git push origin master

git branch -d branch_name               # Delete local branch.
#+end_src

Best answer I have seen on ~git merge~ *strategies*:
https://stackoverflow.com/questions/366860/when-would-you-use-the-different-git-merge-strategies

*** List conflicted files

Unmerged files after a merge failure:

#+begin_src conf
    conflicts = "!git ls-files -u | cut -f 2 | sort -u"
#+end_src

** Prepare a release

Save a repo as a tarball:

#+begin_src conf
    export = archive -o latest.tar.gz -9 --prefix=latest/
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
    record = !sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit, it
will ~reset~ the index.

** Stash

A *stash* is nothing but a *(temporary) branch*.

~git stash~ makes a temporary copy of the changes in your *index* (staging area) and
*working tree*, and clears the decks so you can easily work on something else; it
reverts your local modifications, allowing you to get rid of some incomplete
changes:

#+begin_src conf :tangle no
git stash save "DESCRIBE WHAT YOU DID HERE"
#+end_src

This command is useful in saving all changes not ready to be committed and the
user wants to have an updated repository.

#+begin_tip
Use ~git stash~ if Git refused to merge because it foresees conflicts.
#+end_tip

Take named stash:

#+begin_src conf
    snapshot = !git stash save "Snapshot: $(date +\"%F %a %R\")" && git stash apply "stash@{0}"
#+end_src

When you're done, with ~git stash apply~ (top stash by default), you're back where
you were.  But if that doesn't work, for whatever reason, you can use any of
Git's other branch merging tools to put things back they way you want them.

Be aware that, unlike ~git stash apply~ (though it has its use), ~git stash pop~
*deletes the applied stash* -- /only/ if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!

#+begin_src sh :tangle no
git stash clear
#+end_src

You can operate on the "stash" ref as if it were any other ref.

#+begin_src conf
    ss = stash save
    sl = stash list
    sa = stash apply
#+end_src

#+begin_src conf
    stashes = stash list
#+end_src

#+begin_src conf
    save = stash save
    savepatch = stash save --patch
    savescratch = stash save --keep-index
    pop = stash pop
#+end_src

~git stash pop~ removes the most recent stash or any stash specified and applies
changes as a merge.  If merge fails, the stash is not removed from the list and
must be removed manually.

#+begin_src conf
    hide = stash
    unhide = stash apply
# bad aliases, used by some instead to mean assume and unassume...
#+end_src

#+begin_src conf
    stp = stash pop
    std = stash drop
#+end_src

#+begin_src conf
    stashdiff = stash show -p -w stash@{0}
    stash-unapply = !git stash show -p --no-textconv --binary | git apply -R
#+end_src

#+begin_src conf
    # plop = "!git stash && git pull && git stash pop"
    # up = !git stash && git pull origin master && git stash apply
# `up' used many times
#+end_src

#+begin_warning
The above approach is *unsafe*: if there's nothing to stash, the first command
will do nothing, and then ~stash pop~ will unstash some random stuff from before.
#+end_warning

#+begin_src conf
# cleanpull
# update (like svn? if we add a git reset in front?)
# sync
#+end_src

... but read "you're not using git as it was intended" on
https://news.ycombinator.com/item?id=2301765.

#+begin_src conf
    sp = ![[ -z $(git status --porcelain -uno) ]] && git pull || git stash && git pull && git stash pop
    spp = ![[ -z $(git status --porcelain -uno) ]] && git pull || git stash && git pull && git push && git stash pop
#+end_src

#+begin_src sh :tangle no
git stash list                          # Show a list of all stashes.
git stash show                          # Show the last stash.
git stash show stash@{1}                # Show the previous stash.

git stash apply                         # Apply the stash only, don't delete it.
git stash drop                          # Drop the last stash.
git stash drop stash@{1}                # Drop a previous stash.
#+end_src

XXX What about ~git stash --include-untracked~ and ~git stash pop~?

Git's fix is to ask you to commit (or stash) before you pull (which is fetch
followed by merge). XXX

Alternative to ~stash~ (writing a commit with a default message):

1. Do a regular ~commit~:

   #+begin_src sh :tangle no
   git add -A && git commit -m 'WIP'       # Add all changes (including untracked files).
   #+end_src

2. Do some other work...

3. Return to previous work:

   #+begin_src sh :tangle no
   git reset --mixed                       # Reset the previous commit (but
                                           # keeps all the changes from that
                                           # commit in the working directory).

   git reset --soft                        # Or this one???
   #+end_src

   Or, if I merely need to modify the *previous* commit:

   #+begin_src sh :tangle no
   git commit -a --amend
   #+end_src

   The ~-a~ adds any modifications and deletions of existing files to the commit
   but ignores brand new files.

   The ~--amend~ launches your default commit editor and lets you change the
   commit message of the *most recent* commit.

*** From git help stash

       Pulling into a dirty tree
           When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple git pull will let
           you move forward.

           However, there are cases in which your local changes do conflict with the upstream changes, and git pull refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:

               $ git pull
                ...
               file foobar not up to date, cannot merge.
               $ git stash
               $ git pull
               $ git stash pop

       Interrupted workflow
           When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to
           make the emergency fix, like this:

               # ... hack hack hack ...
               $ git checkout -b my_wip
               $ git commit -a -m "WIP"
               $ git checkout master
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git checkout my_wip
               $ git reset --soft HEAD^
               # ... continue hacking ...

           You can use git stash to simplify the above, like this:

               # ... hack hack hack ...
               $ git stash
               $ edit emergency fix
               $ git commit -a -m "Fix in a hurry"
               $ git stash pop
               # ... continue hacking ...

       Testing partial commits
           You can use git stash save --keep-index when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:

               # ... hack hack hack ...
               $ git add --patch foo            # add just first part to the index
               $ git stash save --keep-index    # save all other changes to the stash
               $ edit/build/test first part
               $ git commit -m 'First part'     # commit fully tested change
               $ git stash pop                  # prepare to work on all other changes
               # ... repeat above five steps until one commit remains ...
               $ edit/build/test remaining parts
               $ git commit foo -m 'Remaining parts'

       Recovering stashes that were cleared/dropped erroneously
           If you mistakenly drop or clear stashes, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stashes that are still in your repository, but not reachable any
           more:

               git fsck --unreachable |
               grep commit | cut -d\  -f3 |
               xargs git log --merges --no-walk --grep=WIP

** Search for commits

*** Whose commit message mention your regexp

If you want to find all commits (*across all branches*, showing names and status
of changed files) where *log message* matches a specified pattern (regular
expression), use ~find~.

#+begin_src conf
    find = "log --all -i --grep"
#+end_src

Add ~--name-status~ to show only names and status of *changed files*.

For example, to find all commits referencing bug #382:

#+begin_src sh :tangle no
git find "Bug #382"
#+end_src

To find commits that match *either* of patterns (implicit *OR* semantic), you can
use:

#+begin_src sh :tangle no
git log --grep=<foo> --grep=<bar>
#+end_src

To find /commit/ that has *both* line matching first and line matching second
somewhere, use the *AND* semantic:

#+begin_src sh :tangle no
git log --all-match --grep=<foo> --grep=<bar>
#+end_src

Show the *last commit* which *message matches a regex*:

#+begin_src sh :tangle no
# Show the last commit which has the word "fix" in its message.
git show :/fix

# Show the last merge commit.
git show :/^Merge
#+end_src

*** String added/removed in Commit contents (Diff)

If you want to find all commits where a *string* was *added or removed* in the /file
contents/ (to be more exact: where its *number of occurrences changed*),
i.e. search the /commit contents/, use ~-S~.

You can dig up commits that have, for example,
- removed calls to a specific function, or
- added a certain CSS classname.

#+begin_note
If the number of times "foo" appears in the file is the same before and after
a commit, it will not match using ~-S "foo"~.
#+end_note

#+begin_src sh :tangle no
git log --all -S "foo" --since="1 week ago"
#+end_src

By default, ~-S~ accepts a string, but can be modified to accept a *regexp* with
~--pickaxe-regex~.

*** Whose changes include your regexp

String contained in added/removed lines from Commit contents (Diff)

With the ~-G~ option, the commit is shown in the log if your *regexp* search matches
any *line* that was added, removed, or changed.

#+begin_src sh :tangle no
git log --all -G "foo" --since="1 week ago"
#+end_src

** Grep (Print lines matching a pattern)

*** Pattern in working directory (and its subdirectories)

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- files registered in the index, rather than the working tree,
- for your regexp in some files from another branch (XXX does not work? XXX).

#+begin_note
It doesn't search files that are not revisioned (untracked, excluded/ignored,
etc.).
#+end_note

More readable output, with *grouping* (like Ripgrep, ~rg~):

#+begin_src conf
    rg = "grep --break --heading"
#+end_src

Broader search (*case-insensitive*), output without grouping:

#+begin_src conf
    gr = "grep -i -I"
#+end_src

*** Find files that contain some terms, not necessarily on the same line

Match any of these patterns, but print matches only from files that have /all/ of
them (files must have lines that match each of them):

#+begin_src sh :tangle no
git grep --all-match -e <regexp> -e <regexp>
#+end_src

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
    lost = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

** COMMENT Git and Subversion

#+begin_src conf :tangle no
    spull = svn rebase
    spush = svn dcommit
    slog = svn log --oneline --show-commit
#+end_src

#+begin_src conf :tangle no
    cvs-full-log = log --reverse --pretty=format:'%B\n--------------------------------------------\n'
    cvsmerge = merge --no-ff --log
#+end_src

** Tips and tricks

Directed Acyclic Graph:

#+begin_src conf
    graphviz = "!f() { echo 'digraph git {' ; git log --pretty='format:  %h -> { %p }' \"$@\" | sed 's/[0-9a-f][0-9a-f]*/\"&\"/g' ; echo '}'; }; f"
#+end_src

** Find out if a change is part of a release

#+begin_src conf
    sha1-tag = '!f() { git name-rev --name-only "$@"; }; f'
#+end_src

The ~name-rev~ command indicates the *position of a commit relative to tags* in the
project. For example, ~v2.3~5~ means that this commit is located 5 commits *before*
the v2.3 tag -- we can be certain that this change is part of v2.3, then.

** Rename branch

Sometimes we name a branch poorly or maybe we thought the name was "good" but
not meaningful to the work we are doing.

To rename the branch locally:

#+begin_src conf
    rename = branch -m
#+end_src

One thing to keep in mind is that this command works in two different ways:

- if we are on the branch we want to rename, we can just ~git rename new-name~.
- If we are not on the branch, we have to use ~git rename target-branch new-name~.

** List branches that contain a given commit ID (SHA1)

Filter the list of *branches* to only those which have the given *commit ID* among
their ancestors.

#+begin_src conf
    where = "branch -a --contains"
#+end_src

This also includes *remote tracking branches* in the list, that is "local
branches that have a direct relationship to a remote branch".

List all *tags* that contain a commit ID:

#+begin_src sh :tangle no
git tag --contains a2c71a6
#+end_src

** See which changes from a branch are already present upstream

While on "feature" branch:

#+begin_src sh :tangle no
git cherry -v master
#+end_src

#+begin_example
+ 497034f2 Listener.new now accepts a hash of options
- 2d0333ff cache the absolute images path for growl messages
+ e4406858 rename Listener#run to #start
#+end_example

The ~cherry~ command is useful to see which commits have been cherry-picked from
a development branch to the stable branch, for instance. This command compares
changes on the current (~feature~) branch to upstream (~master~) and indicates which
are present on both with the ~-~ sign. Changes still missing from upstream are
marked with ~+~.

** Show blame information about original authors of lines changed or removed

#+begin_src conf
    praise = blame -w
    archeology = blame -w -C -n
    whodoikill = blame -w -C -n
#+end_src

Extra script (called [[https://github.com/mislav/dotfiles/blob/master/bin/git-overwritten][git-overwritten]]) which shows blame information about
original authors of lines changed or removed in a given branch:

#+begin_src sh :tangle no
git overwritten feature origin/master
#+end_src

This is useful when opening pull requests per GitHub Flow; you'll want your pull
request reviewed by colleagues but you might not be sure who to ping. With
git-overwritten you'll get the names of people who wrote the lines you just
changed, so you'll know who to @-mention when opening a pull request.

> So, given a patch (or a branch) together with a "base revision", you'd get
> a list of code chunks modified by that patch, then run "annotate" on the
> base revision, and look for those code chunks, collecting the names of
> corresponding authors.

Sounds like git-guilt (which I've just read about today), might be
relevant: https://bitbucket.org/tpettersen/git-guilt

* What if

... I'm working on master adding a simple feature. After a few minutes I realize
it was not so simple and it should have been better to work into a new branch.

http://stackoverflow.com/questions/2569459/git-create-a-branch-from-unstaged-uncommited-changes-on-master

* If you made a mistake

# Absolutely read https://github.com/blog/2019-how-to-undo-almost-anything-with-git!

This will help when we need to change the most recent commit.

'git commit --amend' is already a dangerous operation. Someone might forget that
the current commit has already been pushed, and amend it anyway. What will they
do then?

Try to push the result, see a message about non-fast-forward pushes being not
allowed, then go along the "If pushing fails" section (pull, resolve, commit,
push), and we'll have two similar commits in the history.

I don't really know how to proof the instructions against that.

* Recover from problems
:PROPERTIES:
:header-args+: :tangle no
:END:

It is POSSIBLE that a safe way to recover from your problems is as follows:

#+begin_src sh
git stash
git reset --hard HEAD
git pull --ff-only
git stash apply
#+end_src

Of course, if any of the commands but the last fails, stop and ask for advice
again. If the last one reports merge conflicts, fix them by hand and run “git
add” on each file after you fixed it. DO NOT use C-x v v after fixing a merge
conflict, since that runs both git add and git commit, and you are not ready for
the latter until all merge conflicts are dealt with.

In any case, do run git status before finally doing git commit. If all succeeds,
you can clean up with:

#+begin_src sh
git stash drop
#+end_src

** Review which file have conflicts

This command tells you which files have conflicts after merging.

#+begin_src conf :tangle ~/.dotfiles/home/.gitconfig
    conflicts = diff --name-only --diff-filter=U
    unmerged = diff --name-only --diff-filter=U
#+end_src

** Alternative

If your master branch is busted, rename it to something else so that it's out of
the way:

#+begin_src sh
git branch -m master master-busted
#+end_src

Create a new branch ~master~ that tracks the origin:

#+begin_src sh
git branch --track master origin/master
#+end_src

Check it out (be careful, this will discard all your local changes):

#+begin_src sh
git checkout -f master
#+end_src

Make sure the ~master~ is up-to-date:

#+begin_src sh
git pull
#+end_src

** A GitHub test repository to experiment with conflicts

You can experiment with resolving a Git conflict with this repository:
https://github.com/brianleetest/testGit/blob/master/README.md

* GitHub tasks
:PROPERTIES:
:header-args+: :tangle no
:END:

# https://github.com/abo-abo/oremacs/blob/github/etc/org/wiki/git.org

** Force push

#+begin_src sh
git push --force origin master
#+end_src

** Push tags

#+begin_src sh
git push --tags
#+end_src

** Get user pubkeys

#+begin_src sh
curl https://github.com/abo-abo.keys
#+end_src

** Routine

#+begin_src sh
git fetch --all
#+end_src

This results in all pull requests available in the local repo in the local pull/
namespace.

To check out e.g. PR #42:

#+begin_src sh
git checkout -b foo refs/pull/upstream/42
#+end_src

* Git workflows

It may be helpful to do a some background reading on workflows with Git.  Here
is the gitworkflows man page:
https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html

Other doc on branch models:

http://nvie.com/posts/a-successful-git-branching-model/
http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html
http://williamdurand.fr/2012/01/17/my-git-branching-model/

* References

- https://github.com/tj/git-extras
- https://hub.github.com/hub.1.html
- http://stackoverflow.com/questions/2423777/is-it-possible-to-create-a-remote-repo-on-github-from-the-cli-without-ssh

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
# - [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]

* Free private repositories

I use the *free private repos* from https://bitbucket.org/.

