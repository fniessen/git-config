#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en

#+PROPERTY:  tangle ~/.gitconfig
#+PROPERTY:  eval no

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *be extremely careful*!
#+end_warning

* Tasks

** TODO Outsource and include private entries in .gitconfig

Git (1.7.10+) now supports this syntax in .gitconfig:

#+begin_src conf :tangle no
[include]
    path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a .gitconfig file for your nonsensitive information and a git ignored
.githubconfig file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

** TODO Mix professional and personal git configurations

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

* User

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
	name = Fabrice Niessen
	email = (concat \"fniessen\" at-sign \"pirilampo.org\")
#+end_src

You should "override" the above with your personal details.

* Core

#+begin_src conf
[core]
	editor = emacsclient
	pager = less
	whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

#+begin_src conf :tangle no
	autocrlf = input
	safecrlf = true
#+end_src

* Diff

#+begin_src conf
[diff]
	renames = copies
	algorithm = patience
#+end_src

* Merge

#+begin_src conf
[merge]
	stat = true
#+end_src

* Grep

#+begin_src conf
[grep]
	fullname = true
	linenumber = true
#+end_src

* Pull

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
	rebase = true
#+end_src

* Rebase

Also set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they
pull.

#+begin_src conf
[rebase]
	stat = true
#+end_src

* Push

#+begin_src conf
[push]
	default = current
#+end_src

* Color

#+begin_src conf
[color]
	ui = auto
	branch = auto
	diff = auto
	status = auto
	interactive = auto
#+end_src

** Branch

#+begin_src conf
[color "branch"]
	current = yellow reverse
	local = yellow
	remote = green
#+end_src

** Diff

#+begin_src conf
[color "diff"]
	meta = yellow bold
	frag = magenta bold
	old = red bold
	new = green bold
	whitespace = red reverse
#+end_src

** Status

#+begin_src conf
[color "status"]
	added = yellow
	changed = green
	untracked = cyan
#+end_src

** Grep

#+begin_src conf
[color "grep"]
	filename = bold yellow reverse
	linenumber = magenta bold
	match = green reverse bold
	separator = red bold
	selected = white bold
	context = black
	function = red
#+end_src

* Aliases

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~:

#+begin_src conf
[alias]
	alias = "!git config -l | grep alias | cut -c 7-"
#+end_src

** Abbreviations

Basic shortcuts:

#+begin_src conf
	br = branch
	ci = commit
	cl = clone
	co = checkout
	cp = cherry-pick
	dc = diff --cached
	df = diff
	ls = ls-files
	st = status -s
#+end_src

** Pretty log

XXX %cd or %ad? See default of git log!

#+begin_src conf
	lg = log --decorate --oneline --graph
	lgr = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an> %C(bold blue)(%cd)%Creset' --date=relative --graph
	lga = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an> %C(bold blue)(%cd)%Creset' --date=short --graph
	y = diff "@{yesterday}"
	who = shortlog -n -s --

	# Show files ignored by git:
	ign = ls-files -o -i --exclude-standard
#+end_src

#+begin_src conf
	head = !"git log -n1"
	heads = !"git log --format='%C(yellow)%h%Creset;%C(cyan)%H%Creset;%s %Cgreen<%an>%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"

	# prettier and concise whatchanged
	what = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%cd)%Creset' --date=short --stat

	# prettier whatchanged with full diffs based on text search
	whatwhen = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%cd)%Creset' --date=iso -p -S
#+end_src

** Getting the diff of a branch since it forked from another branch, or since the last merge

To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:

#+begin_src conf
	forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
#+end_src

It uses ~git merge-base~ to determine the fork-point (the commit that is common
to both the branches) and does a ~git diff~ between that commit and the second
branch.

Usage

: git forkdiff <forked from branch> <forked branch> [git-diff-options]

Example

: git forkdiff origin/master my_forked_branch --stat

** Search

#+begin_src shell :tangle no
# Git Search
alias ggFind='git log -g --pretty=format:%h -S'
alias gFind='git log --pretty=format:%h -S'
alias gGFing='git log --pretty=format:%h -G'
alias gCFind='git log --grep="string in a commit message" --all --pretty=format:%h'
#+END_SRC

git log

*** Commit message

If you want to find all commits where /commit message/ contains given word, use
~--grep~.

#+begin_src conf
#+end_src

*** Commit contents (Diff)

If you want to find all commits where a *string* was added or removed in the /file
contents/ (to be more exact: where its *number of occurrences changed*),
i.e. search the /commit contents/, use ~-S~.

By default, ~-S~ accepts a string, but can be modified to accept a regexp with
~--pickaxe-regex~.

~-G~ looks for *differences* whose added or removed *line* matches the given *regexp*.

I think you'd want this with --all as well (whether using -S or -G).

*** Code base

~git grep~

... better speed.

#+begin_src conf
	gr = "grep --break --heading"
#+end_src

XXX works only on files in Git (bypassing ignored files)?

** Tags

List tags using (better) version sorting (if your sort supports it):

#+begin_src conf
	tags = !sh -c 'git tag | sort -V'
#+end_src

** Merge aliases

If you're the Branch/Integration manager, you can use these aliases to merge
stuff:

#+begin_src conf
	ours = "!f() { git co --ours $@ && git add $@; }; f"
	theirs = "!f() { git co --theirs $@ && git add $@; }; f"
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
	record = ! sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit it
will ~reset~ the index.

** Reset Commands

#+begin_src conf
	r = reset
	r1 = reset HEAD^
	r2 = reset HEAD^^
	rh = reset --hard
	rh1 = reset HEAD^ --hard
	rh2 = reset HEAD^^ --hard
#+end_src

** Stash operations

#+begin_src conf
	sl = stash list
	sa = stash apply
	ss = stash save
#+end_src

XXX What about ~git stash --include-untracked~ and ~git stash pop~?

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
	lost = !"git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

* References

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
