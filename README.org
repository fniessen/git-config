#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en

#+EXPORT_EXCLUDE_TAGS: noexport
#+PROPERTY:  tangle ~/.gitconfig
#+PROPERTY:  eval no

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *be extremely careful*!
#+end_warning

* Tasks

** TODO Outsource and include private entries in .gitconfig            :ARCHIVE:

Git (1.7.10+) now supports this syntax in .gitconfig:

#+begin_src conf :tangle no
[include]
	path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a .gitconfig file for your nonsensitive information and a git ignored
.githubconfig file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

Mix professional and personal Git configurations:

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

* User                                                                 :ARCHIVE:

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
	name = John Doe
	email = johndoe@example.com
#+end_src

You should "override" the above with your personal details:

#+begin_src conf
[include]
	path = .gitconfig.user
#+end_src

* Core                                                                 :ARCHIVE:

#+begin_src conf
[core]
	editor = emacsclient
	pager = less
	whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

#+begin_src conf :tangle no
	autocrlf = input
	safecrlf = true
#+end_src

* Diff                                                                 :ARCHIVE:

#+begin_src conf
[diff]
	renames = copies
	algorithm = patience
#+end_src

* Merge                                                                :ARCHIVE:

#+begin_src conf
[merge]
	stat = true
#+end_src

* Grep                                                                 :ARCHIVE:

#+begin_src conf
[grep]
	fullname = true
	linenumber = true
#+end_src

* Pull                                                                 :ARCHIVE:

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
	rebase = true
#+end_src

* Rebase                                                               :ARCHIVE:

Also set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they
pull.

#+begin_src conf
[rebase]
	stat = true
#+end_src

* Push                                                                 :ARCHIVE:

Push *only* the *current working branch* (sane pushing -- instead of pushing all
branches), with an added safety: only if it is /tracking/ a remote upstream branch
with the /same name/.

#+begin_src conf
[push]
	default = simple
#+end_src

(~simple~ is the default in Git 2.x)

* Color                                                                :ARCHIVE:

#+begin_src conf
[color]
	ui = auto
	branch = auto
	diff = auto
	status = auto
	interactive = auto
#+end_src

** Branch

#+begin_src conf
[color "branch"]
	current = yellow reverse
	local = yellow
	remote = green
#+end_src

** Diff

#+begin_src conf
[color "diff"]
	meta = yellow bold
	frag = magenta bold
	old = red bold
	new = green bold
#+end_src

#+begin_src conf
	whitespace = red reverse
#+end_src

** Status

#+begin_src conf
[color "status"]
	added = green
	changed = yellow
	untracked = red
#+end_src

#+begin_src conf
	branch = green
	nobranch = red reverse
#+end_src

#+begin_src conf
	updated = magenta
#+end_src

** Grep

#+begin_src conf
[color "grep"]
	filename = bold yellow reverse
	linenumber = magenta bold
	match = green reverse bold
	separator = red bold
	selected = white bold
	context = black
	function = red
#+end_src

* Aliases

If you forget your aliases and don't want to open =.gitconfig= just to check, type
~git alias~:

#+begin_src conf
[alias]
#+end_src

Print the current list of Git aliases:

#+begin_src conf
	alias = "!git config -l | grep alias | cut -c 7- | sort"
#+end_src

** Abbreviations

Basic shortcuts.

#+begin_src conf
	ci = commit
#+end_src

#+begin_src conf
	cp = cherry-pick
	ls = ls-files
#+end_src

** Getting a Git repository

*** Initialize a repository

#+begin_src conf
	this = !git init && git add . && git commit -m \"Initial commit\"
#+end_src

*** Clone an existing repository

#+begin_src conf
	cl = clone
#+end_src

** Check the status of your files

#+begin_src conf
	st = status -s -b
#+end_src

** Ignoring files

XXX Quickly add a file or directory to =.gitignore=:

#+begin_src conf
	ignore = !([ ! -e .gitignore ] && touch .gitignore) | echo $1 >> .gitignore
#+end_src

Ignore/unignore file without =.gitignore=:

#+begin_src conf
	untrack = update-index --assume-unchanged
#+end_src

#+begin_src conf
	unignore = update-index --no-assume-unchanged
#+end_src

Show files ignored by Git:

#+begin_src conf
	ignored = ls-files -o -i --exclude-standard
#+end_src

** View your changes

Differences since the *last commit* (~HEAD~):

#+begin_src conf
	df = diff
#+end_src

Just before committing the staged changes, check what your commit changes
(differences between the *staging area* and the *last commit*):

#+begin_src conf
	dc = diff --cached
#+end_src

#+begin_src conf
	y = diff "@{yesterday}"
#+end_src

Getting the diff of a branch since it forked from another branch, or since the
last merge.

To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:

#+begin_src conf
	forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
#+end_src

It uses ~git merge-base~ to determine the fork-point (the commit that is common
to both the branches) and does a ~git diff~ between that commit and the second
branch.

Usage

: git forkdiff <forked from branch> <forked branch> [git-diff-options]

Example

: git forkdiff origin/master my_forked_branch --stat

** Remove deleted files

Removing multiple files from a Git repo that have already been deleted from
disk:

#+begin_src conf
	r = !git ls-files --deleted -z | xargs -0 git rm
#+end_src

** View the commit history

#+begin_src conf
	lg = log --decorate --oneline --graph
	lgr = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=relative --graph
	lga = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=short --graph
#+end_src

#+begin_src conf
	heads = !"git log --format='%C(yellow)%h%Creset;%C(cyan)%H%Creset;%s %Cgreen<%an>%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"
#+end_src

#+begin_note
The ~git log~ command shows, by default, the "author date" (not the "committer
date").
#+end_note

#+begin_src conf
	last = log -n 1
#+end_src

Prettier and concise ~whatchanged~:

#+begin_src conf
	what = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=short --stat
#+end_src

Prettier ~whatchanged~ with full diffs based on text search:

#+begin_src conf
	whatwhen = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ad)%Creset' --date=iso -p -S
#+end_src

Show a "top contributors" list:

#+begin_src conf
	who = shortlog -n -s --
#+end_src

#+begin_note
The ~--~ signals the end of options, that the rest of the parameters are limiters.
#+end_note

** Undo things

*** Change your last commit

Amend with the same message (without your editor prompting you for the message
you've already entered).

#+begin_src conf
	amend = "!git log -n 1 --pretty=tformat:%s%n%n%b | git commit -F - --amend"
#+end_src

Modify the previous commit:

#+begin_src conf
	amend = commit --amend --no-edit
	amend = commit -a --amend
#+end_src

XXX Choose one!

The ~-a~ adds any modifications and deletions of existing files to the commit but
ignores brand new files. The ~--amend~ launches your default commit editor and
lets you change the commit message of the most recent commit.

*** Unstage a staged file

Remove the specified files from the index (next commit):

#+begin_src conf
	unstage = reset HEAD --
#+end_src

*** Unmodify a modified file

#+begin_src conf
	undo = checkout --
#+end_src

*** XXX

Go back before last commit, with files in uncommitted state:

#+begin_src conf
	uncommit = reset --soft HEAD~1
#+end_src

Reset the previous commit, but keeps all the changes from that commit in the
working directory:

#+begin_src conf
	undo = reset --mixed HEAD~1
#+end_src

Undo the last commit:

#+begin_src conf
	wipe = reset --hard HEAD~1
#+end_src

If you reset work that you /never committed/, it is gone for good. Too bad!

** Work with remotes

*** Pull

Unpulled:

#+begin_src conf
	in = pull --dry-run
#+end_src

Before doing work (in a new branch), ensure that the working directory is
up-to-date with the ~origin~:

#+begin_src conf
	up = !git pull --rebase --prune $@ && git submodule update --init --recursive
#+end_src

Pull all:

#+begin_src conf
	pull-all = !"old=$(git rev-parse --abbrev-ref HEAD) ; for b in $(git for-each-ref refs/heads --format='%(refname)') ; do git checkout ${b#refs/heads/} ; git pull --ff-only ; done; git checkout ${old}"
#+end_src

*** Push

Unpushed:

#+begin_src conf
	out = log --branches --not --remotes --color --graph --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%ar)%Creset' --abbrev-commit
#+end_src

** Tag

List tags using (better) version sorting (if your ~sort~ supports it):

#+begin_src conf
	tags = !git tag | sort -V
#+end_src

Show the last tag:

#+begin_src conf
	lasttag = describe --tags --abbrev=0
#+end_src

** Branch

#+begin_src conf
	co = checkout
	cob = checkout -b
#+end_src

Checkout common branches (useful if you have feature branches):

#+begin_src conf
	master = checkout master
	develop = checkout develop
#+end_src

List all branches (both remote-tracking and local), showing sha1 and commit
subject line for each head, along with the name of the upstream branch (if any).

#+begin_src conf
	br = branch -a -vv
#+end_src

** Merge

If you're the Branch/Integration manager, you can use these aliases to *merge*
stuff (to select the entirety of either our or their file in a 3 way merge).

Often, during a merge, you know you want to take a file from one side
wholesale. The following aliases expose the ours and theirs commands which will
let you pick a file(s) from the current branch or the merged branch
respectively:

#+begin_src conf
	ours   = "!f() { git checkout --ours $@ && git add $@; }; f"
	theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
#+end_src

** Prepare a release

Save a repo as a tarball:

#+begin_src conf
	export = archive -o latest.tar.gz -9 --prefix=latest/
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
	record = !sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit it
will ~reset~ the index.

** Stash

A *stash* is nothing but a *(temporary) branch*.

~git stash~ makes a temporary copy of the *index* and the *working tree*, and clears
the decks so you can easily work on something else: it resets the branch you
were on so those contents are no longer there.

When you're done, with ~git stash apply~ (top stash by default), you're back where
you were.  But if that doesn't work, for whatever reason, you can use any of
Git's other branch merging tools to put things back they way you want them.

Get rid of some incomplete changes:

#+begin_src conf :tangle no
git stash save --keep-index
#+end_src

Be aware that, unlike ~git stash apply~ (though it has its use), ~git stash pop~
*deletes the applied stash* -- /only/ if the stash is cleanly applied.  If there are
conflicts, Git will not remove it (but it will still apply it)!

#+begin_src conf :tangle no
git stash clear
#+end_src

You can operate on the 'stash' ref as if it were any other ref.

#+begin_src conf
	sl = stash list
	sa = stash apply
	ss = stash save "name_stash"
#+end_src

XXX What about ~git stash --include-untracked~ and ~git stash pop~?

Alternative: do a regular ~commit~ and a ~reset --soft~ instead.

** Search

#+begin_src shell :tangle no
# Git Search
alias ggFind='git log -g --pretty=format:%h -S'
alias gFind='git log --pretty=format:%h -S'
alias gGFing='git log --pretty=format:%h -G'
alias gCFind='git log --grep="string in a commit message" --all --pretty=format:%h'
#+end_src

*** Commit messages

If you want to find all commits where /commit message/ contains given word, use
~--grep~.

#+begin_src conf :tangle no
	git log --grep
#+end_src

*** Commit contents (Diff)

If you want to find all commits where a *string* was added or removed in the /file
contents/ (to be more exact: where its *number of occurrences changed*),
i.e. search the /commit contents/, use ~-S~.

By default, ~-S~ accepts a string, but can be modified to accept a regexp with
~--pickaxe-regex~.

~-G~ looks for *differences* whose added or removed *line* matches the given *regexp*.

I think you'd want this with ~--all~ as well (whether using ~-S~ or ~-G~).

*** Code base

The advantages of ~git grep~ are not only its *speed*, and the fact it only searches
your project files (i.e. no files in =.git=), but also that is allows you to
interface with your repository's Git database; for example, for searching:

- for your regexp in some files from another branch,
- files registered in the index, rather than the working tree.

#+begin_src conf
	gr = "grep --break --heading"
#+end_src

XXX works only on files really in Git (bypassing ignored files)?

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
	lost = "!git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

** Git and Subversion

#+begin_src conf
	spull = "svn rebase"
	spush = "svn dcommit"
#+end_src

* References

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
- [[https://ochronus.com/git-tips-from-the-trenches/][Git tips from the trenches]]
- [[file:~/Public/Repositories/emacs/admin/notes/git-workflow][Emacs Git workflow]]
