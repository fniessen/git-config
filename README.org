#+TITLE:     Git configuration file
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en

#+PROPERTY:  tangle ~/.gitconfig
#+PROPERTY:  eval no

* Overview

The following configures interesting global settings for Git. These are stored
in the =.gitconfig= file located in the user home directory.

#+begin_warning
Note that tangling this file will override whichever =~/.gitconfig= file you
might have. So *be extremely careful*!
#+end_warning

* Tasks

** TODO Outsource and include private entries in .gitconfig

Git (1.7.10+) now supports this syntax in .gitconfig:

#+begin_src conf :tangle no
[include]
    path = /path/to/file
#+end_src

So you can split your gitconfig configurations across multiple files, e.g. you
can have a .gitconfig file for your nonsensitive information and a git ignored
.githubconfig file containing your private github token.

See http://travisjeffery.com/b/2012/03/using-gits-include-for-private-information-like-github-tokens/

** TODO Mix professional and personal git configurations

http://monkeypatch.me/blog/mixing-professional-and-personal-git-configurations.html

* User

Setting your user name and e-mail address is important because Git stores the
committer and author of a change in every commit.

#+begin_src conf
[user]
	name = Fabrice Niessen
	email = (concat \"fniessen\" at-sign \"pirilampo.org\")
#+end_src

You should "override" the above with your personal details.

* Core

#+begin_src conf
[core]
	editor = emacsclient
	pager = less
	whitespace = fix,-indent-with-non-tab,trailing-space,space-before-tab,cr-at-eol
#+end_src

* Diff

#+begin_src conf
[diff]
	renames = copies
	algorithm = patience
#+end_src

* Merge

#+begin_src conf
[merge]
	stat = true
#+end_src

* Grep

#+begin_src conf
[grep]
	fullname = true
#+end_src

* Pull

Configure Git to do the ~--rebase~ part automatically.

#+begin_src conf
[pull]
	rebase = true
#+end_src

* Rebase

Also set ~rebase.stat = true~, so the ~diffstat~ output is still shown when they
pull.

#+begin_src conf
[rebase]
	stat = true
#+end_src

* Push

#+begin_src conf
[push]
	default = current
#+end_src

* Color

#+begin_src conf
[color]
	ui = auto
	branch = auto
	diff = auto
	status = auto
	interactive = auto
#+end_src

** Branch

#+begin_src conf
[color "branch"]
	current = yellow reverse
	local = yellow
	remote = green
#+end_src

** Diff

#+begin_src conf
[color "diff"]
	meta = yellow bold
	frag = magenta bold
	old = red bold
	new = green bold
	whitespace = red reverse
#+end_src

** Status

#+begin_src conf
[color "status"]
	added = yellow
	changed = green
	untracked = cyan
#+end_src

** Grep

#+begin_src conf
[color "grep"]
	filename = bold yellow reverse
	linenumber = magenta bold
	match = green reverse bold
	separator = red bold
	selected = white bold
	context = black
	function = red
#+end_src

* Alias

** Abbreviations

Common shortcuts:

#+begin_src conf
[alias]
	st = status
	br = branch
	df = diff
	ci = commit
	co = checkout

	dc = diff --cached
	ls = ls-files
#+end_src

** Dangling

- Dangling blob = Change(s) that made it to the staging area/index but never got
  committed. One thing that is amazing with Git is that once it gets added to
  the staging area, you can always get it back because these blobs behave like
  commits!!

- Dangling commit = A commit that isn't linked to any branch or tag either
  directly or by any of its ancestors. You can get these back too!

#+begin_src conf
	lost = !"git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset  %s' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"
#+end_src

** Pretty log

XXX %cd or %ad? See default of git log!

#+begin_src conf
	lg = log --decorate --oneline --graph
	lgr = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an> %C(bold blue)(%cd)%Creset' --date=relative --graph
	lga = log --decorate --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an> %C(bold blue)(%cd)%Creset' --date=short --graph
	y = diff "@{yesterday}"
	who = shortlog -sn --

	# Show files ignored by git:
	ign = ls-files -o -i --exclude-standard
#+end_src

#+begin_src conf
	head = !"git log -n1"
	heads = !"git log --format='%C(yellow)%h%Creset;%C(cyan)%H%Creset;%s %Cgreen<%an>%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"

	# prettier and concise whatchanged
	what = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%cd)%Creset' --date=short --stat

	# prettier whatchanged with full diffs based on text search
	whatwhen = log --pretty=format:'%C(yellow)%h%C(auto)%d%Creset %s %Cgreen<%an>%Creset %C(bold blue)(%cd)%Creset' --date=iso -p -S
#+end_src

** Cherrypick style recording

Ask interactively which patch hunk to commit, and then do the commit:

#+begin_src conf
	record = ! sh -c '(git add -p -- $@ && git commit) || git reset' --
#+end_src

It will not only do ~git add -p~ (with an optional file list), but it will also
immediately do the ~commit~. Upon abandonment of either the add or the commit it
will ~reset~ the index.

**  Getting the diff of a branch since it forked from another branch, or since the last merge

To see the changes in a branch since it was forked from another branch, or
since the last merge with the origin branch, you can add this alias:

#+begin_src conf
	forkdiff = !bash -c 'git diff $(git merge-base "$1" "$2") "$2" "${@: 3}" ' -
#+end_src

It uses ~git merge-base~ to determine the fork-point (the commit that is common
to both the branches) and does a ~git diff~ between that commit and the second
branch.

Usage

: git forkdiff <forked from branch> <forked branch> [git-diff-options]

Example

: git forkdiff origin/master my_forked_branch --stat

* References

- [[https://git.wiki.kernel.org/index.php/Aliases][Git SCM Wiki - Aliases]]
